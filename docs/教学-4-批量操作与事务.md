# 教学 Part 4: 批量操作与事务

## 🎯 功能分析 - Linus 式思考

### Linus 的三个问题

**1. "这是个真问题还是臆想出来的？"**

✅ **真实问题**：
- 用户需要删除 20 个已完成的待办事项，现在要点击 20 次"删除"按钮
- 用户想批量完成一组相关的任务（如"本周的所有会议准备任务"），逐个点击效率太低
- 前端发送 20 个请求 = 20 次网络往返 = 慢且浪费带宽

**为什么需要批量操作？**
- **用户体验**：一次操作完成多个任务
- **性能优化**：减少网络往返（20 次 → 1 次）
- **数据一致性**：要么全成功，要么全失败（使用事务）

**2. "有更简单的方法吗？"**

💡 **核心思路**：数据库事务 + 循环处理

**笨方法**（前端循环调用）：
```javascript
// ❌ 低效：20 个待办 = 20 次网络请求
for (const id of selectedIds) {
    await fetch(`/api/v1/todos/${id}`, { method: 'DELETE' });
}
// 问题：某个删除失败了怎么办？数据不一致！
```

**聪明方法**（后端批量处理 + 事务）：
```go
// ✅ 高效：1 次请求，事务保证原子性
func BatchDelete(ids []int) error {
    tx.Begin()
    for _, id := range ids {
        tx.Exec("DELETE FROM todos WHERE id = ?", id)
    }
    tx.Commit()  // 要么全删除，要么全不删除
}
```

**3. "会破坏什么吗？"**

⚠️ **潜在风险**：
- 批量操作中某个 ID 不存在 → 是整体失败还是跳过？
- 事务锁定表 → 批量 1000 个 ID 会不会锁太久？
- 恶意请求 → 传入 10000 个 ID 会不会拖垮数据库？

✅ **安全设计**：
- **部分失败策略**：记录失败的 ID，返回给前端
- **批量大小限制**：最多 100 个 ID/次（防止滥用）
- **事务超时**：SQLite 默认有锁超时（5 秒）
- **向后兼容**：新增独立端点，不影响现有单个操作 API

---

## 📚 核心知识讲解

### 1. 数据库事务的 ACID 特性

**ACID** 是数据库事务的四大保证：

**A - Atomicity（原子性）**
```go
// 要么全成功，要么全失败
tx.Begin()
tx.Exec("DELETE FROM todos WHERE id = 1")  // ✅ 成功
tx.Exec("DELETE FROM todos WHERE id = 2")  // ❌ 失败（不存在）
tx.Rollback()  // 回滚，id=1 的删除也被撤销
```

**C - Consistency（一致性）**
```go
// 数据库约束始终被满足
tx.Begin()
tx.Exec("UPDATE todos SET status = 'invalid'")  // ❌ 违反约束
tx.Commit()  // 失败，数据库拒绝提交
```

**I - Isolation（隔离性）**
```go
// 两个事务并发执行，互不影响
// 事务 A 读取 id=1 → 看到旧值
// 事务 B 修改 id=1 → 未提交
// 事务 A 再次读取 id=1 → 仍然是旧值（隔离）
```

**D - Durability（持久性）**
```go
// 提交后，数据永久保存（即使断电）
tx.Commit()  // ✅ 成功
// 此时服务器崩溃 → 数据仍然在磁盘上
```

---

### 2. Go 中的事务使用模式

**标准模式**（推荐）：

```go
func BatchOperation(db *sql.DB, ids []int) error {
    // 1. 开启事务
    tx, err := db.Begin()
    if err != nil {
        return fmt.Errorf("failed to begin transaction: %w", err)
    }

    // 2. 确保回滚（如果出错）
    defer func() {
        if err != nil {
            tx.Rollback()
        }
    }()

    // 3. 执行操作（每步检查错误）
    for _, id := range ids {
        _, err = tx.Exec("DELETE FROM todos WHERE id = ?", id)
        if err != nil {
            return fmt.Errorf("failed to delete id %d: %w", id, err)
        }
    }

    // 4. 提交事务
    if err = tx.Commit(); err != nil {
        return fmt.Errorf("failed to commit transaction: %w", err)
    }

    return nil
}
```

**关键点**：
- `defer tx.Rollback()` 确保出错时自动回滚
- 每个 `tx.Exec` 都检查错误
- `tx.Commit()` 的返回值也要检查

---

### 3. 批量操作的错误处理策略

**策略 A：全有或全无（All-or-Nothing）**

```go
// 一个失败 → 全部回滚
for _, id := range ids {
    _, err = tx.Exec("DELETE FROM todos WHERE id = ?", id)
    if err != nil {
        return err  // 触发 defer 回滚
    }
}
```

**优点**：简单、数据一致性强
**缺点**：1 个坏 ID 导致 99 个好 ID 也无法处理

---

**策略 B：部分成功（Best-Effort）**

```go
// 记录失败的 ID，继续处理其他
var failures []BatchError
for _, id := range ids {
    _, err = tx.Exec("DELETE FROM todos WHERE id = ?", id)
    if err != nil {
        failures = append(failures, BatchError{ID: id, Error: err.Error()})
    }
}

if len(failures) > 0 {
    // 提交成功的，返回失败列表
    tx.Commit()
    return &PartialError{Failures: failures}
}
```

**优点**：容错性好，用户体验友好
**缺点**：复杂度更高，需要额外的错误结构

---

**本项目推荐**：策略 B（部分成功）

**原因**：
- 用户选择了 20 个 ID，其中 1 个已被其他人删除
- 策略 A 会导致全部失败（用户困惑："为什么一个都没删掉？"）
- 策略 B 会删除 19 个，告诉用户"1 个失败了"（用户可以接受）

---

### 4. SQLite 的事务锁机制

**SQLite 的锁级别**（从低到高）：

1. **UNLOCKED** - 无锁
2. **SHARED** - 共享锁（多个读取者）
3. **RESERVED** - 预留锁（准备写入）
4. **PENDING** - 待定锁（等待其他读取者结束）
5. **EXCLUSIVE** - 排他锁（执行写入）

**事务锁的演进**：

```go
tx.Begin()          // UNLOCKED → RESERVED（预留）
tx.Exec("SELECT")   // RESERVED → SHARED（读取）
tx.Exec("UPDATE")   // SHARED → EXCLUSIVE（写入，阻塞其他所有操作）
tx.Commit()         // EXCLUSIVE → UNLOCKED（释放锁）
```

**批量操作的锁影响**：

```go
// 批量删除 100 个待办
tx.Begin()  // 获取 RESERVED 锁
for i := 1; i <= 100; i++ {
    tx.Exec("DELETE FROM todos WHERE id = ?", i)  // 获取 EXCLUSIVE 锁
}
// 在这段时间内，其他连接：
// - 无法读取（SHARED 锁被阻塞）
// - 无法写入（EXCLUSIVE 锁被阻塞）
tx.Commit()  // 释放锁
```

**性能考虑**：
- SQLite 是文件锁，粒度较粗（不像 PostgreSQL 有行级锁）
- 批量操作时间越长，阻塞其他请求的时间越长
- **推荐**：批量大小限制在 100 以内（处理时间 < 100ms）

---

## 💻 完整代码示例

### 文件 1: `database/db.go` - 新增批量操作函数

```go
package database

import (
	"fmt"
	"time"
)

// BatchError 批量操作中的单个错误
type BatchError struct {
	ID    int    `json:"id"`
	Error string `json:"error"`
}

// BatchResult 批量操作结果
type BatchResult struct {
	SuccessCount int          `json:"success_count"`
	FailedCount  int          `json:"failed_count"`
	Errors       []BatchError `json:"errors,omitempty"`
}

// BatchCompleteTodos 批量完成待办事项
func (db *DB) BatchCompleteTodos(ids []int) (*BatchResult, error) {
	if len(ids) == 0 {
		return &BatchResult{}, nil
	}

	// 限制批量大小
	if len(ids) > 100 {
		return nil, fmt.Errorf("批量操作最多支持 100 个 ID，当前: %d", len(ids))
	}

	tx, err := db.conn.Begin()
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	result := &BatchResult{
		Errors: make([]BatchError, 0),
	}

	for _, id := range ids {
		// 在 Go 层生成时间戳（统一使用 UTC）
		now := time.Now().UTC()

		res, execErr := tx.Exec(`
			UPDATE todos
			SET status = 'completed',
			    completed_at = ?,
			    updated_at = ?
			WHERE id = ? AND status = 'pending'
		`, now, now, id)

		if execErr != nil {
			result.FailedCount++
			result.Errors = append(result.Errors, BatchError{
				ID:    id,
				Error: execErr.Error(),
			})
			continue
		}

		// 检查是否真的更新了（可能 ID 不存在或已经 completed）
		rowsAffected, err := res.RowsAffected()
		if err != nil {
			result.FailedCount++
			result.Errors = append(result.Errors, BatchError{
				ID:    id,
				Error: fmt.Sprintf("获取受影响行数失败: %v", err),
			})
			continue
		}
		if rowsAffected == 0 {
			result.FailedCount++
			result.Errors = append(result.Errors, BatchError{
				ID:    id,
				Error: "待办事项不存在或已完成",
			})
		} else {
			result.SuccessCount++
		}
	}

	// 提交事务（即使有部分失败，成功的也要提交）
	if err = tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return result, nil
}

// BatchDeleteTodos 批量删除待办事项
func (db *DB) BatchDeleteTodos(ids []int) (*BatchResult, error) {
	if len(ids) == 0 {
		return &BatchResult{}, nil
	}

	// 限制批量大小
	if len(ids) > 100 {
		return nil, fmt.Errorf("批量操作最多支持 100 个 ID，当前: %d", len(ids))
	}

	tx, err := db.conn.Begin()
	if err != nil {
		return nil, fmt.Errorf("failed to begin transaction: %w", err)
	}

	defer func() {
		if err != nil {
			tx.Rollback()
		}
	}()

	result := &BatchResult{
		Errors: make([]BatchError, 0),
	}

	for _, id := range ids {
		res, execErr := tx.Exec(`DELETE FROM todos WHERE id = ?`, id)

		if execErr != nil {
			result.FailedCount++
			result.Errors = append(result.Errors, BatchError{
				ID:    id,
				Error: execErr.Error(),
			})
			continue
		}

		// 检查是否真的删除了
		rowsAffected, err := res.RowsAffected()
		if err != nil {
			result.FailedCount++
			result.Errors = append(result.Errors, BatchError{
				ID:    id,
				Error: fmt.Sprintf("获取受影响行数失败: %v", err),
			})
			continue
		}
		if rowsAffected == 0 {
			result.FailedCount++
			result.Errors = append(result.Errors, BatchError{
				ID:    id,
				Error: "待办事项不存在",
			})
		} else {
			result.SuccessCount++
		}
	}

	// 提交事务
	if err = tx.Commit(); err != nil {
		return nil, fmt.Errorf("failed to commit transaction: %w", err)
	}

	return result, nil
}
```

---

### 关键点解析

**1. 批量大小限制**（第 30-32 行，第 99-101 行）
```go
if len(ids) > 100 {
    return nil, fmt.Errorf("批量操作最多支持 100 个 ID，当前: %d", len(ids))
}
```
- 防止恶意请求（传入 10000 个 ID）
- 控制事务锁定时间（< 100ms）
- 提高用户体验（前端可以提示"请分批选择"）

**2. 空列表处理**（第 27-29 行，第 96-98 行）
```go
if len(ids) == 0 {
    return &BatchResult{}, nil
}
```
- 避免空事务
- 返回成功结果（SuccessCount=0, FailedCount=0）

**3. 部分失败策略**（第 51-71 行）
```go
for _, id := range ids {
    res, execErr := tx.Exec(...)
    if execErr != nil {
        result.FailedCount++
        result.Errors = append(result.Errors, BatchError{...})
        continue  // 继续处理下一个
    }

    rowsAffected, _ := res.RowsAffected()
    if rowsAffected == 0 {
        result.FailedCount++
        result.Errors = append(result.Errors, ...)
    } else {
        result.SuccessCount++
    }
}
```
- 使用 `continue` 跳过失败的 ID
- 记录每个失败的原因
- 检查 `RowsAffected`（区分"执行失败"和"ID 不存在"）

**4. 事务提交**（第 75-78 行）
```go
// 提交事务（即使有部分失败，成功的也要提交）
if err = tx.Commit(); err != nil {
    return nil, fmt.Errorf("failed to commit transaction: %w", err)
}
```
- 即使有失败，成功的也要提交
- 如果 `Commit` 失败（磁盘满等），返回错误

**5. 批量完成的特殊逻辑**（第 284-293 行）
```go
// 在 Go 层生成时间戳（统一使用 UTC）
now := time.Now().UTC()

UPDATE todos
SET status = 'completed',
    completed_at = ?,  // 使用 Go 生成的时间戳
    updated_at = ?
WHERE id = ? AND status = 'pending'
```
- 在 Go 层生成时间戳而不是使用 SQL 函数
- 统一使用 `time.Now().UTC()` 保证时区一致性
- `WHERE status = 'pending'` 避免重复完成
- 与项目中其他时间字段的处理方式保持一致

---

### 文件 2: `handler/handler.go` - 新增批量操作 handlers

```go
package handler

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
)

// BatchCompleteRequest 批量完成请求
type BatchCompleteRequest struct {
	IDs []int `json:"ids"`
}

// BatchDeleteRequest 批量删除请求
type BatchDeleteRequest struct {
	IDs []int `json:"ids"`
}

// BatchCompleteTodos 批量完成待办事项
func (h *Handler) BatchCompleteTodos(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()

	var req BatchCompleteRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.sendError(w, http.StatusBadRequest, "INVALID_JSON", fmt.Sprintf("JSON 解析失败: %v", err))
		return
	}

	// 验证请求
	if len(req.IDs) == 0 {
		h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", "IDs 不能为空")
		return
	}

	// 批量大小限制
	if len(req.IDs) > 100 {
		h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", fmt.Sprintf("批量操作最多支持 100 个 ID，当前: %d", len(req.IDs)))
		return
	}

	// 执行批量操作
	result, err := h.db.BatchCompleteTodos(req.IDs)
	if err != nil {
		log.Printf("Failed to batch complete todos: %v", err)
		h.sendError(w, http.StatusInternalServerError, "BATCH_OPERATION_ERROR", err.Error())
		return
	}

	response := Response{
		Success: true,
		Data:    result,
		Message: "批量完成操作完成",
	}
	h.sendJSON(w, http.StatusOK, response)
}

// BatchDeleteTodos 批量删除待办事项
func (h *Handler) BatchDeleteTodos(w http.ResponseWriter, r *http.Request) {
	defer r.Body.Close()

	var req BatchDeleteRequest
	if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
		h.sendError(w, http.StatusBadRequest, "INVALID_JSON", fmt.Sprintf("JSON 解析失败: %v", err))
		return
	}

	// 验证请求
	if len(req.IDs) == 0 {
		h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", "IDs 不能为空")
		return
	}

	// 批量大小限制
	if len(req.IDs) > 100 {
		h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", fmt.Sprintf("批量操作最多支持 100 个 ID，当前: %d", len(req.IDs)))
		return
	}

	// 执行批量操作
	result, err := h.db.BatchDeleteTodos(req.IDs)
	if err != nil {
		log.Printf("Failed to batch delete todos: %v", err)
		h.sendError(w, http.StatusInternalServerError, "BATCH_OPERATION_ERROR", err.Error())
		return
	}

	response := Response{
		Success: true,
		Data:    result,
		Message: "批量删除操作完成",
	}
	h.sendJSON(w, http.StatusOK, response)
}
```

---

### 文件 3: `api/routes.go` - 注册批量操作路由

```go
func SetupRoutes(h *handler.Handler) *http.ServeMux {
	mux := http.NewServeMux()

	withMiddlewares := func(f http.HandlerFunc) http.HandlerFunc {
		return chain(f, corsMiddleware, recoverMiddleware)
	}

	optionsHandler := func(w http.ResponseWriter, r *http.Request) {
		w.WriteHeader(http.StatusOK)
	}

	registerTodoRoutes := func(base string) {
		mux.HandleFunc("GET "+base, withMiddlewares(h.ListTodos))
		mux.HandleFunc("POST "+base, withMiddlewares(h.CreateTodo))
		mux.HandleFunc("OPTIONS "+base, withMiddlewares(optionsHandler))

		// 批量操作端点（必须在 {id} 之前注册）
		mux.HandleFunc("POST "+base+"/batch/complete", withMiddlewares(h.BatchCompleteTodos))
		mux.HandleFunc("POST "+base+"/batch/delete", withMiddlewares(h.BatchDeleteTodos))
		mux.HandleFunc("OPTIONS "+base+"/batch/complete", withMiddlewares(optionsHandler))
		mux.HandleFunc("OPTIONS "+base+"/batch/delete", withMiddlewares(optionsHandler))

		mux.HandleFunc("PUT "+base+"/{id}", withMiddlewares(h.UpdateTodo))
		mux.HandleFunc("DELETE "+base+"/{id}", withMiddlewares(h.DeleteTodo))
		mux.HandleFunc("OPTIONS "+base+"/{id}", withMiddlewares(optionsHandler))
	}

	// Versioned routes with legacy aliases for backward compatibility
	registerTodoRoutes("/api/v1/todos")
	registerTodoRoutes("/api/todos")

	mux.HandleFunc("/health", h.HealthCheck)

	return mux
}
```

**路由注册顺序（最佳实践）**：
- 推荐将 `POST /api/v1/todos/batch/complete` 注册在 `PUT /api/v1/todos/{id}` 之前
- Go 1.22+ 会自动选择更具体的模式（`/batch/complete` 比 `/{id}` 更具体）
- 但为了代码可读性，建议按"从具体到通用"的顺序注册

---

## ⚠️ 潜在陷阱和最佳实践

### 1. **事务中的查询性能陷阱**

**问题代码**：
```go
// ❌ 每次循环都查询一次数据库
for _, id := range ids {
    var todo model.Todo
    tx.QueryRow("SELECT * FROM todos WHERE id = ?", id).Scan(&todo)
    if todo.Status == "pending" {
        tx.Exec("UPDATE todos SET status = 'completed' WHERE id = ?", id)
    }
}
```

**问题**：
- 100 个 ID = 100 次 SELECT + 100 次 UPDATE = 200 次数据库操作
- 事务锁定时间过长

**正确代码**：
```go
// ✅ 使用 WHERE 条件过滤，减少查询
for _, id := range ids {
    tx.Exec("UPDATE todos SET status = 'completed' WHERE id = ? AND status = 'pending'", id)
}
```

---

### 2. **RowsAffected 的重要性**

**场景**：用户选择了 ID [1, 2, 3] 进行批量删除，但 ID=2 不存在

**不检查 RowsAffected**：
```go
// ❌ 无法区分"删除成功"和"ID 不存在"
for _, id := range ids {
    tx.Exec("DELETE FROM todos WHERE id = ?", id)
    result.SuccessCount++  // 错误！ID=2 不存在，但仍然计数为成功
}
// 返回：SuccessCount=3, FailedCount=0（用户以为全部删除了）
```

**检查 RowsAffected**：
```go
// ✅ 正确区分
for _, id := range ids {
    res, _ := tx.Exec("DELETE FROM todos WHERE id = ?", id)
    if res.RowsAffected() == 0 {
        result.FailedCount++
        result.Errors = append(result.Errors, BatchError{ID: id, Error: "不存在"})
    } else {
        result.SuccessCount++
    }
}
// 返回：SuccessCount=2, FailedCount=1, Errors=[{ID:2, Error:"不存在"}]
```

---

### 3. **事务回滚的陷阱**

**问题场景**：
```go
tx.Begin()
for _, id := range ids {
    _, err := tx.Exec("DELETE FROM todos WHERE id = ?", id)
    if err != nil {
        tx.Rollback()  // ❌ 立即回滚，后面的代码还会继续执行！
        return err
    }
}
tx.Commit()  // ⚠️ 如果前面 Rollback 了，这里会出错
```

**问题**：
- `Rollback()` 后，`tx` 已失效
- 后续的 `Commit()` 会返回 `sql.ErrTxDone` 错误

**正确代码**：
```go
defer func() {
    if err != nil {
        tx.Rollback()  // ✅ 在 defer 中回滚
    }
}()

for _, id := range ids {
    _, err = tx.Exec("DELETE FROM todos WHERE id = ?", id)
    if err != nil {
        return err  // 触发 defer 回滚
    }
}

if err = tx.Commit(); err != nil {
    return err
}
```

---

### 4. **SQL 注入的风险**

**问题代码**：
```go
// ❌ 拼接 SQL，存在注入风险
query := fmt.Sprintf("DELETE FROM todos WHERE id IN (%s)", strings.Join(ids, ","))
tx.Exec(query)
```

**风险**：
- 如果 `ids` 是从用户输入解析的字符串（而不是 `int`），可能包含恶意代码
- 示例：`ids = ["1", "2; DROP TABLE todos;"]`

**正确代码**：
```go
// ✅ 使用参数化查询（每个 ID 单独绑定）
for _, id := range ids {
    tx.Exec("DELETE FROM todos WHERE id = ?", id)
}

// 或者使用 IN 子句（构造占位符）
placeholders := make([]string, len(ids))
args := make([]interface{}, len(ids))
for i, id := range ids {
    placeholders[i] = "?"
    args[i] = id
}
query := fmt.Sprintf("DELETE FROM todos WHERE id IN (%s)", strings.Join(placeholders, ","))
tx.Exec(query, args...)
```

---

### 5. **并发删除的竞态条件**

**场景**：
- 用户 A 批量删除 [1, 2, 3]
- 用户 B 同时批量删除 [2, 3, 4]

**SQLite 的行为**：
- SQLite 使用文件锁，事务串行执行
- 先提交的事务成功，后提交的事务：
  - ID=2,3 已被删除 → `RowsAffected=0` → 标记为失败

**结果**：
- 用户 A：SuccessCount=3
- 用户 B：SuccessCount=1（ID=4），FailedCount=2（ID=2,3 不存在）

**这是预期行为**（部分失败策略的好处）！

---

## 🛠️ 实现步骤建议

### 渐进式实现（分 4 步）

**第 1 步**：实现简单的批量删除（全有或全无）

```go
func (db *DB) BatchDeleteTodos(ids []int) error {
    if len(ids) == 0 {
        return nil
    }

    tx, err := db.conn.Begin()
    if err != nil {
        return err
    }
    defer func() {
        if err != nil {
            tx.Rollback()
        }
    }()

    for _, id := range ids {
        _, err = tx.Exec("DELETE FROM todos WHERE id = ?", id)
        if err != nil {
            return err  // 任何失败都回滚
        }
    }

    if err = tx.Commit(); err != nil {
        return err
    }

    return nil
}
```

**测试**：
```bash
curl -X POST http://localhost:7789/api/v1/todos/batch/delete \
  -H "Content-Type: application/json" \
  -d '{"ids": [1, 2, 3]}'
```

---

**第 2 步**：添加 `BatchResult` 结构和部分失败支持

```go
type BatchResult struct {
    SuccessCount int
    FailedCount  int
    Errors       []BatchError
}

func (db *DB) BatchDeleteTodos(ids []int) (*BatchResult, error) {
    // ... 初始化 ...

    result := &BatchResult{Errors: make([]BatchError, 0)}

    for _, id := range ids {
        res, execErr := tx.Exec("DELETE FROM todos WHERE id = ?", id)
        if execErr != nil {
            result.FailedCount++
            result.Errors = append(result.Errors, BatchError{ID: id, Error: execErr.Error()})
            continue
        }

        if res.RowsAffected() == 0 {
            result.FailedCount++
            result.Errors = append(result.Errors, BatchError{ID: id, Error: "不存在"})
        } else {
            result.SuccessCount++
        }
    }

    tx.Commit()
    return result, nil
}
```

**测试**：
```bash
# 删除存在的和不存在的 ID
curl -X POST http://localhost:7789/api/v1/todos/batch/delete \
  -H "Content-Type: application/json" \
  -d '{"ids": [1, 999, 2]}'

# 预期返回
{
  "success": true,
  "data": {
    "success_count": 2,
    "failed_count": 1,
    "errors": [{"id": 999, "error": "不存在"}]
  }
}
```

---

**第 3 步**：实现批量完成（复用逻辑）

```go
func (db *DB) BatchCompleteTodos(ids []int) (*BatchResult, error) {
    // ... 与 BatchDeleteTodos 类似 ...

    for _, id := range ids {
        res, execErr := tx.Exec(`
            UPDATE todos
            SET status = 'completed', completed_at = datetime('now'), updated_at = datetime('now')
            WHERE id = ? AND status = 'pending'
        `, id)

        // ... 处理结果 ...
    }

    tx.Commit()
    return result, nil
}
```

---

**第 4 步**：添加批量大小限制和验证

```go
func (db *DB) BatchDeleteTodos(ids []int) (*BatchResult, error) {
    if len(ids) == 0 {
        return &BatchResult{}, nil
    }

    if len(ids) > 100 {
        return nil, fmt.Errorf("批量操作最多支持 100 个 ID，当前: %d", len(ids))
    }

    // ... 其余逻辑 ...
}
```

**测试**：
```bash
# 测试超过限制
curl -X POST http://localhost:7789/api/v1/todos/batch/delete \
  -H "Content-Type: application/json" \
  -d '{"ids": [1,2,3,...,101]}'  # 101 个 ID

# 预期返回 400 错误
{
  "success": false,
  "error": {
    "code": "BATCH_OPERATION_ERROR",
    "message": "批量操作最多支持 100 个 ID，当前: 101"
  }
}
```

---

## ✅ 验证清单

实现完成后，请检查：

**功能正确性**：
- [ ] 批量删除成功（所有 ID 都存在）
- [ ] 批量完成成功（所有 ID 都是 pending 状态）
- [ ] 部分失败处理（返回正确的 SuccessCount 和 FailedCount）
- [ ] 空列表处理（返回成功，计数为 0）
- [ ] ID 不存在的情况（记录到 Errors）
- [ ] 已完成的待办无法再次完成（记录到 Errors）

**事务性**：
- [ ] Commit 失败时正确返回错误
- [ ] 事务中任何失败都记录（不会静默丢失）
- [ ] defer Rollback 正确处理错误情况

**安全性**：
- [ ] 批量大小限制（最多 100 个）
- [ ] 使用参数化查询（无 SQL 注入风险）
- [ ] IDs 为空时返回 400 错误

**API 设计**：
- [ ] 路由注册顺序正确（/batch/* 在 /{id} 之前）
- [ ] 同时支持 `/api/v1/todos/batch/*` 和 `/api/todos/batch/*`
- [ ] 响应格式符合项目规范

**代码质量**：
- [ ] 错误处理完善
- [ ] 有清晰的注释
- [ ] 代码格式符合 gofmt

---

## 🧪 测试示例

### 完整测试脚本

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1/todos"

echo "=== 准备测试数据 ==="
# 创建 10 个待办事项
for i in {1..10}; do
  curl -s -X POST "$BASE_URL" \
    -H "Content-Type: application/json" \
    -d "{\"title\": \"测试任务 $i\", \"description\": \"描述 $i\"}" > /dev/null
  echo "创建任务 $i"
done

echo -e "\n=== 测试 1: 批量完成（全部成功）==="
curl -s -X POST "$BASE_URL/batch/complete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [1, 2, 3]}' | jq

echo -e "\n=== 测试 2: 批量完成（部分失败 - 已完成的）==="
curl -s -X POST "$BASE_URL/batch/complete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [1, 4, 5]}' | jq
# 预期：ID=1 已完成，失败；ID=4,5 成功

echo -e "\n=== 测试 3: 批量完成（部分失败 - ID 不存在）==="
curl -s -X POST "$BASE_URL/batch/complete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [6, 999, 7]}' | jq
# 预期：ID=999 不存在，失败；ID=6,7 成功

echo -e "\n=== 测试 4: 批量删除（全部成功）==="
curl -s -X POST "$BASE_URL/batch/delete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [8, 9, 10]}' | jq

echo -e "\n=== 测试 5: 批量删除（部分失败 - ID 不存在）==="
curl -s -X POST "$BASE_URL/batch/delete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [8, 9, 10]}' | jq
# 预期：全部失败（已被删除）

echo -e "\n=== 测试 6: 空 IDs 列表 ==="
curl -s -X POST "$BASE_URL/batch/delete" \
  -H "Content-Type: application/json" \
  -d '{"ids": []}' | jq
# 预期：400 错误

echo -e "\n=== 测试 7: 超过限制（101 个 ID）==="
IDS=$(seq -s ',' 1 101)
curl -s -X POST "$BASE_URL/batch/delete" \
  -H "Content-Type: application/json" \
  -d "{\"ids\": [$IDS]}" | jq
# 预期：400 错误

echo -e "\n=== 测试 8: 向后兼容（/api/todos/batch/*）==="
curl -s -X POST "http://localhost:7789/api/todos/batch/complete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [4, 5]}' | jq

echo -e "\n=== 清理 ==="
# 删除所有测试数据（手动或通过 API）
```

保存为 `scripts/test-batch.sh`，然后执行：
```bash
chmod +x scripts/test-batch.sh
./scripts/test-batch.sh
```

---

## 📖 扩展阅读

### Go 数据库事务
- [`database/sql` Transactions](https://go.dev/doc/database/execute-transactions)
- [Handling Errors in Transactions](https://go.dev/doc/database/querying#handling-errors)

### SQLite 事务机制
- [Transaction](https://www.sqlite.org/lang_transaction.html)
- [Locking And Concurrency](https://www.sqlite.org/lockingv3.html)

### 批量操作最佳实践
- [Batch Processing Patterns](https://martinfowler.com/articles/patterns-of-distributed-systems/batch-processing.html)
- [Database Batch Operations](https://en.wikipedia.org/wiki/Batch_processing)

---

## 🚀 开始实现吧！

现在请你按照以上步骤：

1. **修改 `database/db.go`**：
   - 添加 `BatchError` 和 `BatchResult` 结构体
   - 实现 `BatchCompleteTodos()` 函数
   - 实现 `BatchDeleteTodos()` 函数

2. **修改 `handler/handler.go`**：
   - 添加 `BatchCompleteRequest` 和 `BatchDeleteRequest` 结构体
   - 实现 `BatchCompleteTodos` handler
   - 实现 `BatchDeleteTodos` handler

3. **修改 `api/routes.go`**：
   - 注册 `POST /api/v1/todos/batch/complete` 路由
   - 注册 `POST /api/v1/todos/batch/delete` 路由
   - 注意路由顺序（在 `/{id}` 之前）

4. **测试**：
   - 使用上面的测试脚本验证功能
   - 确保部分失败、空列表、超限等边界情况都正确处理

**记住**：
- 事务中每步都要检查错误
- 使用 `RowsAffected()` 区分"执行失败"和"ID 不存在"
- 批量大小限制（最多 100 个）
- 部分失败策略（记录错误，提交成功的）

遇到问题随时问我！💪

---

## 💡 常见问题 FAQ

### Q1: 为什么不用 IN 子句？

**问题**：`DELETE FROM todos WHERE id IN (1,2,3)` 不是更快吗？

**答**：
- **性能**：IN 子句确实更快（1 次 SQL vs 3 次）
- **错误处理**：无法区分哪个 ID 失败了
  ```sql
  DELETE FROM todos WHERE id IN (1, 999, 2)
  -- RowsAffected = 2，但无法知道是哪两个成功了
  ```
- **本项目**：循环逐个处理，便于记录每个 ID 的结果

**如果追求性能**：
```go
// 先用 IN 子句删除
res := tx.Exec("DELETE FROM todos WHERE id IN (?, ?, ?)", ids...)
// 再逐个查询哪些还存在（失败的）
for _, id := range ids {
    var exists int
    tx.QueryRow("SELECT 1 FROM todos WHERE id = ?", id).Scan(&exists)
    if exists == 1 {
        result.Errors = append(...)
    }
}
```

### Q2: 批量操作会锁表多久？

**答**：
- SQLite 使用文件锁，事务期间整个数据库被锁定
- 100 个删除操作约 50-100ms
- 其他请求会被阻塞（等待锁释放）
- **缓解**：批量大小限制在 100 以内

### Q3: 如果批量 1000 个怎么办？

**答**：
- 前端分批发送（每批 100 个）
- 或者后端支持"分页批量"：
  ```go
  for i := 0; i < len(ids); i += 100 {
      batch := ids[i:min(i+100, len(ids))]
      result := BatchDelete(batch)
      // 合并结果
  }
  ```

### Q4: 批量完成后，前端如何刷新列表？

**答**：
```javascript
const result = await batchComplete([1, 2, 3]);
if (result.failed_count > 0) {
    alert(`${result.failed_count} 个任务操作失败`);
}
// 重新加载列表
fetchTodos();
```

### Q5: 能否支持批量更新（修改标题、截止日期等）？

**答**：
- 可以，但 API 设计会更复杂：
  ```json
  {
    "updates": [
      {"id": 1, "title": "新标题"},
      {"id": 2, "due_date": "2024-12-31"}
    ]
  }
  ```
- 每个 ID 的更新字段可能不同
- 建议：先实现简单的批量完成/删除，再考虑扩展

---

**现在，开始实现批量操作吧！记住：事务、错误处理、批量限制。** 🚀
