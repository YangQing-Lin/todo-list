# æ•™å­¦ Part 9: è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶

> **ğŸ“Œ å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / ç”Ÿäº§çº§å¯è§‚æµ‹æ€§
> **å‰ç½®è¦æ±‚**: å·²å®Œæˆæ•™å­¦-5/6/7/8ï¼ˆäº‹åŠ¡ã€Contextã€æ‰¹é‡æ“ä½œã€å¯¼å…¥å¯¼å‡ºã€è½¯åˆ é™¤ï¼‰
> **å­¦ä¹ ç›®æ ‡**: æŒæ¡ `log/slog` ç»“æ„åŒ–æ—¥å¿—ã€å®ç°è¯·æ±‚è¿½è¸ªã€ç†è§£ä¸­é—´ä»¶é«˜çº§æŠ€å·§
> **æ—¶é—´æŠ•å…¥**: 2-3 å°æ—¶(ç†è§£åŸç† + å®ç° + æµ‹è¯•)

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®é—®é¢˜**:
- ç”¨æˆ·æŠ¥å‘Š API æ…¢ â†’ å“ªä¸ªæ¥å£æ…¢ï¼Ÿæ…¢äº†å¤šä¹…ï¼Ÿ
- æœåŠ¡å™¨è¿”å› 500 é”™è¯¯ â†’ ä»€ä¹ˆè¯·æ±‚å¯¼è‡´çš„ï¼Ÿå‚æ•°æ˜¯ä»€ä¹ˆï¼Ÿ
- éœ€è¦æ’æŸ¥é—®é¢˜ â†’ æŸä¸ªè¯·æ±‚ç»è¿‡äº†å“ªäº›å¤„ç†ï¼Ÿ

**ç”Ÿäº§ç¯å¢ƒçš„çœŸå®åœºæ™¯**:
```
ç”¨æˆ·: "æˆ‘ç‚¹äº†æäº¤æŒ‰é’®ï¼Œæ²¡ååº”"
è¿ç»´: æŸ¥çœ‹æ—¥å¿—... æ²¡æœ‰ä»»ä½•è®°å½•
å¼€å‘: "è¯·æ±‚åˆ°æœåŠ¡å™¨äº†å—ï¼Ÿ" "ä¸çŸ¥é“..."
```

**ä¸ºä»€ä¹ˆéœ€è¦è¯·æ±‚æ—¥å¿—?**
- **é—®é¢˜æ’æŸ¥**: çŸ¥é“"å‘ç”Ÿäº†ä»€ä¹ˆ"
- **æ€§èƒ½ç›‘æ§**: å‘ç°æ…¢æ¥å£
- **å®‰å…¨å®¡è®¡**: è°åœ¨ä»€ä¹ˆæ—¶å€™åšäº†ä»€ä¹ˆ
- **ä¸šåŠ¡åˆ†æ**: å“ªäº› API è¢«é¢‘ç¹è°ƒç”¨

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**: ä¸­é—´ä»¶ + ç»“æ„åŒ–æ—¥å¿—

**é”™è¯¯æ–¹æ³•**(åœ¨æ¯ä¸ª Handler é‡Œå†™æ—¥å¿—):
```go
// âŒ é‡å¤ä»£ç ï¼Œå®¹æ˜“é—æ¼
func ListTodos(w http.ResponseWriter, r *http.Request) {
    log.Printf("Request: %s %s", r.Method, r.URL.Path)
    // ... ä¸šåŠ¡é€»è¾‘
    log.Printf("Response: 200, took 50ms")
}
```

**æ­£ç¡®æ–¹æ³•**(ä¸­é—´ä»¶ç»Ÿä¸€å¤„ç†):
```go
// âœ… æ‰€æœ‰è¯·æ±‚è‡ªåŠ¨è®°å½•
func LoggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        ww := &responseWrapper{ResponseWriter: w}
        next(ww, r)
        log.Printf("%s %s %d %v", r.Method, r.URL.Path, ww.status, time.Since(start))
    }
}
```

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£é™©**:
- æ—¥å¿—å¤ªå¤š â†’ ç£ç›˜å†™æ»¡
- è®°å½•æ•æ„Ÿä¿¡æ¯ â†’ å¯†ç ã€Token æ³„éœ²
- æ—¥å¿— I/O é˜»å¡ â†’ å½±å“è¯·æ±‚å“åº”æ—¶é—´

âœ… **å®‰å…¨è®¾è®¡**:
- æ—¥å¿—åˆ†çº§(Debug/Info/Warn/Error)
- æ•æ„Ÿä¿¡æ¯è„±æ•
- å¼‚æ­¥æ—¥å¿—å†™å…¥(å¤§æµé‡åœºæ™¯)

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. Go 1.21+ çš„ log/slog åŒ…

**ä¸ºä»€ä¹ˆç”¨ slog è€Œä¸æ˜¯ log?**

| ç‰¹æ€§ | log | slog |
|------|-----|------|
| ç»“æ„åŒ–è¾“å‡º | âŒ | âœ… |
| æ—¥å¿—çº§åˆ« | âŒ | âœ… |
| JSON æ ¼å¼ | âŒ | âœ… |
| ä¸Šä¸‹æ–‡ä¼ é€’ | âŒ | âœ… |
| æ€§èƒ½ | ä¸€èˆ¬ | æ›´å¥½ |

**åŸºæœ¬ç”¨æ³•**:
```go
import "log/slog"

// æ™®é€šæ—¥å¿—
slog.Info("æœåŠ¡å™¨å¯åŠ¨", "port", 7789)

// å¸¦é”™è¯¯
slog.Error("æ•°æ®åº“è¿æ¥å¤±è´¥", "error", err)

// å¸¦å¤šä¸ªå­—æ®µ
slog.Info("è¯·æ±‚å®Œæˆ",
    "method", "GET",
    "path", "/api/todos",
    "status", 200,
    "duration_ms", 50,
)
```

**è¾“å‡ºæ ¼å¼**:
```
// é»˜è®¤æ–‡æœ¬æ ¼å¼
2024-01-15 10:30:00 INFO è¯·æ±‚å®Œæˆ method=GET path=/api/todos status=200 duration_ms=50

// JSON æ ¼å¼
{"time":"2024-01-15T10:30:00Z","level":"INFO","msg":"è¯·æ±‚å®Œæˆ","method":"GET","path":"/api/todos","status":200,"duration_ms":50}
```

---

### 2. é…ç½® slog

**è®¾ç½®å…¨å±€æ—¥å¿—å™¨**:
```go
func setupLogger() {
    // æ–¹å¼ 1: æ–‡æœ¬æ ¼å¼(å¼€å‘ç¯å¢ƒ)
    handler := slog.NewTextHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelDebug,
    })

    // æ–¹å¼ 2: JSON æ ¼å¼(ç”Ÿäº§ç¯å¢ƒ)
    handler := slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{
        Level: slog.LevelInfo,
    })

    logger := slog.New(handler)
    slog.SetDefault(logger)
}
```

**æ—¥å¿—çº§åˆ«**:
```go
slog.LevelDebug  // -4: è°ƒè¯•ä¿¡æ¯
slog.LevelInfo   // 0:  ä¸€èˆ¬ä¿¡æ¯
slog.LevelWarn   // 4:  è­¦å‘Š
slog.LevelError  // 8:  é”™è¯¯
```

---

### 3. æ•è· HTTP å“åº”çŠ¶æ€ç 

**é—®é¢˜**: `http.ResponseWriter` æ²¡æœ‰æš´éœ²çŠ¶æ€ç 

**è§£å†³**: åŒ…è£… ResponseWriter

```go
// responseWrapper åŒ…è£… ResponseWriter ä»¥æ•è·çŠ¶æ€ç 
type responseWrapper struct {
    http.ResponseWriter
    statusCode    int
    bytesWritten  int
    wroteHeader   bool
}

func newResponseWrapper(w http.ResponseWriter) *responseWrapper {
    return &responseWrapper{
        ResponseWriter: w,
        statusCode:     200, // é»˜è®¤ 200
    }
}

func (w *responseWrapper) WriteHeader(code int) {
    if !w.wroteHeader {
        w.statusCode = code
        w.wroteHeader = true
        w.ResponseWriter.WriteHeader(code)
    }
}

func (w *responseWrapper) Write(b []byte) (int, error) {
    if !w.wroteHeader {
        w.WriteHeader(200)
    }
    n, err := w.ResponseWriter.Write(b)
    w.bytesWritten += n
    return n, err
}
```

---

### 4. è¯·æ±‚ ID ç”Ÿæˆ

**ä¸ºä»€ä¹ˆéœ€è¦è¯·æ±‚ ID?**
- å…³è”åŒä¸€è¯·æ±‚çš„å¤šæ¡æ—¥å¿—
- åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­è¿½è¸ªè¯·æ±‚é“¾è·¯
- æ–¹ä¾¿ç”¨æˆ·åé¦ˆé—®é¢˜æ—¶å®šä½

**ç”Ÿæˆæ–¹å¼**:
```go
import (
    "crypto/rand"
    "encoding/hex"
)

// generateRequestID ç”Ÿæˆè¯·æ±‚ ID
func generateRequestID() string {
    b := make([]byte, 8)  // 16 å­—ç¬¦çš„åå…­è¿›åˆ¶å­—ç¬¦ä¸²
    rand.Read(b)
    return hex.EncodeToString(b)
}

// æˆ–è€…ä½¿ç”¨æ—¶é—´æˆ³ + éšæœºæ•°
func generateRequestID() string {
    return fmt.Sprintf("%d-%d", time.Now().UnixNano(), rand.Int31())
}
```

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: åˆ›å»ºæ—¥å¿—ä¸­é—´ä»¶æ–‡ä»¶

> **æ³¨æ„**ï¼šæœ¬é¡¹ç›®å·²æœ‰ `api/routes.go` æ–‡ä»¶åŒ…å«ä¸­é—´ä»¶ã€‚
> å¯ä»¥é€‰æ‹©åœ¨ç°æœ‰æ–‡ä»¶ä¸­æ·»åŠ ï¼Œæˆ–åˆ›å»ºç‹¬ç«‹çš„ `api/middleware.go` æ–‡ä»¶ã€‚
> ä»¥ä¸‹ç¤ºä¾‹å‡è®¾åˆ›å»ºç‹¬ç«‹æ–‡ä»¶ï¼Œä¸é¡¹ç›®ç»“æ„ä¿æŒæ¸…æ™°ã€‚

åˆ›å»º `api/middleware.go`:

```go
package api

import (
    "crypto/rand"
    "encoding/hex"
    "log/slog"
    "net/http"
    "strings"
    "time"
)

// responseWrapper åŒ…è£… ResponseWriter ä»¥æ•è·å“åº”ä¿¡æ¯
type responseWrapper struct {
    http.ResponseWriter
    statusCode   int
    bytesWritten int
    wroteHeader  bool
}

func newResponseWrapper(w http.ResponseWriter) *responseWrapper {
    return &responseWrapper{
        ResponseWriter: w,
        statusCode:     200,
    }
}

func (w *responseWrapper) WriteHeader(code int) {
    if !w.wroteHeader {
        w.statusCode = code
        w.wroteHeader = true
        w.ResponseWriter.WriteHeader(code)
    }
}

func (w *responseWrapper) Write(b []byte) (int, error) {
    if !w.wroteHeader {
        w.WriteHeader(200)
    }
    n, err := w.ResponseWriter.Write(b)
    w.bytesWritten += n
    return n, err
}

// generateRequestID ç”Ÿæˆå”¯ä¸€è¯·æ±‚ ID
func generateRequestID() string {
    b := make([]byte, 8)
    rand.Read(b)
    return hex.EncodeToString(b)
}

// getClientIP è·å–å®¢æˆ·ç«¯çœŸå® IP
func getClientIP(r *http.Request) string {
    // æ£€æŸ¥å¸¸è§çš„ä»£ç†å¤´
    if xff := r.Header.Get("X-Forwarded-For"); xff != "" {
        // X-Forwarded-For å¯èƒ½åŒ…å«å¤šä¸ª IPï¼Œå–ç¬¬ä¸€ä¸ª
        if idx := strings.Index(xff, ","); idx != -1 {
            return strings.TrimSpace(xff[:idx])
        }
        return strings.TrimSpace(xff)
    }

    if xri := r.Header.Get("X-Real-IP"); xri != "" {
        return xri
    }

    // å»æ‰ç«¯å£å·
    ip := r.RemoteAddr
    if idx := strings.LastIndex(ip, ":"); idx != -1 {
        ip = ip[:idx]
    }
    return ip
}

// LoggingMiddleware è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶
func LoggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        start := time.Now()
        requestID := generateRequestID()

        // åŒ…è£… ResponseWriter
        ww := newResponseWrapper(w)

        // å°†è¯·æ±‚ ID æ·»åŠ åˆ°å“åº”å¤´(æ–¹ä¾¿å®¢æˆ·ç«¯è¿½è¸ª)
        ww.Header().Set("X-Request-ID", requestID)

        // è®°å½•è¯·æ±‚å¼€å§‹(Debug çº§åˆ«)
        slog.Debug("è¯·æ±‚å¼€å§‹",
            "request_id", requestID,
            "method", r.Method,
            "path", r.URL.Path,
            "query", r.URL.RawQuery,
            "client_ip", getClientIP(r),
            "user_agent", r.UserAgent(),
        )

        // æ‰§è¡Œä¸‹ä¸€ä¸ªå¤„ç†å™¨
        next(ww, r)

        // è®¡ç®—è€—æ—¶
        duration := time.Since(start)

        // æ ¹æ®çŠ¶æ€ç é€‰æ‹©æ—¥å¿—çº§åˆ«
        logLevel := slog.LevelInfo
        if ww.statusCode >= 500 {
            logLevel = slog.LevelError
        } else if ww.statusCode >= 400 {
            logLevel = slog.LevelWarn
        }

        // è®°å½•è¯·æ±‚å®Œæˆ
        slog.Log(r.Context(), logLevel, "è¯·æ±‚å®Œæˆ",
            "request_id", requestID,
            "method", r.Method,
            "path", r.URL.Path,
            "status", ww.statusCode,
            "bytes", ww.bytesWritten,
            "duration_ms", duration.Milliseconds(),
            "client_ip", getClientIP(r),
        )
    }
}

// RecoverMiddleware panic æ¢å¤ä¸­é—´ä»¶(å¸¦æ—¥å¿—)
func RecoverMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                slog.Error("Panic recovered",
                    "error", err,
                    "method", r.Method,
                    "path", r.URL.Path,
                )
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        next(w, r)
    }
}

// CORSMiddleware CORS ä¸­é—´ä»¶
func CORSMiddleware(next http.HandlerFunc) http.HandlerFunc {
    return func(w http.ResponseWriter, r *http.Request) {
        w.Header().Set("Access-Control-Allow-Origin", "*")
        w.Header().Set("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS")
        w.Header().Set("Access-Control-Allow-Headers", "Content-Type, Authorization, X-Request-ID")

        if r.Method == http.MethodOptions {
            w.WriteHeader(http.StatusOK)
            return
        }

        next(w, r)
    }
}
```

---

### æ­¥éª¤ 2: é…ç½®æ—¥å¿—å™¨

åœ¨ `cmd/server/main.go` ä¸­æ·»åŠ :

```go
package main

import (
    "log/slog"
    "os"
    // ... å…¶ä»– import
)

func setupLogger() {
    // ä»ç¯å¢ƒå˜é‡è¯»å–æ—¥å¿—çº§åˆ«
    levelStr := os.Getenv("LOG_LEVEL")
    level := slog.LevelInfo

    switch levelStr {
    case "debug":
        level = slog.LevelDebug
    case "warn":
        level = slog.LevelWarn
    case "error":
        level = slog.LevelError
    }

    // ä»ç¯å¢ƒå˜é‡è¯»å–æ—¥å¿—æ ¼å¼
    format := os.Getenv("LOG_FORMAT")

    var handler slog.Handler
    opts := &slog.HandlerOptions{
        Level: level,
        // æ·»åŠ æºä»£ç ä½ç½®(ä»… Debug çº§åˆ«)
        AddSource: level == slog.LevelDebug,
    }

    if format == "json" {
        // ç”Ÿäº§ç¯å¢ƒ: JSON æ ¼å¼
        handler = slog.NewJSONHandler(os.Stdout, opts)
    } else {
        // å¼€å‘ç¯å¢ƒ: æ–‡æœ¬æ ¼å¼
        handler = slog.NewTextHandler(os.Stdout, opts)
    }

    logger := slog.New(handler)
    slog.SetDefault(logger)

    slog.Info("æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ",
        "level", level.String(),
        "format", format,
    )
}

func main() {
    // åˆå§‹åŒ–æ—¥å¿—(æ”¾åœ¨æœ€å‰é¢)
    setupLogger()

    // ... å…¶ä»–åˆå§‹åŒ–ä»£ç 
    slog.Info("æœåŠ¡å™¨å¯åŠ¨",
        "addr", ":7789",
        "db_path", dbPath,
    )

    // ...
}
```

---

### æ­¥éª¤ 3: æ›´æ–°è·¯ç”±æ³¨å†Œ

> **æ³¨æ„**ï¼šä»¥ä¸‹ç¤ºä¾‹ä¸é¡¹ç›®ç°æœ‰çš„ `api/routes.go` ç»“æ„ä¿æŒä¸€è‡´ã€‚
> å‚è€ƒå½“å‰é¡¹ç›® `api/routes.go:58-68` çš„ `registerTodoRoutes` é—­åŒ…æ¨¡å¼ã€‚

åœ¨ `api/routes.go` ä¸­ä½¿ç”¨æ–°çš„ä¸­é—´ä»¶:

```go
package api

import (
    "net/http"
    "todo-list/handler"
)

// chain é“¾å¼è°ƒç”¨ä¸­é—´ä»¶(ä»å³åˆ°å·¦æ‰§è¡Œ)
func chain(h http.HandlerFunc, middlewares ...func(http.HandlerFunc) http.HandlerFunc) http.HandlerFunc {
    for i := len(middlewares) - 1; i >= 0; i-- {
        h = middlewares[i](h)
    }
    return h
}

// SetupRoutes è®¾ç½®è·¯ç”±
func SetupRoutes(h *handler.Handler) *http.ServeMux {
    mux := http.NewServeMux()

    // ä¸­é—´ä»¶é“¾: Recover -> CORS -> Logging -> Handler
    // æ‰§è¡Œé¡ºåº: Logging å…ˆè®°å½• -> CORS å¤„ç† -> Handler æ‰§è¡Œ -> Recover å…œåº•
    withMiddlewares := func(handler http.HandlerFunc) http.HandlerFunc {
        return chain(handler,
            RecoverMiddleware,
            CORSMiddleware,
            LoggingMiddleware,
        )
    }

    // OPTIONS å¤„ç†å™¨ï¼ˆå¤ç”¨ç°æœ‰çš„ï¼‰
    optionsHandler := func(w http.ResponseWriter, r *http.Request) {
        w.WriteHeader(http.StatusOK)
    }

    // å¥åº·æ£€æŸ¥(ä¸è®°å½•æ—¥å¿—ï¼Œé¿å…åˆ·å±)
    mux.HandleFunc("GET /health", h.HealthCheck)

    // ä½¿ç”¨é—­åŒ…æ³¨å†Œè·¯ç”±ï¼ˆä¸é¡¹ç›®ç°æœ‰ç»“æ„ä¿æŒä¸€è‡´ï¼‰
    registerTodoRoutes := func(base string) {
        mux.HandleFunc("GET "+base, withMiddlewares(h.ListTodos))
        mux.HandleFunc("POST "+base, withMiddlewares(h.CreateTodo))
        mux.HandleFunc("OPTIONS "+base, withMiddlewares(optionsHandler))

        mux.HandleFunc("GET "+base+"/stats", withMiddlewares(h.GetStats))

        // æ•™å­¦-5/6ï¼šæ‰¹é‡æ“ä½œè·¯ç”±ï¼ˆå¦‚æœå·²å®ç°ï¼‰
        // mux.HandleFunc("POST "+base+"/batch/complete", withMiddlewares(h.BatchCompleteTodosPartial))
        // mux.HandleFunc("POST "+base+"/batch/delete", withMiddlewares(h.BatchDeleteTodosPartial))

        // æ•™å­¦-7ï¼šå¯¼å…¥å¯¼å‡ºè·¯ç”±ï¼ˆå¦‚æœå·²å®ç°ï¼‰
        // mux.HandleFunc("GET "+base+"/export", withMiddlewares(h.ExportTodos))
        // mux.HandleFunc("POST "+base+"/import", withMiddlewares(h.ImportTodos))

        // æ•™å­¦-8ï¼šå›æ”¶ç«™è·¯ç”±ï¼ˆå¦‚æœå·²å®ç°ï¼‰
        // mux.HandleFunc("GET "+base+"/trash", withMiddlewares(h.ListTrash))
        // mux.HandleFunc("DELETE "+base+"/trash", withMiddlewares(h.ClearTrash))

        mux.HandleFunc("PUT "+base+"/{id}", withMiddlewares(h.UpdateTodo))
        mux.HandleFunc("DELETE "+base+"/{id}", withMiddlewares(h.DeleteTodo))
        mux.HandleFunc("OPTIONS "+base+"/{id}", withMiddlewares(optionsHandler))
    }

    // æ³¨å†Œä¸¤ä¸ªç‰ˆæœ¬çš„è·¯ç”±
    registerTodoRoutes("/api/v1/todos")
    registerTodoRoutes("/api/todos")

    return mux
}
```

---

### æ­¥éª¤ 4: åœ¨ Handler ä¸­ä½¿ç”¨ç»“æ„åŒ–æ—¥å¿—

> **æ³¨æ„**ï¼šHandler å±‚çš„æ—¥å¿—åº”ä¸æ•™å­¦-5/6/7/8 çš„é”™è¯¯å¤„ç†æ¨¡å¼ä¿æŒä¸€è‡´ã€‚
> ç‰¹åˆ«æ˜¯è¶…æ—¶é”™è¯¯(`context.DeadlineExceeded`)å’Œå–æ¶ˆé”™è¯¯(`context.Canceled`)çš„å¤„ç†ã€‚

æ›´æ–° `handler/handler.go`:

```go
import "log/slog"

// CreateTodo åˆ›å»ºå¾…åŠäº‹é¡¹
func (h *Handler) CreateTodo(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Contextï¼ˆä¸æ•™å­¦-5/6/7/8ä¸€è‡´ï¼‰
    ctx, cancel := context.WithTimeout(r.Context(), CreateTimeout)
    defer cancel()

    defer r.Body.Close()

    var req CreateTodoRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        slog.Warn("JSON è§£æå¤±è´¥",
            "error", err,
            "path", r.URL.Path,
        )
        h.sendError(w, http.StatusBadRequest, "INVALID_JSON", "JSON è§£æå¤±è´¥")
        return
    }

    if req.Title == "" {
        h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", "æ ‡é¢˜ä¸èƒ½ä¸ºç©º")
        return
    }

    todo := model.NewTodo(req.Title, req.Description)

    if err := h.db.CreateTodoContext(ctx, todo); err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6/7/8ä¸€è‡´ï¼‰
        if errors.Is(err, context.DeadlineExceeded) {
            slog.Error("åˆ›å»ºå¾…åŠäº‹é¡¹è¶…æ—¶",
                "error", err,
                "title", req.Title,
            )
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "åˆ›å»ºè¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            slog.Debug("åˆ›å»ºå¾…åŠäº‹é¡¹è¢«å–æ¶ˆ",
                "error", err,
            )
            return // å®¢æˆ·ç«¯å–æ¶ˆï¼Œä¸å“åº”
        }
        slog.Error("åˆ›å»ºå¾…åŠäº‹é¡¹å¤±è´¥",
            "error", err,
            "title", req.Title,
        )
        h.sendError(w, http.StatusInternalServerError, "DATABASE_ERROR", "åˆ›å»ºå¤±è´¥")
        return
    }

    slog.Debug("åˆ›å»ºå¾…åŠäº‹é¡¹æˆåŠŸ",
        "id", todo.ID,
        "title", todo.Title,
    )

    h.sendJSON(w, http.StatusCreated, Response{
        Success: true,
        Data:    todo,
        Message: "åˆ›å»ºæˆåŠŸ",
    })
}
```

---

## âš ï¸ å…³é”®ç‚¹è§£æ

### 1. æ•æ„Ÿä¿¡æ¯è„±æ•

**é—®é¢˜**: ä¸å°å¿ƒè®°å½•äº†å¯†ç ã€Token

```go
// âŒ å±é™©ï¼è®°å½•äº†æ•æ„Ÿä¿¡æ¯
slog.Info("ç”¨æˆ·ç™»å½•", "password", req.Password)
```

**è§£å†³æ–¹æ¡ˆ**:
```go
// âœ… è„±æ•å¤„ç†
func maskSensitive(s string) string {
    if len(s) <= 4 {
        return "****"
    }
    return s[:2] + "****" + s[len(s)-2:]
}

// æˆ–è€…ä½¿ç”¨è‡ªå®šä¹‰ç±»å‹
type SensitiveString string

func (s SensitiveString) LogValue() slog.Value {
    return slog.StringValue("****")
}
```

---

### 2. æ—¥å¿—é‡‡æ ·(é«˜æµé‡åœºæ™¯)

**é—®é¢˜**: æ¯ç§’ 10000 è¯·æ±‚ï¼Œæ—¥å¿—é‡å¤ªå¤§

```go
// é‡‡æ ·æ—¥å¿—: åªè®°å½• 1% çš„è¯·æ±‚
func LoggingMiddleware(next http.HandlerFunc) http.HandlerFunc {
    var counter uint64
    return func(w http.ResponseWriter, r *http.Request) {
        shouldLog := atomic.AddUint64(&counter, 1)%100 == 0

        // ... æ‰§è¡Œè¯·æ±‚

        if shouldLog || ww.statusCode >= 400 {  // é”™è¯¯æ€»æ˜¯è®°å½•
            slog.Info("è¯·æ±‚å®Œæˆ", ...)
        }
    }
}
```

---

### 3. å¼‚æ­¥æ—¥å¿—(è¿›é˜¶)

**é—®é¢˜**: æ—¥å¿—å†™å…¥ I/O é˜»å¡è¯·æ±‚

```go
// å¼‚æ­¥æ—¥å¿— Handler
type AsyncHandler struct {
    ch      chan *slog.Record
    handler slog.Handler
}

func NewAsyncHandler(h slog.Handler) *AsyncHandler {
    ah := &AsyncHandler{
        ch:      make(chan *slog.Record, 10000),
        handler: h,
    }
    go ah.run()
    return ah
}

func (h *AsyncHandler) Handle(ctx context.Context, r slog.Record) error {
    select {
    case h.ch <- &r:
    default:
        // ç¼“å†²åŒºæ»¡ï¼Œä¸¢å¼ƒæ—¥å¿—(æˆ–åŒæ­¥å†™å…¥)
    }
    return nil
}

func (h *AsyncHandler) run() {
    for r := range h.ch {
        h.handler.Handle(context.Background(), *r)
    }
}
```

**æ³¨æ„**: å¯¹äºæœ¬å­¦ä¹ é¡¹ç›®ï¼ŒåŒæ­¥æ—¥å¿—å·²ç»è¶³å¤Ÿã€‚

---

### 4. è¯·æ±‚ ID ä¼ é€’

**è·¨æœåŠ¡è¿½è¸ª**:
```go
// æ£€æŸ¥è¯·æ±‚å¤´ä¸­æ˜¯å¦æœ‰ä¼ å…¥çš„è¯·æ±‚ ID
func getOrCreateRequestID(r *http.Request) string {
    if id := r.Header.Get("X-Request-ID"); id != "" {
        return id  // ä½¿ç”¨ä¸Šæ¸¸ä¼ å…¥çš„ ID
    }
    return generateRequestID()  // ç”Ÿæˆæ–°çš„ ID
}

// è°ƒç”¨ä¸‹æ¸¸æœåŠ¡æ—¶ä¼ é€’
func callDownstream(ctx context.Context, requestID string) {
    req, _ := http.NewRequestWithContext(ctx, "GET", "http://...", nil)
    req.Header.Set("X-Request-ID", requestID)
    // ...
}
```

---

### 5. ä¸æ•™å­¦-5/6/7/8 çš„ä¸€è‡´æ€§

**æ—¥å¿—çº§åˆ«ä¸é”™è¯¯ç±»å‹å¯¹åº”**:
```go
// ä¸ Handler å±‚è¶…æ—¶æ§åˆ¶é…åˆ
if errors.Is(err, context.DeadlineExceeded) {
    slog.Error("æ“ä½œè¶…æ—¶", "error", err)  // ERROR çº§åˆ«
    h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "...")
}
if errors.Is(err, context.Canceled) {
    slog.Debug("æ“ä½œè¢«å–æ¶ˆ", "error", err)  // DEBUG çº§åˆ«ï¼ˆæ­£å¸¸æƒ…å†µï¼‰
    return
}

// ä¸šåŠ¡é”™è¯¯
slog.Warn("éªŒè¯å¤±è´¥", "error", err)  // WARN çº§åˆ«ï¼ˆ400 é”™è¯¯ï¼‰

// ç³»ç»Ÿé”™è¯¯
slog.Error("æ•°æ®åº“é”™è¯¯", "error", err)  // ERROR çº§åˆ«ï¼ˆ500 é”™è¯¯ï¼‰
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

echo "=== 1. å¯åŠ¨æœåŠ¡å™¨(å¼€å‘æ¨¡å¼) ==="
# LOG_LEVEL=debug go run cmd/server/main.go &
# sleep 2

echo "=== 2. å‘é€æ­£å¸¸è¯·æ±‚ ==="
curl -s http://localhost:7789/api/v1/todos | head -1
# æŸ¥çœ‹æ—¥å¿—: INFO è¯·æ±‚å®Œæˆ method=GET path=/api/v1/todos status=200 duration_ms=5

echo -e "\n=== 3. å‘é€åˆ›å»ºè¯·æ±‚ ==="
curl -s -X POST http://localhost:7789/api/v1/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "æµ‹è¯•æ—¥å¿—"}' | jq '.data.id'
# æŸ¥çœ‹æ—¥å¿—: INFO è¯·æ±‚å®Œæˆ method=POST path=/api/v1/todos status=201 duration_ms=10

echo -e "\n=== 4. å‘é€é”™è¯¯è¯·æ±‚(400) ==="
curl -s -X POST http://localhost:7789/api/v1/todos \
  -H "Content-Type: application/json" \
  -d '{"title": ""}'
# æŸ¥çœ‹æ—¥å¿—: WARN è¯·æ±‚å®Œæˆ method=POST path=/api/v1/todos status=400 duration_ms=1

echo -e "\n=== 5. å‘é€æ— æ•ˆ JSON ==="
curl -s -X POST http://localhost:7789/api/v1/todos \
  -H "Content-Type: application/json" \
  -d 'invalid json'
# æŸ¥çœ‹æ—¥å¿—: WARN JSON è§£æå¤±è´¥ error=...

echo -e "\n=== 6. æ£€æŸ¥å“åº”å¤´ä¸­çš„è¯·æ±‚ ID ==="
curl -I http://localhost:7789/api/v1/todos 2>/dev/null | grep X-Request-ID

echo -e "\n=== 7. æµ‹è¯• JSON æ ¼å¼æ—¥å¿— ==="
# LOG_FORMAT=json LOG_LEVEL=info go run cmd/server/main.go
# è¾“å‡º: {"time":"...","level":"INFO","msg":"è¯·æ±‚å®Œæˆ",...}
```

### é¢„æœŸæ—¥å¿—è¾“å‡º

**å¼€å‘æ¨¡å¼(æ–‡æœ¬æ ¼å¼)**:
```
time=2024-01-15T10:30:00.000+08:00 level=INFO msg="æ—¥å¿—ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆ" level=INFO format=""
time=2024-01-15T10:30:00.001+08:00 level=INFO msg="æœåŠ¡å™¨å¯åŠ¨" addr=:7789 db_path=./todos.db
time=2024-01-15T10:30:05.123+08:00 level=INFO msg="è¯·æ±‚å®Œæˆ" request_id=a1b2c3d4e5f6 method=GET path=/api/v1/todos status=200 bytes=1234 duration_ms=15 client_ip=127.0.0.1
time=2024-01-15T10:30:06.456+08:00 level=WARN msg="è¯·æ±‚å®Œæˆ" request_id=b2c3d4e5f6g7 method=POST path=/api/v1/todos status=400 bytes=89 duration_ms=2 client_ip=127.0.0.1
```

**ç”Ÿäº§æ¨¡å¼(JSON æ ¼å¼)**:
```json
{"time":"2024-01-15T10:30:05.123Z","level":"INFO","msg":"è¯·æ±‚å®Œæˆ","request_id":"a1b2c3d4e5f6","method":"GET","path":"/api/v1/todos","status":200,"bytes":1234,"duration_ms":15,"client_ip":"127.0.0.1"}
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

**æ—¥å¿—ä¸­é—´ä»¶**:
- [ ] è®°å½•è¯·æ±‚æ–¹æ³•å’Œè·¯å¾„
- [ ] è®°å½•å“åº”çŠ¶æ€ç 
- [ ] è®°å½•è¯·æ±‚è€—æ—¶(æ¯«ç§’)
- [ ] è®°å½•å®¢æˆ·ç«¯ IP
- [ ] ç”Ÿæˆå¹¶è¿”å›è¯·æ±‚ ID
- [ ] æ ¹æ®çŠ¶æ€ç é€‰æ‹©æ—¥å¿—çº§åˆ«

**æ—¥å¿—é…ç½®**:
- [ ] æ”¯æŒæ—¥å¿—çº§åˆ«é…ç½®(ç¯å¢ƒå˜é‡)
- [ ] æ”¯æŒ JSON æ ¼å¼è¾“å‡º
- [ ] å¼€å‘æ¨¡å¼ä½¿ç”¨æ–‡æœ¬æ ¼å¼
- [ ] ç”Ÿäº§æ¨¡å¼ä½¿ç”¨ JSON æ ¼å¼

**ä¸æ•™å­¦-5/6/7/8 çš„ä¸€è‡´æ€§**:
- [ ] Handler å±‚ä½¿ç”¨ `slog` æ›¿ä»£ `log`
- [ ] è¶…æ—¶é”™è¯¯ä½¿ç”¨ `slog.Error` è®°å½•
- [ ] å–æ¶ˆé”™è¯¯ä½¿ç”¨ `slog.Debug` è®°å½•
- [ ] ä¸šåŠ¡é”™è¯¯ä½¿ç”¨ `slog.Warn` è®°å½•
- [ ] è·¯ç”±æ³¨å†Œä½¿ç”¨é—­åŒ…æ¨¡å¼

**å®‰å…¨æ€§**:
- [ ] ä¸è®°å½•æ•æ„Ÿä¿¡æ¯(å¯†ç ã€Token)
- [ ] å¥åº·æ£€æŸ¥ä¸è®°å½•æ—¥å¿—(é˜²æ­¢åˆ·å±)
- [ ] é”™è¯¯æ—¥å¿—åŒ…å«è¶³å¤Ÿçš„è°ƒè¯•ä¿¡æ¯

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: ä¸ºä»€ä¹ˆè¦ç”¨ç»“æ„åŒ–æ—¥å¿—?

**ç­”**:
1. **å¯æœç´¢**: åœ¨æ—¥å¿—ç³»ç»Ÿä¸­æŒ‰å­—æ®µè¿‡æ»¤(å¦‚ `status:500`)
2. **å¯èšåˆ**: ç»Ÿè®¡ API è°ƒç”¨æ¬¡æ•°ã€å¹³å‡è€—æ—¶
3. **å¯è§£æ**: ç¨‹åºå¯ä»¥è¯»å–å’Œåˆ†ææ—¥å¿—
4. **å¯æ‰©å±•**: æ–¹ä¾¿æ·»åŠ æ–°å­—æ®µ

### Q2: æ—¥å¿—åº”è¯¥è®°å½•ä»€ä¹ˆ?

**ç­”**:
- **å¿…é¡»è®°å½•**: è¯·æ±‚æ–¹æ³•ã€è·¯å¾„ã€çŠ¶æ€ç ã€è€—æ—¶ã€é”™è¯¯
- **å»ºè®®è®°å½•**: è¯·æ±‚ IDã€å®¢æˆ·ç«¯ IPã€å“åº”å¤§å°
- **ä¸è¦è®°å½•**: å¯†ç ã€Tokenã€ä¿¡ç”¨å¡å·ã€å®Œæ•´è¯·æ±‚ä½“(å¤ªå¤§)

### Q3: æ—¥å¿—çº§åˆ«æ€ä¹ˆé€‰?

**ç­”**:
- **DEBUG**: å¼€å‘è°ƒè¯•ä¿¡æ¯ï¼Œç”Ÿäº§ç¯å¢ƒå…³é—­
- **INFO**: æ­£å¸¸ä¸šåŠ¡æ—¥å¿—ï¼Œå¦‚è¯·æ±‚å®Œæˆ
- **WARN**: å¼‚å¸¸ä½†å¯æ¢å¤ï¼Œå¦‚ 400 é”™è¯¯
- **ERROR**: ä¸¥é‡é”™è¯¯ï¼Œå¦‚ 500 é”™è¯¯ã€æ•°æ®åº“è¿æ¥å¤±è´¥ã€è¶…æ—¶

### Q4: å¦‚ä½•åœ¨åˆ†å¸ƒå¼ç³»ç»Ÿä¸­è¿½è¸ªè¯·æ±‚?

**ç­”**: ä½¿ç”¨ OpenTelemetry:
```go
import "go.opentelemetry.io/otel/trace"

// åœ¨ä¸­é—´ä»¶ä¸­åˆ›å»º Span
span := trace.SpanFromContext(r.Context())
traceID := span.SpanContext().TraceID().String()
slog.Info("è¯·æ±‚å®Œæˆ", "trace_id", traceID, ...)
```

---

## ğŸš€ å®ç°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: åˆ›å»º `api/middleware.go`ï¼Œå®ç° `responseWrapper`

**ç¬¬ 2 æ­¥**: å®ç° `LoggingMiddleware`

**ç¬¬ 3 æ­¥**: åœ¨ `main.go` ä¸­æ·»åŠ  `setupLogger()`

**ç¬¬ 4 æ­¥**: æ›´æ–°è·¯ç”±æ³¨å†Œï¼Œåº”ç”¨ä¸­é—´ä»¶ï¼ˆä¿æŒé—­åŒ…æ¨¡å¼ï¼‰

**ç¬¬ 5 æ­¥**: æ›´æ–° Handler ä¸­çš„æ—¥å¿—è°ƒç”¨ä¸º `slog`

**ç¬¬ 6 æ­¥**: æµ‹è¯•ä¸åŒåœºæ™¯çš„æ—¥å¿—è¾“å‡º

---

**ä¸æ•™å­¦-5/6/7/8 çš„ä¸€è‡´æ€§**ï¼š
- **è·¯ç”±æ³¨å†Œ**ï¼šä½¿ç”¨ `registerTodoRoutes` é—­åŒ…æ¨¡å¼
- **ä¸­é—´ä»¶é“¾**ï¼š`Recover -> CORS -> Logging -> Handler`
- **é”™è¯¯å¤„ç†**ï¼šåŒºåˆ† `DeadlineExceeded`ã€`Canceled`ã€ä¸šåŠ¡é”™è¯¯
- **æ—¥å¿—çº§åˆ«**ï¼šè¶…æ—¶=ERRORï¼Œå–æ¶ˆ=DEBUGï¼Œä¸šåŠ¡é”™è¯¯=WARN

**ç°åœ¨ï¼Œå¼€å§‹å®ç°è¯·æ±‚æ—¥å¿—ä¸­é—´ä»¶å§ï¼è®°ä½ï¼šç»“æ„åŒ–ã€åˆ†çº§ã€è„±æ•ã€ä¸ç°æœ‰ä»£ç é£æ ¼ä¿æŒä¸€è‡´ã€‚** ğŸš€
