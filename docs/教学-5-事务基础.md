# 教学 Part 5: 事务基础

> **📌 学习阶段**: 中级 / Go 数据库编程
> **前置要求**: 已掌握基础 CRUD、SQL 查询
> **学习目标**: 理解事务 ACID、掌握 Go 事务使用、实现简单批量操作
> **时间投入**: 3-4 小时(理解原理 + 实现 + 测试)

---

## 🎯 功能分析 - Linus 式思考

### Linus 的三个问题

**1. "这是个真问题还是臆想出来的？"**

✅ **真实问题**：
- 用户选择了 10 个待办事项要删除，其中第 5 个删除失败了
- 结果：前 4 个被删除，后 5 个还在 → 数据不一致！
- 用户困惑："为什么只删了一部分？"

**为什么需要事务？**
- **原子性**: 要么全成功，要么全失败
- **一致性**: 保持数据完整性
- **隔离性**: 并发操作不互相干扰

**2. "有更简单的方法吗？"**

💡 **核心思路**：使用数据库事务

**没有事务的问题**:
```go
// ❌ 部分失败会导致数据不一致
for _, id := range ids {
    db.Exec("DELETE FROM todos WHERE id = ?", id)  // 第5个失败
    // 前4个已删除，无法回滚！
}
```

**有事务的解决方案**:
```go
// ✅ 失败时自动回滚
tx, _ := db.Begin()
for _, id := range ids {
    if err := tx.Exec("DELETE..."); err != nil {
        tx.Rollback()  // 撤销所有操作
        return err
    }
}
tx.Commit()  // 全部成功才提交
```

**3. "会破坏什么吗？"**

✅ **安全设计**：
- 事务默认会回滚（如果忘记 Commit）
- SQLite 有默认超时（5秒）
- 事务是连接级别的，不影响其他连接

---

## 📚 核心知识讲解

### 1. 事务的 ACID 特性

ACID 是数据库事务的四大保证，让我们通过例子理解：

#### A - Atomicity（原子性）
**"要么全做，要么全不做"**

```go
// 场景：转账 100 元（A账户 -100，B账户 +100）
tx.Begin()
tx.Exec("UPDATE accounts SET balance = balance - 100 WHERE id = 'A'")  // ✅
tx.Exec("UPDATE accounts SET balance = balance + 100 WHERE id = 'B'")  // ❌ 失败
tx.Rollback()  // A账户的钱也会恢复，不会凭空消失100元
```

#### C - Consistency（一致性）
**"始终满足业务规则"**

```go
// 规则：账户余额不能为负
tx.Begin()
tx.Exec("UPDATE accounts SET balance = -100")  // ❌ 违反约束
tx.Commit()  // 失败！数据库拒绝这种不一致的状态
```

#### I - Isolation（隔离性）
**"事务之间不互相干扰"**

```go
// 事务A和事务B同时执行
// 事务A: 读取 balance = 1000
// 事务B: 修改 balance = 500（未提交）
// 事务A: 再次读取 balance = 1000（看不到B的修改）
```

#### D - Durability（持久性）
**"提交后永久保存"**

```go
tx.Commit()  // ✅ 成功
// 即使此时断电，数据也已经写入磁盘
```

---

### 2. Go 中的事务基本操作

#### 开启事务
```go
tx, err := db.Begin()
if err != nil {
    return fmt.Errorf("开启事务失败: %w", err)
}
```

#### 执行操作
```go
_, err = tx.Exec("DELETE FROM todos WHERE id = ?", id)
if err != nil {
    tx.Rollback()  // 出错时回滚
    return fmt.Errorf("删除失败: %w", err)
}
```

#### 提交或回滚
```go
// 提交事务
if err := tx.Commit(); err != nil {
    return fmt.Errorf("提交事务失败: %w", err)
}

// 或者回滚
if err := tx.Rollback(); err != nil {
    // Rollback 也可能失败（如连接已断开）
    log.Printf("回滚失败: %v", err)
}
```

---

### 3. 事务的标准模式

**推荐模式**：使用 defer 确保清理

```go
func DeleteMultipleTodos(db *sql.DB, ids []int) error {
    // 1. 开启事务
    tx, err := db.Begin()
    if err != nil {
        return fmt.Errorf("开启事务失败: %w", err)
    }

    // 2. 确保事务被正确处理
    defer func() {
        if err != nil {
            tx.Rollback()  // 有错误时回滚
            return
        }
        err = tx.Commit()  // 无错误时提交
    }()

    // 3. 执行业务逻辑
    for _, id := range ids {
        _, err = tx.Exec("DELETE FROM todos WHERE id = ?", id)
        if err != nil {
            return fmt.Errorf("删除 ID %d 失败: %w", id, err)
        }
    }

    return nil
}
```

**关键点**：
- `defer` 确保事务一定会被处理（提交或回滚）
- 使用命名返回值 `err` 让 defer 能访问到错误
- 每步操作都检查错误

---

## 💻 实战：实现简单的批量操作

### 需求描述

实现两个批量操作功能：
1. **批量完成**：将多个待办事项标记为已完成
2. **批量删除**：删除多个待办事项

**要求**：
- 使用事务保证原子性
- 全部成功或全部失败
- 限制批量大小（最多100个）

### 步骤 1：数据库层实现

创建 `database/batch.go` 文件：

```go
package database

import (
    "fmt"
    "time"
)

// BatchCompleteTodos 批量完成待办事项（全有或全无）
func (db *DB) BatchCompleteTodos(ids []int) error {
    // 验证输入
    if len(ids) == 0 {
        return nil  // 空列表直接返回成功
    }

    if len(ids) > 100 {
        return fmt.Errorf("批量操作最多支持100个项目，当前: %d", len(ids))
    }

    // 开启事务
    tx, err := db.conn.Begin()
    if err != nil {
        return fmt.Errorf("开启事务失败: %w", err)
    }

    // 使用 defer 确保事务被处理
    defer func() {
        if err != nil {
            tx.Rollback()
        }
    }()

    // 批量更新
    now := time.Now().UTC()
    for _, id := range ids {
        result, err := tx.Exec(`
            UPDATE todos
            SET status = 'completed',
                completed_at = ?,
                updated_at = ?
            WHERE id = ? AND status = 'pending'
        `, now, now, id)

        if err != nil {
            return fmt.Errorf("更新 ID %d 失败: %w", id, err)
        }

        // 检查是否真的更新了
        rows, err := result.RowsAffected()
        if err != nil {
            return fmt.Errorf("获取影响行数失败: %w", err)
        }

        if rows == 0 {
            return fmt.Errorf("待办事项 %d 不存在或已完成", id)
        }
    }

    // 提交事务
    if err = tx.Commit(); err != nil {
        return fmt.Errorf("提交事务失败: %w", err)
    }

    return nil
}

// BatchDeleteTodos 批量删除待办事项（全有或全无）
func (db *DB) BatchDeleteTodos(ids []int) error {
    // 验证输入
    if len(ids) == 0 {
        return nil
    }

    if len(ids) > 100 {
        return fmt.Errorf("批量操作最多支持100个项目，当前: %d", len(ids))
    }

    // 开启事务
    tx, err := db.conn.Begin()
    if err != nil {
        return fmt.Errorf("开启事务失败: %w", err)
    }

    // 使用 defer 确保事务被处理
    defer func() {
        if err != nil {
            tx.Rollback()
        }
    }()

    // 批量删除
    for _, id := range ids {
        result, err := tx.Exec("DELETE FROM todos WHERE id = ?", id)

        if err != nil {
            return fmt.Errorf("删除 ID %d 失败: %w", id, err)
        }

        // 检查是否真的删除了
        rows, err := result.RowsAffected()
        if err != nil {
            return fmt.Errorf("获取影响行数失败: %w", err)
        }

        if rows == 0 {
            return fmt.Errorf("待办事项 %d 不存在", id)
        }
    }

    // 提交事务
    if err = tx.Commit(); err != nil {
        return fmt.Errorf("提交事务失败: %w", err)
    }

    return nil
}
```

### 步骤 2：处理器层实现

在 `handler/handler.go` 中添加：

```go
// BatchRequest 批量操作请求
type BatchRequest struct {
    IDs []int `json:"ids"`
}

// BatchCompleteTodos 批量完成待办事项
func (h *Handler) BatchCompleteTodos(w http.ResponseWriter, r *http.Request) {
    defer r.Body.Close()

    var req BatchRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, http.StatusBadRequest, "INVALID_JSON", "请求格式错误")
        return
    }

    // 验证请求
    if len(req.IDs) == 0 {
        h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", "IDs不能为空")
        return
    }

    // 执行批量操作
    if err := h.db.BatchCompleteTodos(req.IDs); err != nil {
        log.Printf("批量完成失败: %v", err)
        h.sendError(w, http.StatusInternalServerError, "BATCH_ERROR", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Message: fmt.Sprintf("成功完成 %d 个待办事项", len(req.IDs)),
    })
}

// BatchDeleteTodos 批量删除待办事项
func (h *Handler) BatchDeleteTodos(w http.ResponseWriter, r *http.Request) {
    defer r.Body.Close()

    var req BatchRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, http.StatusBadRequest, "INVALID_JSON", "请求格式错误")
        return
    }

    // 验证请求
    if len(req.IDs) == 0 {
        h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", "IDs不能为空")
        return
    }

    // 执行批量操作
    if err := h.db.BatchDeleteTodos(req.IDs); err != nil {
        log.Printf("批量删除失败: %v", err)
        h.sendError(w, http.StatusInternalServerError, "BATCH_ERROR", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Message: fmt.Sprintf("成功删除 %d 个待办事项", len(req.IDs)),
    })
}
```

### 步骤 3：注册路由

在 `api/routes.go` 中添加：

```go
// 批量操作路由（注意：要在 /{id} 路由之前注册）
mux.HandleFunc("POST "+base+"/batch/complete", withMiddlewares(h.BatchCompleteTodos))
mux.HandleFunc("POST "+base+"/batch/delete", withMiddlewares(h.BatchDeleteTodos))
```

---

## ⚠️ 常见陷阱

### 1. 忘记处理事务

**错误代码**：
```go
tx, _ := db.Begin()
tx.Exec("DELETE FROM todos WHERE id = 1")
// 忘记 Commit，事务会自动回滚！
```

**正确代码**：
```go
tx, _ := db.Begin()
defer func() {
    if err != nil {
        tx.Rollback()
    } else {
        tx.Commit()
    }
}()
tx.Exec("DELETE FROM todos WHERE id = 1")
```

### 2. Commit 后继续使用事务

**错误代码**：
```go
tx.Commit()
tx.Exec("DELETE...")  // ❌ 错误：事务已结束
```

### 3. 不检查 RowsAffected

**问题**：
```go
tx.Exec("DELETE FROM todos WHERE id = 999")  // ID不存在
// 没有错误，但也没有删除任何东西
```

**解决**：
```go
result, _ := tx.Exec("DELETE FROM todos WHERE id = 999")
if rows, _ := result.RowsAffected(); rows == 0 {
    return fmt.Errorf("记录不存在")
}
```

---

## 🧪 测试你的实现

### 测试脚本

创建 `scripts/test-batch-simple.sh`:

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1/todos"

echo "=== 创建测试数据 ==="
for i in {1..5}; do
  curl -s -X POST "$BASE_URL" \
    -H "Content-Type: application/json" \
    -d "{\"title\": \"任务 $i\"}" > /dev/null
  echo "创建任务 $i"
done

echo -e "\n=== 测试批量完成 ==="
curl -X POST "$BASE_URL/batch/complete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [1, 2, 3]}'

echo -e "\n\n=== 测试批量删除 ==="
curl -X POST "$BASE_URL/batch/delete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [4, 5]}'

echo -e "\n\n=== 测试错误情况（不存在的ID）==="
curl -X POST "$BASE_URL/batch/delete" \
  -H "Content-Type: application/json" \
  -d '{"ids": [999]}'
```

### 预期结果

1. **批量完成成功**：返回 "成功完成 3 个待办事项"
2. **批量删除成功**：返回 "成功删除 2 个待办事项"
3. **错误情况**：返回错误 "待办事项 999 不存在"

---

## ✅ 实现检查清单

完成实现后，确认以下内容：

**功能**：
- [ ] 批量完成功能正常工作
- [ ] 批量删除功能正常工作
- [ ] 空列表处理正确（返回成功）
- [ ] 超过100个ID时拒绝操作
- [ ] ID不存在时事务回滚

**代码质量**：
- [ ] 使用 defer 确保事务处理
- [ ] 每步操作都检查错误
- [ ] 检查 RowsAffected
- [ ] 有合理的错误信息

**安全性**：
- [ ] 使用参数化查询（防SQL注入）
- [ ] 有批量大小限制
- [ ] 事务超时保护（SQLite默认5秒）

---

## 📖 扩展学习

学完基础事务后，可以了解：

1. **事务隔离级别**
   - READ UNCOMMITTED
   - READ COMMITTED
   - REPEATABLE READ
   - SERIALIZABLE

2. **分布式事务**
   - 两阶段提交（2PC）
   - 三阶段提交（3PC）
   - Saga模式

3. **性能优化**
   - 批量插入优化
   - 事务大小权衡
   - 锁竞争处理

---

## 🎯 下一步

完成本节后，你应该：
1. 理解事务的ACID特性
2. 掌握Go中的事务使用
3. 能实现简单的批量操作

**下一节**：如果需要更复杂的批量操作（部分失败处理），参考 `教学-5b-批量操作进阶.md`

---

## 💡 记住

> "Simplicity is the ultimate sophistication." - Leonardo da Vinci

从简单的"全有或全无"开始，这已经能解决90%的批量操作需求。只有在真正需要时才增加复杂性。

**现在，开始动手实现吧！** 🚀