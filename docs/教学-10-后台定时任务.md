# æ•™å­¦ Part 10: åå°å®šæ—¶ä»»åŠ¡

> **ğŸ“Œ å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / Go å¹¶å‘ç¼–ç¨‹
> **å‰ç½®è¦æ±‚**: å·²æŒæ¡ goroutine åŸºç¡€ã€Contextã€ä¼˜é›…å…³é—­ï¼ˆæ•™å­¦-5/6/7ï¼‰
> **å­¦ä¹ ç›®æ ‡**: æŒæ¡ `time.Ticker`ã€goroutine ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€å®šæ—¶ä»»åŠ¡è°ƒåº¦
> **æ—¶é—´æŠ•å…¥**: 2-3 å°æ—¶(ç†è§£åŸç† + å®ç° + æµ‹è¯•)

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®é—®é¢˜**:
- å›æ”¶ç«™æ•°æ®å †ç§¯ â†’ 30 å¤©ååº”è¯¥è‡ªåŠ¨æ¸…ç†
- æƒ³çŸ¥é“æœ‰å¤šå°‘è¿‡æœŸä»»åŠ¡ â†’ æ¯å¤©ç»Ÿè®¡ä¸€æ¬¡
- æ•°æ®åº“éœ€è¦å®šæœŸä¼˜åŒ– â†’ æ¯å‘¨æ‰§è¡Œä¸€æ¬¡ VACUUM

**ä¸ºä»€ä¹ˆéœ€è¦å®šæ—¶ä»»åŠ¡?**
- **æ•°æ®æ¸…ç†**: è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®
- **ç»Ÿè®¡æŠ¥å‘Š**: å®šæœŸç”Ÿæˆç»Ÿè®¡ä¿¡æ¯
- **å¥åº·æ£€æŸ¥**: å®šæœŸæ£€æµ‹ç³»ç»ŸçŠ¶æ€
- **ç»´æŠ¤ä»»åŠ¡**: æ•°æ®åº“ä¼˜åŒ–ã€æ—¥å¿—è½®è½¬

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**: `time.Ticker` + goroutine + Context + ä¼˜é›…å…³é—­

**é”™è¯¯æ–¹æ³•**(é˜»å¡ä¸»çº¿ç¨‹):
```go
// âŒ ä¼šé˜»å¡æœåŠ¡å™¨å¯åŠ¨
for {
    cleanupTrash()
    time.Sleep(24 * time.Hour)
}
```

**æ­£ç¡®æ–¹æ³•**(åå° goroutine + Context):
```go
// âœ… éé˜»å¡ï¼Œå¯ä»¥ä¼˜é›…å…³é—­ï¼Œæ”¯æŒè¶…æ—¶æ§åˆ¶
go func() {
    ticker := time.NewTicker(24 * time.Hour)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            // ä½¿ç”¨å¸¦è¶…æ—¶çš„ Contextï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
            ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
            cleanupTrash(ctx)
            cancel()
        case <-stopCh:
            return
        }
    }
}()
```

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£é™©**:
- goroutine æ³„æ¼ â†’ å¿˜è®°å…³é—­ Ticker
- ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿ â†’ ä»»åŠ¡å †ç§¯
- å¹¶å‘è®¿é—®æ•°æ®åº“ â†’ ä¸ HTTP è¯·æ±‚ç«äº‰
- ä»»åŠ¡æ‰§è¡Œä¸­æœåŠ¡å™¨å…³é—­ â†’ æ•°æ®ä¸ä¸€è‡´

âœ… **å®‰å…¨è®¾è®¡**:
- ä½¿ç”¨ Context æ§åˆ¶ä»»åŠ¡è¶…æ—¶
- ä½¿ç”¨ channel ä¿¡å·ä¼˜é›…å…³é—­
- ä½¿ç”¨ `sync.WaitGroup` ç­‰å¾…ä»»åŠ¡å®Œæˆ
- ä»»åŠ¡æ‰§è¡Œæ—¶é—´ç›‘æ§

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. time.Ticker vs time.Timer

**`time.Timer`**: ä¸€æ¬¡æ€§å®šæ—¶å™¨
```go
timer := time.NewTimer(5 * time.Second)
<-timer.C  // 5 ç§’åè§¦å‘ä¸€æ¬¡
// éœ€è¦æ‰‹åŠ¨ Reset æ‰èƒ½å†æ¬¡è§¦å‘
```

**`time.Ticker`**: å‘¨æœŸæ€§å®šæ—¶å™¨
```go
ticker := time.NewTicker(5 * time.Second)
for t := range ticker.C {
    // æ¯ 5 ç§’è§¦å‘ä¸€æ¬¡
    fmt.Println("Tick at", t)
}
```

**å¿…é¡»è°ƒç”¨ `Stop()`**:
```go
ticker := time.NewTicker(time.Second)
defer ticker.Stop()  // é˜²æ­¢ goroutine æ³„æ¼
```

---

### 2. goroutine ç”Ÿå‘½å‘¨æœŸç®¡ç†

**é—®é¢˜**: å¦‚ä½•ä¼˜é›…åœ°åœæ­¢åå° goroutine?

**æ–¹æ¡ˆ A: channel ä¿¡å·**
```go
stopCh := make(chan struct{})

go func() {
    ticker := time.NewTicker(time.Hour)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            doWork()
        case <-stopCh:
            return  // æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œé€€å‡º
        }
    }
}()

// åœæ­¢æ—¶
close(stopCh)
```

**æ–¹æ¡ˆ B: Context å–æ¶ˆï¼ˆæ¨èï¼Œä¸é¡¹ç›®é£æ ¼ä¸€è‡´ï¼‰**
```go
ctx, cancel := context.WithCancel(context.Background())

go func() {
    ticker := time.NewTicker(time.Hour)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            // åˆ›å»ºå¸¦è¶…æ—¶çš„å­ Context
            taskCtx, taskCancel := context.WithTimeout(ctx, 5*time.Minute)
            doWork(taskCtx)
            taskCancel()
        case <-ctx.Done():
            return
        }
    }
}()

// åœæ­¢æ—¶
cancel()
```

---

### 3. sync.WaitGroup ç­‰å¾…å®Œæˆ

**é—®é¢˜**: ä¸»ç¨‹åºé€€å‡ºæ—¶ï¼Œå¦‚ä½•ç¡®ä¿åå°ä»»åŠ¡å·²å®Œæˆ?

```go
var wg sync.WaitGroup

wg.Add(1)
go func() {
    defer wg.Done()
    // ... åå°ä»»åŠ¡
}()

// å…³é—­æ—¶
close(stopCh)
wg.Wait()  // ç­‰å¾…æ‰€æœ‰åå°ä»»åŠ¡é€€å‡º
```

---

### 4. é¿å…ä»»åŠ¡å †ç§¯

**é—®é¢˜**: å¦‚æœä»»åŠ¡æ‰§è¡Œæ—¶é—´ > è°ƒåº¦é—´éš”?

```go
// âŒ å¯èƒ½å †ç§¯
ticker := time.NewTicker(1 * time.Minute)
for range ticker.C {
    heavyTask()  // æ‰§è¡Œ 2 åˆ†é’Ÿ
    // ä¸‹ä¸€ä¸ª tick å·²ç»åœ¨ç­‰å¾…äº†
}

// âœ… ä½¿ç”¨ time.After é¿å…å †ç§¯
for {
    heavyTask()  // å…ˆæ‰§è¡Œ
    time.Sleep(1 * time.Minute)  // å†ç­‰å¾…
}

// âœ… æˆ–è€…æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ‰§è¡Œ
var running int32
for range ticker.C {
    if !atomic.CompareAndSwapInt32(&running, 0, 1) {
        continue  // ä¸Šä¸€æ¬¡è¿˜åœ¨æ‰§è¡Œï¼Œè·³è¿‡
    }
    go func() {
        defer atomic.StoreInt32(&running, 0)
        heavyTask()
    }()
}
```

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: åˆ›å»ºè°ƒåº¦å™¨

> **æ³¨æ„**ï¼šè°ƒåº¦å™¨ä½¿ç”¨ Context ä¼ é€’æœºåˆ¶ï¼Œä¸æ•™å­¦-5/6/7çš„ä»£ç é£æ ¼ä¿æŒä¸€è‡´ã€‚

åˆ›å»º `scheduler/scheduler.go`:

```go
package scheduler

import (
    "context"
    "log"
    "sync"
    "time"
    "todo-list/database"
)

// ä»»åŠ¡è¶…æ—¶å¸¸é‡ï¼ˆä¸ handler å±‚é£æ ¼ä¸€è‡´ï¼‰
const (
    CleanupTimeout = 5 * time.Minute  // æ¸…ç†ä»»åŠ¡è¶…æ—¶
    StatsTimeout   = 1 * time.Minute  // ç»Ÿè®¡ä»»åŠ¡è¶…æ—¶
)

// Scheduler å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
type Scheduler struct {
    db     *database.DB
    ctx    context.Context
    cancel context.CancelFunc
    wg     sync.WaitGroup
}

// New åˆ›å»ºè°ƒåº¦å™¨
func New(db *database.DB) *Scheduler {
    ctx, cancel := context.WithCancel(context.Background())
    return &Scheduler{
        db:     db,
        ctx:    ctx,
        cancel: cancel,
    }
}

// Start å¯åŠ¨æ‰€æœ‰å®šæ—¶ä»»åŠ¡
func (s *Scheduler) Start() {
    log.Println("å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨")

    // ä»»åŠ¡ 1: æ¯å°æ—¶æ£€æŸ¥è¿‡æœŸä»»åŠ¡
    s.wg.Add(1)
    go s.runTask("æ£€æŸ¥è¿‡æœŸä»»åŠ¡", 1*time.Hour, StatsTimeout, s.checkOverdueTodos)

    // ä»»åŠ¡ 2: æ¯å¤©æ¸…ç†å›æ”¶ç«™(ä¿ç•™ 30 å¤©)
    s.wg.Add(1)
    go s.runTask("æ¸…ç†å›æ”¶ç«™", 24*time.Hour, CleanupTimeout, s.cleanupTrash)

    // ä»»åŠ¡ 3: æ¯å¤©å‡Œæ™¨ç»Ÿè®¡æ•°æ®(ä»…è®°å½•æ—¥å¿—)
    s.wg.Add(1)
    go s.runTask("æ¯æ—¥ç»Ÿè®¡", 24*time.Hour, StatsTimeout, s.dailyStats)
}

// Stop åœæ­¢æ‰€æœ‰å®šæ—¶ä»»åŠ¡
func (s *Scheduler) Stop() {
    log.Println("åœæ­¢å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨...")
    s.cancel()
    s.wg.Wait()
    log.Println("æ‰€æœ‰å®šæ—¶ä»»åŠ¡å·²åœæ­¢")
}

// runTask è¿è¡Œå•ä¸ªå®šæ—¶ä»»åŠ¡ï¼ˆæ”¯æŒ Context è¶…æ—¶ï¼‰
func (s *Scheduler) runTask(name string, interval, timeout time.Duration, task func(ctx context.Context)) {
    defer s.wg.Done()

    ticker := time.NewTicker(interval)
    defer ticker.Stop()

    log.Printf("å®šæ—¶ä»»åŠ¡å·²æ³¨å†Œ: name=%s, interval=%s, timeout=%s", name, interval, timeout)

    // å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œä¸€æ¬¡
    s.safeRun(name, timeout, task)

    for {
        select {
        case <-ticker.C:
            s.safeRun(name, timeout, task)
        case <-s.ctx.Done():
            log.Printf("å®šæ—¶ä»»åŠ¡æ”¶åˆ°åœæ­¢ä¿¡å·: name=%s", name)
            return
        }
    }
}

// safeRun å®‰å…¨æ‰§è¡Œä»»åŠ¡(æ•è· panicï¼Œæ”¯æŒ Context è¶…æ—¶)
func (s *Scheduler) safeRun(name string, timeout time.Duration, task func(ctx context.Context)) {
    defer func() {
        if err := recover(); err != nil {
            log.Printf("å®šæ—¶ä»»åŠ¡ panic: name=%s, error=%v", name, err)
        }
    }()

    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Contextï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
    taskCtx, cancel := context.WithTimeout(s.ctx, timeout)
    defer cancel()

    start := time.Now()
    task(taskCtx)
    duration := time.Since(start)

    log.Printf("å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ: name=%s, duration_ms=%d", name, duration.Milliseconds())

    // ä»»åŠ¡æ‰§è¡Œå¤ªæ…¢ï¼Œè®°å½•è­¦å‘Š
    if duration > 1*time.Minute {
        log.Printf("è­¦å‘Š: å®šæ—¶ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿: name=%s, duration=%s", name, duration)
    }
}

// checkOverdueTodos æ£€æŸ¥è¿‡æœŸä»»åŠ¡ï¼ˆæ¥å— Context å‚æ•°ï¼‰
func (s *Scheduler) checkOverdueTodos(ctx context.Context) {
    stats, err := s.db.GetStatsContext(ctx)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
        if ctx.Err() == context.DeadlineExceeded {
            log.Printf("æ£€æŸ¥è¿‡æœŸä»»åŠ¡è¶…æ—¶: %v", err)
            return
        }
        if ctx.Err() == context.Canceled {
            log.Printf("æ£€æŸ¥è¿‡æœŸä»»åŠ¡å·²å–æ¶ˆ")
            return
        }
        log.Printf("è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: %v", err)
        return
    }

    if stats.Overdue > 0 {
        log.Printf("å‘ç°è¿‡æœŸä»»åŠ¡: overdue_count=%d, today_count=%d", stats.Overdue, stats.Today)
    }
}

// cleanupTrash æ¸…ç†å›æ”¶ç«™(30 å¤©å‰çš„æ•°æ®ï¼Œæ¥å— Context å‚æ•°)
func (s *Scheduler) cleanupTrash(ctx context.Context) {
    deleted, err := s.db.CleanupOldTrashContext(ctx, 30)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
        if ctx.Err() == context.DeadlineExceeded {
            log.Printf("æ¸…ç†å›æ”¶ç«™è¶…æ—¶: %v", err)
            return
        }
        if ctx.Err() == context.Canceled {
            log.Printf("æ¸…ç†å›æ”¶ç«™å·²å–æ¶ˆ")
            return
        }
        log.Printf("æ¸…ç†å›æ”¶ç«™å¤±è´¥: %v", err)
        return
    }

    if deleted > 0 {
        log.Printf("æ¸…ç†å›æ”¶ç«™å®Œæˆ: deleted_count=%d, retention_days=30", deleted)
    }
}

// dailyStats æ¯æ—¥ç»Ÿè®¡ï¼ˆæ¥å— Context å‚æ•°ï¼‰
func (s *Scheduler) dailyStats(ctx context.Context) {
    stats, err := s.db.GetStatsContext(ctx)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
        if ctx.Err() == context.DeadlineExceeded {
            log.Printf("æ¯æ—¥ç»Ÿè®¡è¶…æ—¶: %v", err)
            return
        }
        if ctx.Err() == context.Canceled {
            log.Printf("æ¯æ—¥ç»Ÿè®¡å·²å–æ¶ˆ")
            return
        }
        log.Printf("è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥: %v", err)
        return
    }

    log.Printf("æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š: total=%d, pending=%d, completed=%d, overdue=%d, today=%d, this_week=%d",
        stats.Total, stats.Pending, stats.Completed, stats.Overdue, stats.Today, stats.ThisWeek)
}
```

---

### æ­¥éª¤ 2: é›†æˆåˆ° main.go

æ›´æ–° `cmd/server/main.go`:

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    "todo-list/api"
    "todo-list/database"
    "todo-list/handler"
    "todo-list/scheduler"
)

func main() {
    // åˆå§‹åŒ–æ•°æ®åº“
    dbPath := os.Getenv("DB_PATH")
    if dbPath == "" {
        dbPath = "./todos.db"
    }

    db, err := database.New(dbPath)
    if err != nil {
        log.Fatalf("æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥: %v", err)
    }

    // åˆ›å»º Handler å’Œè·¯ç”±
    h := handler.NewHandler(db)
    mux := api.SetupRoutes(h)

    // å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
    sched := scheduler.New(db)
    sched.Start()

    // é…ç½® HTTP æœåŠ¡å™¨
    server := &http.Server{
        Addr:         ":7789",
        Handler:      mux,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // ä¿¡å·å¤„ç†
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

    // å¯åŠ¨æœåŠ¡å™¨
    go func() {
        log.Printf("æœåŠ¡å™¨å¯åŠ¨: addr=%s", server.Addr)
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("æœåŠ¡å™¨å¯åŠ¨å¤±è´¥: %v", err)
        }
    }()

    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    sig := <-sigChan
    log.Printf("æ”¶åˆ°å…³é—­ä¿¡å·: signal=%s", sig.String())

    // ä¼˜é›…å…³é—­
    shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer shutdownCancel()

    // 1. åœæ­¢å®šæ—¶ä»»åŠ¡
    sched.Stop()

    // 2. åœæ­¢ HTTP æœåŠ¡å™¨
    if err := server.Shutdown(shutdownCtx); err != nil {
        log.Printf("æœåŠ¡å™¨å…³é—­å¤±è´¥: %v", err)
        server.Close()
    } else {
        log.Println("HTTP æœåŠ¡å™¨å·²å…³é—­")
    }

    // 3. å…³é—­æ•°æ®åº“
    if err := db.Close(); err != nil {
        log.Printf("æ•°æ®åº“å…³é—­å¤±è´¥: %v", err)
    } else {
        log.Println("æ•°æ®åº“è¿æ¥å·²å…³é—­")
    }

    log.Println("æœåŠ¡å™¨å·²å®Œå…¨åœæ­¢")
}
```

---

### æ­¥éª¤ 3: æ·»åŠ æ•°æ®åº“æ¸…ç†æ–¹æ³•

> **æ³¨æ„**ï¼šå‡½æ•°å‘½åå¸¦ `Context` åç¼€ï¼Œä½¿ç”¨å‘½åè¿”å›å€¼ï¼Œä¸æ•™å­¦-5/6/7ä¿æŒä¸€è‡´ã€‚

åœ¨ `database/db.go` ä¸­æ·»åŠ :

```go
// CleanupOldTrashContext æ¸…ç†è¶…è¿‡æŒ‡å®šå¤©æ•°çš„å›æ”¶ç«™æ•°æ®ï¼ˆæ”¯æŒ Contextï¼‰
// æ³¨æ„ï¼šä½¿ç”¨å‘½åè¿”å›å€¼ (deleted int, err error)ï¼Œè®© defer èƒ½è®¿é—®åˆ°é”™è¯¯
func (db *DB) CleanupOldTrashContext(ctx context.Context, days int) (deleted int, err error) {
    cutoff := time.Now().AddDate(0, 0, -days)

    query := `DELETE FROM todos WHERE deleted_at IS NOT NULL AND deleted_at < ?`

    result, err := db.conn.ExecContext(ctx, query, cutoff)
    if err != nil {
        return 0, fmt.Errorf("æ¸…ç†æ—§æ•°æ®å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return 0, fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    return int(rows), nil
}

// GetStatsContext è·å–ç»Ÿè®¡ä¿¡æ¯ï¼ˆæ”¯æŒ Contextï¼‰
// æ³¨æ„ï¼šå¦‚æœåŸæœ‰ GetStats å‡½æ•°ä¸æ”¯æŒ Contextï¼Œéœ€è¦æ·»åŠ æ­¤ç‰ˆæœ¬
func (db *DB) GetStatsContext(ctx context.Context) (*Stats, error) {
    // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
    select {
    case <-ctx.Done():
        return nil, ctx.Err()
    default:
    }

    // ... ç°æœ‰çš„ç»Ÿè®¡æŸ¥è¯¢é€»è¾‘ï¼Œä½¿ç”¨ QueryContext æ›¿æ¢ Query ...
    // ç¤ºä¾‹ï¼š
    var stats Stats

    // ä½¿ç”¨ QueryRowContext æ›¿æ¢ QueryRow
    err := db.conn.QueryRowContext(ctx, `
        SELECT
            COUNT(*) as total,
            COUNT(CASE WHEN status = 'pending' AND deleted_at IS NULL THEN 1 END) as pending,
            COUNT(CASE WHEN status = 'completed' AND deleted_at IS NULL THEN 1 END) as completed,
            COUNT(CASE WHEN due_date < date('now') AND status = 'pending' AND deleted_at IS NULL THEN 1 END) as overdue,
            COUNT(CASE WHEN date(due_date) = date('now') AND deleted_at IS NULL THEN 1 END) as today,
            COUNT(CASE WHEN due_date BETWEEN date('now') AND date('now', '+7 days') AND deleted_at IS NULL THEN 1 END) as this_week
        FROM todos
    `).Scan(&stats.Total, &stats.Pending, &stats.Completed, &stats.Overdue, &stats.Today, &stats.ThisWeek)

    if err != nil {
        return nil, fmt.Errorf("ç»Ÿè®¡æŸ¥è¯¢å¤±è´¥: %w", err)
    }

    return &stats, nil
}
```

---

## âš ï¸ å…³é”®ç‚¹è§£æ

### 1. ç«‹å³æ‰§è¡Œ vs ç­‰å¾…ç¬¬ä¸€ä¸ªå‘¨æœŸ

```go
// æ–¹å¼ A: ç­‰å¾…ç¬¬ä¸€ä¸ªå‘¨æœŸ
ticker := time.NewTicker(24 * time.Hour)
for range ticker.C {
    task()  // æ˜å¤©æ‰ä¼šç¬¬ä¸€æ¬¡æ‰§è¡Œ
}

// æ–¹å¼ B: ç«‹å³æ‰§è¡Œä¸€æ¬¡ï¼ˆæ¨èï¼‰
task()  // å…ˆæ‰§è¡Œ
ticker := time.NewTicker(24 * time.Hour)
for range ticker.C {
    task()
}

// æ–¹å¼ C: ä½¿ç”¨ time.AfterFunc(å»¶è¿Ÿåæ‰§è¡Œä¸€æ¬¡)
time.AfterFunc(0, task)  // ç«‹å³æ‰§è¡Œ
```

**æœ¬é¡¹ç›®é€‰æ‹©æ–¹å¼ B**: å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œä¸€æ¬¡ï¼Œç„¶åæŒ‰å‘¨æœŸæ‰§è¡Œã€‚

---

### 2. é˜²æ­¢ goroutine æ³„æ¼

**é—®é¢˜**: å¿˜è®° `ticker.Stop()`

```go
// âŒ æ³„æ¼
func bad() {
    ticker := time.NewTicker(time.Second)
    go func() {
        for range ticker.C {
            // ...
        }
    }()
    // ticker æ°¸è¿œä¸ä¼šåœæ­¢
}

// âœ… æ­£ç¡®ï¼ˆä½¿ç”¨ Contextï¼‰
func good(ctx context.Context) {
    ticker := time.NewTicker(time.Second)
    go func() {
        defer ticker.Stop()  // ç¡®ä¿åœæ­¢
        for {
            select {
            case <-ticker.C:
                // ...
            case <-ctx.Done():
                return
            }
        }
    }()
}
```

---

### 3. Context è¶…æ—¶æ§åˆ¶ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰

```go
func (s *Scheduler) safeRun(name string, timeout time.Duration, task func(ctx context.Context)) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Context
    taskCtx, cancel := context.WithTimeout(s.ctx, timeout)
    defer cancel()

    start := time.Now()
    task(taskCtx)
    duration := time.Since(start)

    // ä»»åŠ¡æ‰§è¡Œå¤ªæ…¢ï¼Œè®°å½•è­¦å‘Š
    if duration > 1*time.Minute {
        log.Printf("è­¦å‘Š: å®šæ—¶ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿: name=%s, duration=%s", name, duration)
    }
}
```

---

### 4. ä»»åŠ¡ä¸­çš„é”™è¯¯å¤„ç†ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰

```go
func (s *Scheduler) cleanupTrash(ctx context.Context) {
    deleted, err := s.db.CleanupOldTrashContext(ctx, 30)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯
        if ctx.Err() == context.DeadlineExceeded {
            log.Printf("æ¸…ç†å›æ”¶ç«™è¶…æ—¶: %v", err)
            return
        }
        if ctx.Err() == context.Canceled {
            log.Printf("æ¸…ç†å›æ”¶ç«™å·²å–æ¶ˆ")
            return
        }
        log.Printf("æ¸…ç†å›æ”¶ç«™å¤±è´¥: %v", err)
        return
    }
    // ...
}
```

---

### 5. é…ç½®åŒ–çš„ä»»åŠ¡é—´éš”

```go
type TaskConfig struct {
    Name     string
    Interval time.Duration
    Timeout  time.Duration
    Task     func(ctx context.Context)
    Enabled  bool
}

func (s *Scheduler) Start(configs []TaskConfig) {
    for _, cfg := range configs {
        if !cfg.Enabled {
            continue
        }
        s.wg.Add(1)
        go s.runTask(cfg.Name, cfg.Interval, cfg.Timeout, cfg.Task)
    }
}

// ä½¿ç”¨
configs := []TaskConfig{
    {Name: "æ¸…ç†å›æ”¶ç«™", Interval: 24 * time.Hour, Timeout: 5 * time.Minute, Task: s.cleanupTrash, Enabled: true},
    {Name: "å‘é€æŠ¥å‘Š", Interval: 7 * 24 * time.Hour, Timeout: 10 * time.Minute, Task: s.sendWeeklyReport, Enabled: false},
}
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

echo "=== 1. å¯åŠ¨æœåŠ¡å™¨ ==="
go run cmd/server/main.go &
SERVER_PID=$!
sleep 3

echo "=== 2. æŸ¥çœ‹å¯åŠ¨æ—¥å¿— ==="
# åº”è¯¥çœ‹åˆ°:
# - "å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨"
# - "å®šæ—¶ä»»åŠ¡å·²æ³¨å†Œ: name=æ£€æŸ¥è¿‡æœŸä»»åŠ¡, interval=1h0m0s, timeout=1m0s"
# - "å®šæ—¶ä»»åŠ¡å·²æ³¨å†Œ: name=æ¸…ç†å›æ”¶ç«™, interval=24h0m0s, timeout=5m0s"
# - "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ" (ç«‹å³æ‰§è¡Œçš„é‚£æ¬¡)

echo "=== 3. åˆ›å»ºæµ‹è¯•æ•°æ® ==="
# åˆ›å»ºä¸€äº›è¿‡æœŸä»»åŠ¡
YESTERDAY=$(date -v-1d +%Y-%m-%dT00:00:00Z)
curl -s -X POST "http://localhost:7789/api/v1/todos" \
  -H "Content-Type: application/json" \
  -d "{\"title\": \"è¿‡æœŸä»»åŠ¡\"}" > /dev/null

# æ‰‹åŠ¨è®¾ç½®ä¸ºè¿‡æœŸ(éœ€è¦ç›´æ¥æ“ä½œæ•°æ®åº“)
# sqlite3 todos.db "UPDATE todos SET due_date='$YESTERDAY' WHERE title='è¿‡æœŸä»»åŠ¡'"

echo "=== 4. ç­‰å¾…å®šæ—¶ä»»åŠ¡æ‰§è¡Œ ==="
# ä¿®æ”¹ Ticker é—´éš”ä¸º 10 ç§’è¿›è¡Œæµ‹è¯•
sleep 15

echo "=== 5. æŸ¥çœ‹å®šæ—¶ä»»åŠ¡æ—¥å¿— ==="
# åº”è¯¥çœ‹åˆ°:
# - "å‘ç°è¿‡æœŸä»»åŠ¡: overdue_count=1, today_count=..."
# - "æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š: total=... pending=..."

echo "=== 6. æµ‹è¯•ä¼˜é›…å…³é—­ ==="
kill -TERM $SERVER_PID

# åº”è¯¥çœ‹åˆ°:
# - "æ”¶åˆ°å…³é—­ä¿¡å·: signal=terminated"
# - "åœæ­¢å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨..."
# - "å®šæ—¶ä»»åŠ¡æ”¶åˆ°åœæ­¢ä¿¡å·: name=..."
# - "æ‰€æœ‰å®šæ—¶ä»»åŠ¡å·²åœæ­¢"
# - "æœåŠ¡å™¨å·²å®Œå…¨åœæ­¢"

wait $SERVER_PID
echo "æœåŠ¡å™¨å·²åœæ­¢"
```

### å•å…ƒæµ‹è¯•

```go
package scheduler

import (
    "context"
    "sync/atomic"
    "testing"
    "time"
)

func TestSchedulerStopsGracefully(t *testing.T) {
    var counter int32

    ctx, cancel := context.WithCancel(context.Background())
    var wg sync.WaitGroup

    wg.Add(1)
    go func() {
        defer wg.Done()
        ticker := time.NewTicker(10 * time.Millisecond)
        defer ticker.Stop()

        for {
            select {
            case <-ticker.C:
                atomic.AddInt32(&counter, 1)
            case <-ctx.Done():
                return
            }
        }
    }()

    // ç­‰å¾…å‡ æ¬¡æ‰§è¡Œ
    time.Sleep(50 * time.Millisecond)

    // åœæ­¢
    cancel()
    wg.Wait()

    // éªŒè¯
    if counter == 0 {
        t.Error("ä»»åŠ¡åº”è¯¥è‡³å°‘æ‰§è¡Œäº†ä¸€æ¬¡")
    }
}

func TestSchedulerRecoverFromPanic(t *testing.T) {
    s := &Scheduler{
        ctx:    context.Background(),
        cancel: func() {},
    }

    // ä¸åº”è¯¥ panic
    s.safeRun("test", time.Minute, func(ctx context.Context) {
        panic("test panic")
    })
}

func TestSchedulerRespectsTimeout(t *testing.T) {
    s := &Scheduler{
        ctx:    context.Background(),
        cancel: func() {},
    }

    var taskCtxCanceled bool
    s.safeRun("test", 50*time.Millisecond, func(ctx context.Context) {
        select {
        case <-time.After(100 * time.Millisecond):
            // åº”è¯¥ä¸ä¼šèµ°åˆ°è¿™é‡Œ
        case <-ctx.Done():
            taskCtxCanceled = true
        }
    })

    if !taskCtxCanceled {
        t.Error("ä»»åŠ¡åº”è¯¥å› è¶…æ—¶è€Œè¢«å–æ¶ˆ")
    }
}
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

**è°ƒåº¦å™¨åŸºç¡€**:
- [ ] `Scheduler` ç»“æ„ä½“å®šä¹‰ï¼ˆåŒ…å« Contextï¼‰
- [ ] `Start()` å¯åŠ¨æ‰€æœ‰ä»»åŠ¡
- [ ] `Stop()` åœæ­¢æ‰€æœ‰ä»»åŠ¡
- [ ] ä½¿ç”¨ `sync.WaitGroup` ç­‰å¾…ä»»åŠ¡å®Œæˆ
- [ ] ä½¿ç”¨ Context å–æ¶ˆæœºåˆ¶ï¼ˆè€Œé channelï¼‰

**ä»»åŠ¡ç®¡ç†**:
- [ ] `runTask()` è¿è¡Œå•ä¸ªä»»åŠ¡ï¼ˆæ”¯æŒè¶…æ—¶å‚æ•°ï¼‰
- [ ] `safeRun()` æ•è· panic + Context è¶…æ—¶
- [ ] å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œä¸€æ¬¡
- [ ] è®°å½•ä»»åŠ¡æ‰§è¡Œæ—¶é—´
- [ ] è¶…æ—¶è­¦å‘Šæ—¥å¿—

**å…·ä½“ä»»åŠ¡**:
- [ ] æ£€æŸ¥è¿‡æœŸä»»åŠ¡(æ¯å°æ—¶) - æ¥å— Context å‚æ•°
- [ ] æ¸…ç†å›æ”¶ç«™(æ¯å¤©) - æ¥å— Context å‚æ•°
- [ ] æ¯æ—¥ç»Ÿè®¡(æ¯å¤©) - æ¥å— Context å‚æ•°

**Context æ”¯æŒ**ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰:
- [ ] ä»»åŠ¡å‡½æ•°ç­¾ååŒ…å« `ctx context.Context` å‚æ•°
- [ ] æ•°æ®åº“å‡½æ•°ä½¿ç”¨ `xxxContext` å‘½ååç¼€
- [ ] ä½¿ç”¨ `ExecContext`ã€`QueryContext` æ›¿ä»£ `Exec`ã€`Query`
- [ ] åŒºåˆ† `context.DeadlineExceeded` å’Œ `context.Canceled`

**ä»£ç è´¨é‡**ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰:
- [ ] æ•°æ®åº“å‡½æ•°ä½¿ç”¨å‘½åè¿”å›å€¼ `(deleted int, err error)`
- [ ] å®šä¹‰è¶…æ—¶å¸¸é‡ï¼ˆå¦‚ `CleanupTimeout`ï¼‰

**é›†æˆ**:
- [ ] åœ¨ `main.go` ä¸­å¯åŠ¨è°ƒåº¦å™¨
- [ ] ä¼˜é›…å…³é—­æ—¶å…ˆåœæ­¢è°ƒåº¦å™¨
- [ ] æ—¥å¿—è®°å½•å®Œæ•´

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: å¦‚ä½•è®¾ç½®å…·ä½“çš„æ‰§è¡Œæ—¶é—´(å¦‚æ¯å¤©å‡Œæ™¨ 3 ç‚¹)?

**ç­”**: è®¡ç®—è·ç¦»ä¸‹æ¬¡æ‰§è¡Œçš„æ—¶é—´
```go
func nextRunAt(hour, minute int) time.Duration {
    now := time.Now()
    next := time.Date(now.Year(), now.Month(), now.Day(), hour, minute, 0, 0, now.Location())
    if now.After(next) {
        next = next.Add(24 * time.Hour)
    }
    return next.Sub(now)
}

// ä½¿ç”¨
time.Sleep(nextRunAt(3, 0))  // ç­‰åˆ°å‡Œæ™¨ 3 ç‚¹
task()
ticker := time.NewTicker(24 * time.Hour)
```

### Q2: å¦‚ä½•é¿å…å¤šå®ä¾‹é‡å¤æ‰§è¡Œ?

**ç­”**: ä½¿ç”¨åˆ†å¸ƒå¼é”
```go
// ä½¿ç”¨ Redis æˆ–æ•°æ®åº“é”
func (s *Scheduler) cleanupTrash(ctx context.Context) {
    if !s.acquireLock(ctx, "cleanup_trash", 10*time.Minute) {
        return  // å…¶ä»–å®ä¾‹æ­£åœ¨æ‰§è¡Œ
    }
    defer s.releaseLock("cleanup_trash")

    // ... æ‰§è¡Œä»»åŠ¡
}
```

### Q3: å¦‚ä½•ç›‘æ§ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€?

**ç­”**: æ·»åŠ  Prometheus æŒ‡æ ‡
```go
var (
    taskExecutions = prometheus.NewCounterVec(
        prometheus.CounterOpts{Name: "scheduler_task_executions_total"},
        []string{"task"},
    )
    taskDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{Name: "scheduler_task_duration_seconds"},
        []string{"task"},
    )
)

func (s *Scheduler) safeRun(name string, timeout time.Duration, task func(ctx context.Context)) {
    start := time.Now()
    // ... æ‰§è¡Œä»»åŠ¡ ...
    taskExecutions.WithLabelValues(name).Inc()
    taskDuration.WithLabelValues(name).Observe(time.Since(start).Seconds())
}
```

### Q4: ä»»åŠ¡å¤±è´¥åæ˜¯å¦é‡è¯•?

**ç­”**: å¯ä»¥æ·»åŠ é‡è¯•é€»è¾‘
```go
func (s *Scheduler) runWithRetry(ctx context.Context, name string, task func(ctx context.Context) error, maxRetries int) {
    for i := 0; i < maxRetries; i++ {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
        select {
        case <-ctx.Done():
            log.Printf("ä»»åŠ¡å·²å–æ¶ˆï¼Œåœæ­¢é‡è¯•: name=%s", name)
            return
        default:
        }

        if err := task(ctx); err == nil {
            return
        }
        log.Printf("ä»»åŠ¡æ‰§è¡Œå¤±è´¥ï¼Œå‡†å¤‡é‡è¯•: name=%s, attempt=%d, max_retries=%d", name, i+1, maxRetries)
        time.Sleep(time.Duration(i+1) * time.Minute)  // æŒ‡æ•°é€€é¿
    }
    log.Printf("ä»»åŠ¡é‡è¯•æ¬¡æ•°ç”¨å°½: name=%s", name)
}
```

---

## ğŸš€ å®ç°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: åˆ›å»º `scheduler/scheduler.go` æ–‡ä»¶
- å®šä¹‰è¶…æ—¶å¸¸é‡
- ä½¿ç”¨ Context å–æ¶ˆæœºåˆ¶

**ç¬¬ 2 æ­¥**: å®ç° `Scheduler` ç»“æ„ä½“å’ŒåŸºæœ¬æ–¹æ³•
- ä»»åŠ¡å‡½æ•°ç­¾ååŒ…å« `ctx context.Context`
- `safeRun` åˆ›å»ºå¸¦è¶…æ—¶çš„ Context

**ç¬¬ 3 æ­¥**: å®ç°å…·ä½“çš„å®šæ—¶ä»»åŠ¡
- æ‰€æœ‰ä»»åŠ¡å‡½æ•°æ¥å— Context å‚æ•°
- åŒºåˆ†è¶…æ—¶/å–æ¶ˆé”™è¯¯

**ç¬¬ 4 æ­¥**: æ·»åŠ æ•°æ®åº“ Context ç‰ˆæœ¬å‡½æ•°
- `CleanupOldTrashContext`
- `GetStatsContext`
- ä½¿ç”¨å‘½åè¿”å›å€¼

**ç¬¬ 5 æ­¥**: åœ¨ `main.go` ä¸­é›†æˆè°ƒåº¦å™¨

**ç¬¬ 6 æ­¥**: æµ‹è¯•ä¼˜é›…å…³é—­å’Œè¶…æ—¶

---

**ä¸æ•™å­¦-5/6/7çš„ä¸€è‡´æ€§**ï¼š
- **Context ä¼ é€’**ï¼šä»»åŠ¡å‡½æ•°æ¥å— `ctx context.Context` å‚æ•°
- **å‡½æ•°å‘½å**ï¼š`xxxContext` åç¼€
- **SQL æ‰§è¡Œ**ï¼š`ExecContext`ã€`QueryContext`
- **å‘½åè¿”å›å€¼**ï¼š`(deleted int, err error)`
- **é”™è¯¯åŒºåˆ†**ï¼š`context.DeadlineExceeded` vs `context.Canceled`
- **è¶…æ—¶å¸¸é‡**ï¼šå®šä¹‰ä¸“ç”¨å¸¸é‡

**ç°åœ¨ï¼Œå¼€å§‹å®ç°åå°å®šæ—¶ä»»åŠ¡å§ï¼è®°ä½ï¼šContext ä¼ é€’ã€goroutine ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€ä¼˜é›…å…³é—­ã€panic æ¢å¤ã€‚** ğŸš€
