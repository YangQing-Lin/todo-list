# æ•™å­¦ Part 10: åå°å®šæ—¶ä»»åŠ¡

> **å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / Go å¹¶å‘ç¼–ç¨‹
> **å‰ç½®è¦æ±‚**: å·²æŒæ¡ goroutine åŸºç¡€ã€Contextã€ä¼˜é›…å…³é—­
> **å­¦ä¹ ç›®æ ‡**: æŒæ¡ `time.Ticker`ã€goroutine ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€å®šæ—¶ä»»åŠ¡è°ƒåº¦
> **æ—¶é—´æŠ•å…¥**: 2-3 å°æ—¶(ç†è§£åŸç† + å®ç° + æµ‹è¯•)

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®é—®é¢˜**:
- å›æ”¶ç«™æ•°æ®å †ç§¯ â†’ 30 å¤©ååº”è¯¥è‡ªåŠ¨æ¸…ç†
- æƒ³çŸ¥é“æœ‰å¤šå°‘è¿‡æœŸä»»åŠ¡ â†’ æ¯å¤©ç»Ÿè®¡ä¸€æ¬¡
- æ•°æ®åº“éœ€è¦å®šæœŸä¼˜åŒ– â†’ æ¯å‘¨æ‰§è¡Œä¸€æ¬¡ VACUUM

**ä¸ºä»€ä¹ˆéœ€è¦å®šæ—¶ä»»åŠ¡?**
- **æ•°æ®æ¸…ç†**: è‡ªåŠ¨æ¸…ç†è¿‡æœŸæ•°æ®
- **ç»Ÿè®¡æŠ¥å‘Š**: å®šæœŸç”Ÿæˆç»Ÿè®¡ä¿¡æ¯
- **å¥åº·æ£€æŸ¥**: å®šæœŸæ£€æµ‹ç³»ç»ŸçŠ¶æ€
- **ç»´æŠ¤ä»»åŠ¡**: æ•°æ®åº“ä¼˜åŒ–ã€æ—¥å¿—è½®è½¬

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**: `time.Ticker` + goroutine + ä¼˜é›…å…³é—­

**é”™è¯¯æ–¹æ³•**(é˜»å¡ä¸»çº¿ç¨‹):
```go
// âŒ ä¼šé˜»å¡æœåŠ¡å™¨å¯åŠ¨
for {
    cleanupTrash()
    time.Sleep(24 * time.Hour)
}
```

**æ­£ç¡®æ–¹æ³•**(åå° goroutine):
```go
// âœ… éé˜»å¡ï¼Œå¯ä»¥ä¼˜é›…å…³é—­
go func() {
    ticker := time.NewTicker(24 * time.Hour)
    for {
        select {
        case <-ticker.C:
            cleanupTrash()
        case <-stopCh:
            ticker.Stop()
            return
        }
    }
}()
```

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£é™©**:
- goroutine æ³„æ¼ â†’ å¿˜è®°å…³é—­ Ticker
- ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿ â†’ ä»»åŠ¡å †ç§¯
- å¹¶å‘è®¿é—®æ•°æ®åº“ â†’ ä¸ HTTP è¯·æ±‚ç«äº‰

âœ… **å®‰å…¨è®¾è®¡**:
- ä½¿ç”¨ channel ä¿¡å·ä¼˜é›…å…³é—­
- ä½¿ç”¨ `sync.WaitGroup` ç­‰å¾…ä»»åŠ¡å®Œæˆ
- ä»»åŠ¡æ‰§è¡Œæ—¶é—´é™åˆ¶

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. time.Ticker vs time.Timer

**`time.Timer`**: ä¸€æ¬¡æ€§å®šæ—¶å™¨
```go
timer := time.NewTimer(5 * time.Second)
<-timer.C  // 5 ç§’åè§¦å‘ä¸€æ¬¡
// éœ€è¦æ‰‹åŠ¨ Reset æ‰èƒ½å†æ¬¡è§¦å‘
```

**`time.Ticker`**: å‘¨æœŸæ€§å®šæ—¶å™¨
```go
ticker := time.NewTicker(5 * time.Second)
for t := range ticker.C {
    // æ¯ 5 ç§’è§¦å‘ä¸€æ¬¡
    fmt.Println("Tick at", t)
}
```

**å¿…é¡»è°ƒç”¨ `Stop()`**:
```go
ticker := time.NewTicker(time.Second)
defer ticker.Stop()  // é˜²æ­¢ goroutine æ³„æ¼
```

---

### 2. goroutine ç”Ÿå‘½å‘¨æœŸç®¡ç†

**é—®é¢˜**: å¦‚ä½•ä¼˜é›…åœ°åœæ­¢åå° goroutine?

**æ–¹æ¡ˆ A: channel ä¿¡å·**
```go
stopCh := make(chan struct{})

go func() {
    ticker := time.NewTicker(time.Hour)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            doWork()
        case <-stopCh:
            return  // æ”¶åˆ°åœæ­¢ä¿¡å·ï¼Œé€€å‡º
        }
    }
}()

// åœæ­¢æ—¶
close(stopCh)
```

**æ–¹æ¡ˆ B: Context å–æ¶ˆ**
```go
ctx, cancel := context.WithCancel(context.Background())

go func() {
    ticker := time.NewTicker(time.Hour)
    defer ticker.Stop()

    for {
        select {
        case <-ticker.C:
            doWork()
        case <-ctx.Done():
            return
        }
    }
}()

// åœæ­¢æ—¶
cancel()
```

---

### 3. sync.WaitGroup ç­‰å¾…å®Œæˆ

**é—®é¢˜**: ä¸»ç¨‹åºé€€å‡ºæ—¶ï¼Œå¦‚ä½•ç¡®ä¿åå°ä»»åŠ¡å·²å®Œæˆ?

```go
var wg sync.WaitGroup

wg.Add(1)
go func() {
    defer wg.Done()
    // ... åå°ä»»åŠ¡
}()

// å…³é—­æ—¶
close(stopCh)
wg.Wait()  // ç­‰å¾…æ‰€æœ‰åå°ä»»åŠ¡é€€å‡º
```

---

### 4. é¿å…ä»»åŠ¡å †ç§¯

**é—®é¢˜**: å¦‚æœä»»åŠ¡æ‰§è¡Œæ—¶é—´ > è°ƒåº¦é—´éš”?

```go
// âŒ å¯èƒ½å †ç§¯
ticker := time.NewTicker(1 * time.Minute)
for range ticker.C {
    heavyTask()  // æ‰§è¡Œ 2 åˆ†é’Ÿ
    // ä¸‹ä¸€ä¸ª tick å·²ç»åœ¨ç­‰å¾…äº†
}

// âœ… ä½¿ç”¨ time.After é¿å…å †ç§¯
for {
    heavyTask()  // å…ˆæ‰§è¡Œ
    time.Sleep(1 * time.Minute)  // å†ç­‰å¾…
}

// âœ… æˆ–è€…æ£€æŸ¥æ˜¯å¦æ­£åœ¨æ‰§è¡Œ
var running int32
for range ticker.C {
    if !atomic.CompareAndSwapInt32(&running, 0, 1) {
        continue  // ä¸Šä¸€æ¬¡è¿˜åœ¨æ‰§è¡Œï¼Œè·³è¿‡
    }
    go func() {
        defer atomic.StoreInt32(&running, 0)
        heavyTask()
    }()
}
```

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: åˆ›å»ºè°ƒåº¦å™¨

åˆ›å»º `scheduler/scheduler.go`:

```go
package scheduler

import (
    "log/slog"
    "sync"
    "time"
    "todo-list/database"
)

// Scheduler å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
type Scheduler struct {
    db     *database.DB
    stopCh chan struct{}
    wg     sync.WaitGroup
}

// New åˆ›å»ºè°ƒåº¦å™¨
func New(db *database.DB) *Scheduler {
    return &Scheduler{
        db:     db,
        stopCh: make(chan struct{}),
    }
}

// Start å¯åŠ¨æ‰€æœ‰å®šæ—¶ä»»åŠ¡
func (s *Scheduler) Start() {
    slog.Info("å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨")

    // ä»»åŠ¡ 1: æ¯å°æ—¶æ£€æŸ¥è¿‡æœŸä»»åŠ¡
    s.wg.Add(1)
    go s.runTask("æ£€æŸ¥è¿‡æœŸä»»åŠ¡", 1*time.Hour, s.checkOverdueTodos)

    // ä»»åŠ¡ 2: æ¯å¤©æ¸…ç†å›æ”¶ç«™(ä¿ç•™ 30 å¤©)
    s.wg.Add(1)
    go s.runTask("æ¸…ç†å›æ”¶ç«™", 24*time.Hour, s.cleanupTrash)

    // ä»»åŠ¡ 3: æ¯å¤©å‡Œæ™¨ç»Ÿè®¡æ•°æ®(ä»…è®°å½•æ—¥å¿—)
    s.wg.Add(1)
    go s.runTask("æ¯æ—¥ç»Ÿè®¡", 24*time.Hour, s.dailyStats)
}

// Stop åœæ­¢æ‰€æœ‰å®šæ—¶ä»»åŠ¡
func (s *Scheduler) Stop() {
    slog.Info("åœæ­¢å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨...")
    close(s.stopCh)
    s.wg.Wait()
    slog.Info("æ‰€æœ‰å®šæ—¶ä»»åŠ¡å·²åœæ­¢")
}

// runTask è¿è¡Œå•ä¸ªå®šæ—¶ä»»åŠ¡
func (s *Scheduler) runTask(name string, interval time.Duration, task func()) {
    defer s.wg.Done()

    ticker := time.NewTicker(interval)
    defer ticker.Stop()

    slog.Info("å®šæ—¶ä»»åŠ¡å·²æ³¨å†Œ",
        "name", name,
        "interval", interval.String(),
    )

    // å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œä¸€æ¬¡
    s.safeRun(name, task)

    for {
        select {
        case <-ticker.C:
            s.safeRun(name, task)
        case <-s.stopCh:
            slog.Debug("å®šæ—¶ä»»åŠ¡æ”¶åˆ°åœæ­¢ä¿¡å·", "name", name)
            return
        }
    }
}

// safeRun å®‰å…¨æ‰§è¡Œä»»åŠ¡(æ•è· panic)
func (s *Scheduler) safeRun(name string, task func()) {
    defer func() {
        if err := recover(); err != nil {
            slog.Error("å®šæ—¶ä»»åŠ¡ panic",
                "name", name,
                "error", err,
            )
        }
    }()

    start := time.Now()
    task()
    slog.Debug("å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ",
        "name", name,
        "duration_ms", time.Since(start).Milliseconds(),
    )
}

// checkOverdueTodos æ£€æŸ¥è¿‡æœŸä»»åŠ¡
func (s *Scheduler) checkOverdueTodos() {
    stats, err := s.db.GetStats()
    if err != nil {
        slog.Error("è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥", "error", err)
        return
    }

    if stats.Overdue > 0 {
        slog.Warn("å‘ç°è¿‡æœŸä»»åŠ¡",
            "overdue_count", stats.Overdue,
            "today_count", stats.Today,
        )
    }
}

// cleanupTrash æ¸…ç†å›æ”¶ç«™(30 å¤©å‰çš„æ•°æ®)
func (s *Scheduler) cleanupTrash() {
    deleted, err := s.db.CleanupOldTrash(30)
    if err != nil {
        slog.Error("æ¸…ç†å›æ”¶ç«™å¤±è´¥", "error", err)
        return
    }

    if deleted > 0 {
        slog.Info("æ¸…ç†å›æ”¶ç«™å®Œæˆ",
            "deleted_count", deleted,
            "retention_days", 30,
        )
    }
}

// dailyStats æ¯æ—¥ç»Ÿè®¡
func (s *Scheduler) dailyStats() {
    stats, err := s.db.GetStats()
    if err != nil {
        slog.Error("è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥", "error", err)
        return
    }

    slog.Info("æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š",
        "total", stats.Total,
        "pending", stats.Pending,
        "completed", stats.Completed,
        "overdue", stats.Overdue,
        "today", stats.Today,
        "this_week", stats.ThisWeek,
    )
}
```

---

### æ­¥éª¤ 2: é›†æˆåˆ° main.go

æ›´æ–° `cmd/server/main.go`:

```go
package main

import (
    "context"
    "log/slog"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
    "todo-list/api"
    "todo-list/database"
    "todo-list/handler"
    "todo-list/scheduler"
)

func main() {
    setupLogger()

    // åˆå§‹åŒ–æ•°æ®åº“
    dbPath := os.Getenv("DB_PATH")
    if dbPath == "" {
        dbPath = "./todos.db"
    }

    db, err := database.New(dbPath)
    if err != nil {
        slog.Error("æ•°æ®åº“åˆå§‹åŒ–å¤±è´¥", "error", err)
        os.Exit(1)
    }

    // åˆ›å»º Handler å’Œè·¯ç”±
    h := handler.NewHandler(db)
    mux := api.SetupRoutes(h)

    // å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨
    sched := scheduler.New(db)
    sched.Start()

    // é…ç½® HTTP æœåŠ¡å™¨
    server := &http.Server{
        Addr:         ":7789",
        Handler:      mux,
        ReadTimeout:  15 * time.Second,
        WriteTimeout: 15 * time.Second,
        IdleTimeout:  60 * time.Second,
    }

    // ä¿¡å·å¤„ç†
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

    // å¯åŠ¨æœåŠ¡å™¨
    go func() {
        slog.Info("æœåŠ¡å™¨å¯åŠ¨", "addr", server.Addr)
        if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            slog.Error("æœåŠ¡å™¨å¯åŠ¨å¤±è´¥", "error", err)
            os.Exit(1)
        }
    }()

    // ç­‰å¾…ä¸­æ–­ä¿¡å·
    sig := <-sigChan
    slog.Info("æ”¶åˆ°å…³é—­ä¿¡å·", "signal", sig.String())

    // ä¼˜é›…å…³é—­
    shutdownCtx, shutdownCancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer shutdownCancel()

    // 1. åœæ­¢å®šæ—¶ä»»åŠ¡
    sched.Stop()

    // 2. åœæ­¢ HTTP æœåŠ¡å™¨
    if err := server.Shutdown(shutdownCtx); err != nil {
        slog.Error("æœåŠ¡å™¨å…³é—­å¤±è´¥", "error", err)
        server.Close()
    } else {
        slog.Info("HTTP æœåŠ¡å™¨å·²å…³é—­")
    }

    // 3. å…³é—­æ•°æ®åº“
    if err := db.Close(); err != nil {
        slog.Error("æ•°æ®åº“å…³é—­å¤±è´¥", "error", err)
    } else {
        slog.Info("æ•°æ®åº“è¿æ¥å·²å…³é—­")
    }

    slog.Info("æœåŠ¡å™¨å·²å®Œå…¨åœæ­¢")
}
```

---

### æ­¥éª¤ 3: æ·»åŠ æ•°æ®åº“æ¸…ç†æ–¹æ³•

åœ¨ `database/db.go` ä¸­æ·»åŠ (å¦‚æœè¿˜æ²¡æœ‰):

```go
// CleanupOldTrash æ¸…ç†è¶…è¿‡æŒ‡å®šå¤©æ•°çš„å›æ”¶ç«™æ•°æ®
func (db *DB) CleanupOldTrash(days int) (int, error) {
    cutoff := time.Now().AddDate(0, 0, -days)

    query := `DELETE FROM todos WHERE deleted_at IS NOT NULL AND deleted_at < ?`

    result, err := db.conn.Exec(query, cutoff)
    if err != nil {
        return 0, fmt.Errorf("æ¸…ç†æ—§æ•°æ®å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return 0, fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    return int(rows), nil
}
```

---

## âš ï¸ å…³é”®ç‚¹è§£æ

### 1. ç«‹å³æ‰§è¡Œ vs ç­‰å¾…ç¬¬ä¸€ä¸ªå‘¨æœŸ

```go
// æ–¹å¼ A: ç­‰å¾…ç¬¬ä¸€ä¸ªå‘¨æœŸ
ticker := time.NewTicker(24 * time.Hour)
for range ticker.C {
    task()  // æ˜å¤©æ‰ä¼šç¬¬ä¸€æ¬¡æ‰§è¡Œ
}

// æ–¹å¼ B: ç«‹å³æ‰§è¡Œä¸€æ¬¡
task()  // å…ˆæ‰§è¡Œ
ticker := time.NewTicker(24 * time.Hour)
for range ticker.C {
    task()
}

// æ–¹å¼ C: ä½¿ç”¨ time.AfterFunc(å»¶è¿Ÿåæ‰§è¡Œä¸€æ¬¡)
time.AfterFunc(0, task)  // ç«‹å³æ‰§è¡Œ
```

**æœ¬é¡¹ç›®é€‰æ‹©æ–¹å¼ B**: å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œä¸€æ¬¡ï¼Œç„¶åæŒ‰å‘¨æœŸæ‰§è¡Œã€‚

---

### 2. é˜²æ­¢ goroutine æ³„æ¼

**é—®é¢˜**: å¿˜è®° `ticker.Stop()`

```go
// âŒ æ³„æ¼
func bad() {
    ticker := time.NewTicker(time.Second)
    go func() {
        for range ticker.C {
            // ...
        }
    }()
    // ticker æ°¸è¿œä¸ä¼šåœæ­¢
}

// âœ… æ­£ç¡®
func good(stopCh chan struct{}) {
    ticker := time.NewTicker(time.Second)
    go func() {
        defer ticker.Stop()  // ç¡®ä¿åœæ­¢
        for {
            select {
            case <-ticker.C:
                // ...
            case <-stopCh:
                return
            }
        }
    }()
}
```

---

### 3. ä»»åŠ¡æ‰§è¡Œæ—¶é—´ç›‘æ§

```go
func (s *Scheduler) safeRun(name string, task func()) {
    start := time.Now()

    defer func() {
        duration := time.Since(start)

        // ä»»åŠ¡æ‰§è¡Œå¤ªæ…¢ï¼Œè®°å½•è­¦å‘Š
        if duration > 1*time.Minute {
            slog.Warn("å®šæ—¶ä»»åŠ¡æ‰§è¡Œæ—¶é—´è¿‡é•¿",
                "name", name,
                "duration", duration.String(),
            )
        }

        if err := recover(); err != nil {
            slog.Error("å®šæ—¶ä»»åŠ¡ panic", "name", name, "error", err)
        }
    }()

    task()
}
```

---

### 4. é…ç½®åŒ–çš„ä»»åŠ¡é—´éš”

```go
type TaskConfig struct {
    Name     string
    Interval time.Duration
    Task     func()
    Enabled  bool
}

func (s *Scheduler) Start(configs []TaskConfig) {
    for _, cfg := range configs {
        if !cfg.Enabled {
            continue
        }
        s.wg.Add(1)
        go s.runTask(cfg.Name, cfg.Interval, cfg.Task)
    }
}

// ä½¿ç”¨
configs := []TaskConfig{
    {Name: "æ¸…ç†å›æ”¶ç«™", Interval: 24 * time.Hour, Task: s.cleanupTrash, Enabled: true},
    {Name: "å‘é€æŠ¥å‘Š", Interval: 7 * 24 * time.Hour, Task: s.sendWeeklyReport, Enabled: false},
}
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

echo "=== 1. å¯åŠ¨æœåŠ¡å™¨ ==="
LOG_LEVEL=debug go run cmd/server/main.go &
SERVER_PID=$!
sleep 3

echo "=== 2. æŸ¥çœ‹å¯åŠ¨æ—¥å¿— ==="
# åº”è¯¥çœ‹åˆ°:
# - "å¯åŠ¨å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨"
# - "å®šæ—¶ä»»åŠ¡å·²æ³¨å†Œ" name=æ£€æŸ¥è¿‡æœŸä»»åŠ¡ interval=1h0m0s
# - "å®šæ—¶ä»»åŠ¡å·²æ³¨å†Œ" name=æ¸…ç†å›æ”¶ç«™ interval=24h0m0s
# - "å®šæ—¶ä»»åŠ¡æ‰§è¡Œå®Œæˆ" (ç«‹å³æ‰§è¡Œçš„é‚£æ¬¡)

echo "=== 3. åˆ›å»ºæµ‹è¯•æ•°æ® ==="
# åˆ›å»ºä¸€äº›è¿‡æœŸä»»åŠ¡
YESTERDAY=$(date -v-1d +%Y-%m-%dT00:00:00Z)
curl -s -X POST "http://localhost:7789/api/v1/todos" \
  -H "Content-Type: application/json" \
  -d "{\"title\": \"è¿‡æœŸä»»åŠ¡\"}" > /dev/null

# æ‰‹åŠ¨è®¾ç½®ä¸ºè¿‡æœŸ(éœ€è¦ç›´æ¥æ“ä½œæ•°æ®åº“)
# sqlite3 todos.db "UPDATE todos SET due_date='$YESTERDAY' WHERE title='è¿‡æœŸä»»åŠ¡'"

echo "=== 4. ç­‰å¾…å®šæ—¶ä»»åŠ¡æ‰§è¡Œ ==="
# ä¿®æ”¹ Ticker é—´éš”ä¸º 10 ç§’è¿›è¡Œæµ‹è¯•
sleep 15

echo "=== 5. æŸ¥çœ‹å®šæ—¶ä»»åŠ¡æ—¥å¿— ==="
# åº”è¯¥çœ‹åˆ°:
# - "å‘ç°è¿‡æœŸä»»åŠ¡" overdue_count=1
# - "æ¯æ—¥ç»Ÿè®¡æŠ¥å‘Š" total=... pending=...

echo "=== 6. æµ‹è¯•ä¼˜é›…å…³é—­ ==="
kill -TERM $SERVER_PID

# åº”è¯¥çœ‹åˆ°:
# - "æ”¶åˆ°å…³é—­ä¿¡å·" signal=terminated
# - "åœæ­¢å®šæ—¶ä»»åŠ¡è°ƒåº¦å™¨..."
# - "å®šæ—¶ä»»åŠ¡æ”¶åˆ°åœæ­¢ä¿¡å·" name=...
# - "æ‰€æœ‰å®šæ—¶ä»»åŠ¡å·²åœæ­¢"
# - "æœåŠ¡å™¨å·²å®Œå…¨åœæ­¢"

wait $SERVER_PID
echo "æœåŠ¡å™¨å·²åœæ­¢"
```

### å•å…ƒæµ‹è¯•

```go
package scheduler

import (
    "sync/atomic"
    "testing"
    "time"
)

func TestSchedulerStopsGracefully(t *testing.T) {
    var counter int32

    s := &Scheduler{
        stopCh: make(chan struct{}),
    }

    s.wg.Add(1)
    go func() {
        defer s.wg.Done()
        ticker := time.NewTicker(10 * time.Millisecond)
        defer ticker.Stop()

        for {
            select {
            case <-ticker.C:
                atomic.AddInt32(&counter, 1)
            case <-s.stopCh:
                return
            }
        }
    }()

    // ç­‰å¾…å‡ æ¬¡æ‰§è¡Œ
    time.Sleep(50 * time.Millisecond)

    // åœæ­¢
    s.Stop()

    // éªŒè¯
    if counter == 0 {
        t.Error("ä»»åŠ¡åº”è¯¥è‡³å°‘æ‰§è¡Œäº†ä¸€æ¬¡")
    }
}

func TestSchedulerRecoverFromPanic(t *testing.T) {
    s := &Scheduler{
        stopCh: make(chan struct{}),
    }

    // ä¸åº”è¯¥ panic
    s.safeRun("test", func() {
        panic("test panic")
    })
}
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

**è°ƒåº¦å™¨åŸºç¡€**:
- [ ] `Scheduler` ç»“æ„ä½“å®šä¹‰
- [ ] `Start()` å¯åŠ¨æ‰€æœ‰ä»»åŠ¡
- [ ] `Stop()` åœæ­¢æ‰€æœ‰ä»»åŠ¡
- [ ] ä½¿ç”¨ `sync.WaitGroup` ç­‰å¾…ä»»åŠ¡å®Œæˆ
- [ ] ä½¿ç”¨ channel ä¿¡å·é€šçŸ¥åœæ­¢

**ä»»åŠ¡ç®¡ç†**:
- [ ] `runTask()` è¿è¡Œå•ä¸ªä»»åŠ¡
- [ ] `safeRun()` æ•è· panic
- [ ] å¯åŠ¨æ—¶ç«‹å³æ‰§è¡Œä¸€æ¬¡
- [ ] è®°å½•ä»»åŠ¡æ‰§è¡Œæ—¶é—´

**å…·ä½“ä»»åŠ¡**:
- [ ] æ£€æŸ¥è¿‡æœŸä»»åŠ¡(æ¯å°æ—¶)
- [ ] æ¸…ç†å›æ”¶ç«™(æ¯å¤©)
- [ ] æ¯æ—¥ç»Ÿè®¡(æ¯å¤©)

**é›†æˆ**:
- [ ] åœ¨ `main.go` ä¸­å¯åŠ¨è°ƒåº¦å™¨
- [ ] ä¼˜é›…å…³é—­æ—¶å…ˆåœæ­¢è°ƒåº¦å™¨
- [ ] æ—¥å¿—è®°å½•å®Œæ•´

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: å¦‚ä½•è®¾ç½®å…·ä½“çš„æ‰§è¡Œæ—¶é—´(å¦‚æ¯å¤©å‡Œæ™¨ 3 ç‚¹)?

**ç­”**: è®¡ç®—è·ç¦»ä¸‹æ¬¡æ‰§è¡Œçš„æ—¶é—´
```go
func nextRunAt(hour, minute int) time.Duration {
    now := time.Now()
    next := time.Date(now.Year(), now.Month(), now.Day(), hour, minute, 0, 0, now.Location())
    if now.After(next) {
        next = next.Add(24 * time.Hour)
    }
    return next.Sub(now)
}

// ä½¿ç”¨
time.Sleep(nextRunAt(3, 0))  // ç­‰åˆ°å‡Œæ™¨ 3 ç‚¹
task()
ticker := time.NewTicker(24 * time.Hour)
```

### Q2: å¦‚ä½•é¿å…å¤šå®ä¾‹é‡å¤æ‰§è¡Œ?

**ç­”**: ä½¿ç”¨åˆ†å¸ƒå¼é”
```go
// ä½¿ç”¨ Redis æˆ–æ•°æ®åº“é”
func (s *Scheduler) cleanupTrash() {
    if !s.acquireLock("cleanup_trash", 10*time.Minute) {
        return  // å…¶ä»–å®ä¾‹æ­£åœ¨æ‰§è¡Œ
    }
    defer s.releaseLock("cleanup_trash")

    // ... æ‰§è¡Œä»»åŠ¡
}
```

### Q3: å¦‚ä½•ç›‘æ§ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€?

**ç­”**: æ·»åŠ  Prometheus æŒ‡æ ‡
```go
var (
    taskExecutions = prometheus.NewCounterVec(
        prometheus.CounterOpts{Name: "scheduler_task_executions_total"},
        []string{"task"},
    )
    taskDuration = prometheus.NewHistogramVec(
        prometheus.HistogramOpts{Name: "scheduler_task_duration_seconds"},
        []string{"task"},
    )
)

func (s *Scheduler) safeRun(name string, task func()) {
    start := time.Now()
    task()
    taskExecutions.WithLabelValues(name).Inc()
    taskDuration.WithLabelValues(name).Observe(time.Since(start).Seconds())
}
```

### Q4: ä»»åŠ¡å¤±è´¥åæ˜¯å¦é‡è¯•?

**ç­”**: å¯ä»¥æ·»åŠ é‡è¯•é€»è¾‘
```go
func (s *Scheduler) runWithRetry(name string, task func() error, maxRetries int) {
    for i := 0; i < maxRetries; i++ {
        if err := task(); err == nil {
            return
        }
        slog.Warn("ä»»åŠ¡æ‰§è¡Œå¤±è´¥ï¼Œå‡†å¤‡é‡è¯•",
            "name", name,
            "attempt", i+1,
            "max_retries", maxRetries,
        )
        time.Sleep(time.Duration(i+1) * time.Minute)  // æŒ‡æ•°é€€é¿
    }
    slog.Error("ä»»åŠ¡é‡è¯•æ¬¡æ•°ç”¨å°½", "name", name)
}
```

---

## ğŸš€ å®ç°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: åˆ›å»º `scheduler/scheduler.go` æ–‡ä»¶

**ç¬¬ 2 æ­¥**: å®ç° `Scheduler` ç»“æ„ä½“å’ŒåŸºæœ¬æ–¹æ³•

**ç¬¬ 3 æ­¥**: å®ç°å…·ä½“çš„å®šæ—¶ä»»åŠ¡

**ç¬¬ 4 æ­¥**: åœ¨ `main.go` ä¸­é›†æˆè°ƒåº¦å™¨

**ç¬¬ 5 æ­¥**: æµ‹è¯•ä¼˜é›…å…³é—­

**ç¬¬ 6 æ­¥**: è°ƒæ•´ä»»åŠ¡é—´éš”è¿›è¡ŒéªŒè¯

---

**ç°åœ¨ï¼Œå¼€å§‹å®ç°åå°å®šæ—¶ä»»åŠ¡å§ï¼è®°ä½ï¼šgoroutine ç”Ÿå‘½å‘¨æœŸç®¡ç†ã€ä¼˜é›…å…³é—­ã€panic æ¢å¤ã€‚** ğŸš€
