# æ•™å­¦ Part 12: ç®€å•ç¼“å­˜å±‚

> **ğŸ“Œ å­¦ä¹ é˜¶æ®µ**: ä¸­çº§è¿›é˜¶ / æ€§èƒ½ä¼˜åŒ–
> **å‰ç½®è¦æ±‚**: å·²å®Œæˆæ•™å­¦-11ï¼ˆå­ä»»åŠ¡æ£€æŸ¥æ¸…å•ï¼‰ã€æŒæ¡ Go å¹¶å‘åŸºç¡€ã€sync åŒ…
> **å­¦ä¹ ç›®æ ‡**: ç†è§£ç¼“å­˜ç­–ç•¥ã€æŒæ¡ `sync.Map` å’Œ `sync.RWMutex`ã€å®ç° TTL ç¼“å­˜
> **æ—¶é—´æŠ•å…¥**: 2-3 å°æ—¶ï¼ˆç†è§£åŸç† + å®ç° + æµ‹è¯•ï¼‰

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„ï¼Ÿ"**

âœ… **çœŸå®é—®é¢˜**ï¼š
- ç»Ÿè®¡ä¿¡æ¯ API æ¯æ¬¡éƒ½è¦æ‰«æå…¨è¡¨ â†’ å“åº”æ…¢
- åŒä¸€æ•°æ®è¢«é¢‘ç¹è¯·æ±‚ â†’ æ•°æ®åº“å‹åŠ›å¤§
- é¦–é¡µåŠ è½½æ…¢ â†’ ç”¨æˆ·ä½“éªŒå·®

**çœŸå®åœºæ™¯**ï¼š
```
ç”¨æˆ· A: GET /api/v1/todos/stats  â†’ æŸ¥è¯¢æ•°æ®åº“ 50ms
ç”¨æˆ· B: GET /api/v1/todos/stats  â†’ å†æ¬¡æŸ¥è¯¢æ•°æ®åº“ 50ms
ç”¨æˆ· C: GET /api/v1/todos/stats  â†’ å†æ¬¡æŸ¥è¯¢æ•°æ®åº“ 50ms
...
ä¸€åˆ†é’Ÿå†… 100 æ¬¡è¯·æ±‚ â†’ 100 æ¬¡æ•°æ®åº“æŸ¥è¯¢
```

**åŠ å…¥ç¼“å­˜å**ï¼š
```
ç”¨æˆ· A: GET /api/v1/todos/stats  â†’ æŸ¥è¯¢æ•°æ®åº“ 50ms â†’ ç¼“å­˜ç»“æœ
ç”¨æˆ· B: GET /api/v1/todos/stats  â†’ å‘½ä¸­ç¼“å­˜ 0.1ms
ç”¨æˆ· C: GET /api/v1/todos/stats  â†’ å‘½ä¸­ç¼“å­˜ 0.1ms
...
ä¸€åˆ†é’Ÿå†… 100 æ¬¡è¯·æ±‚ â†’ 1 æ¬¡æ•°æ®åº“æŸ¥è¯¢ + 99 æ¬¡ç¼“å­˜å‘½ä¸­
```

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—ï¼Ÿ"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**ï¼šå†…å­˜ç¼“å­˜ + TTL è¿‡æœŸ

**ä¸éœ€è¦ Redis**ï¼šå•æœºåº”ç”¨ç”¨å†…å­˜ç¼“å­˜å°±å¤Ÿäº†

```go
// ç®€å•çš„ç¼“å­˜ç»“æ„
type Cache struct {
    data sync.Map
}

type cacheEntry struct {
    value     interface{}
    expiredAt time.Time
}
```

**3. "ä¼šç ´åä»€ä¹ˆå—ï¼Ÿ"**

âš ï¸ **æ½œåœ¨é£é™©**ï¼š
- ç¼“å­˜æ•°æ®è¿‡æœŸ â†’ ç”¨æˆ·çœ‹åˆ°æ—§æ•°æ®
- å†…å­˜æ³„æ¼ â†’ ç¼“å­˜æ•°æ®ä¸æ¸…ç†
- å¹¶å‘é—®é¢˜ â†’ æ•°æ®ç«äº‰

âœ… **å®‰å…¨è®¾è®¡**ï¼š
- TTL è¿‡æœŸæœºåˆ¶
- å†™å…¥æ—¶å¤±æ•ˆç­–ç•¥
- ä½¿ç”¨ `sync.Map` ä¿è¯å¹¶å‘å®‰å…¨
- å®šæœŸæ¸…ç†è¿‡æœŸç¼“å­˜

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. ç¼“å­˜çš„åŸºæœ¬æ¦‚å¿µ

**ç¼“å­˜å‘½ä¸­ (Cache Hit)**ï¼šæ•°æ®åœ¨ç¼“å­˜ä¸­ï¼Œç›´æ¥è¿”å›
**ç¼“å­˜æœªå‘½ä¸­ (Cache Miss)**ï¼šæ•°æ®ä¸åœ¨ç¼“å­˜ä¸­ï¼Œéœ€è¦æŸ¥è¯¢æ•°æ®æº

**å…³é”®æŒ‡æ ‡**ï¼š
- **å‘½ä¸­ç‡**ï¼šå‘½ä¸­æ¬¡æ•° / æ€»è¯·æ±‚æ¬¡æ•°
- **TTL (Time To Live)**ï¼šç¼“å­˜æ•°æ®çš„å­˜æ´»æ—¶é—´

---

### 2. Go çš„å¹¶å‘å®‰å…¨ Map

**æ™®é€š map ä¸æ˜¯å¹¶å‘å®‰å…¨çš„**ï¼š
```go
// âŒ ä¼š panic: concurrent map writes
m := make(map[string]int)
go func() { m["a"] = 1 }()
go func() { m["b"] = 2 }()
```

**æ–¹æ¡ˆ A: sync.RWMutex**
```go
type Cache struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    v, ok := c.data[key]
    return v, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[key] = value
}
```

**æ–¹æ¡ˆ B: sync.Map**ï¼ˆæ¨èç”¨äºè¯»å¤šå†™å°‘åœºæ™¯ï¼‰
```go
var cache sync.Map

// å­˜å‚¨
cache.Store("key", value)

// è¯»å–
if v, ok := cache.Load("key"); ok {
    // ä½¿ç”¨ v
}

// åˆ é™¤
cache.Delete("key")
```

**sync.Map çš„ä¼˜åŠ¿**ï¼š
- æ— é”è¯»å–ï¼ˆè¯»å¤šå†™å°‘æ—¶æ€§èƒ½å¥½ï¼‰
- è‡ªåŠ¨å¤„ç†å¹¶å‘
- ä¸éœ€è¦åˆå§‹åŒ–

---

### 3. TTL å®ç°ç­–ç•¥

**ç­–ç•¥ Aï¼šæƒ°æ€§åˆ é™¤**ï¼ˆæ¨èï¼‰
- è¯»å–æ—¶æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
- è¿‡æœŸåˆ™åˆ é™¤å¹¶è¿”å›æœªå‘½ä¸­
- ä¼˜ç‚¹ï¼šç®€å•ï¼Œæ— åå° goroutine

**ç­–ç•¥ Bï¼šå®šæœŸæ¸…ç†**
- åå° goroutine å®šæœŸæ‰«æè¿‡æœŸæ•°æ®
- ä¼˜ç‚¹ï¼šå†…å­˜åŠæ—¶é‡Šæ”¾
- ç¼ºç‚¹ï¼šå¢åŠ å¤æ‚åº¦

**ç­–ç•¥ Cï¼šæƒ°æ€§ + å®šæœŸ**
- è¯»å–æ—¶æ£€æŸ¥ + å®šæœŸæ¸…ç†
- æœ€ä½³å®è·µï¼Œä½†å¤æ‚åº¦æœ€é«˜

---

### 4. ç¼“å­˜å¤±æ•ˆç­–ç•¥

**å†™å…¥æ—¶å¤±æ•ˆ (Write-Through)**ï¼š
```go
func (h *Handler) CreateTodo(...) {
    // å†™å…¥æ•°æ®åº“
    h.db.CreateTodo(todo)
    // ç«‹å³å¤±æ•ˆç›¸å…³ç¼“å­˜
    h.cache.Delete("stats")
    h.cache.Delete("todos_list")
}
```

**å¸¸è§ç¼“å­˜é—®é¢˜**ï¼š

| é—®é¢˜ | æè¿° | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| ç¼“å­˜ç©¿é€ | æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ® | ç¼“å­˜ç©ºç»“æœ |
| ç¼“å­˜å‡»ç©¿ | çƒ­ç‚¹æ•°æ®è¿‡æœŸç¬é—´å¤§é‡è¯·æ±‚ | åŠ é”æˆ–æ°¸ä¸è¿‡æœŸ |
| ç¼“å­˜é›ªå´© | å¤§é‡ç¼“å­˜åŒæ—¶è¿‡æœŸ | éšæœº TTL |

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ–‡ä»¶ 1: `cache/cache.go` - åŸºç¡€ç¼“å­˜æ¨¡å—

> **æ³¨æ„**ï¼šåˆ›å»ºæ–°çš„ `cache` åŒ…ï¼Œä¸ç°æœ‰ä»£ç è§£è€¦ã€‚

```go
package cache

import (
    "sync"
    "time"
)

// Cache ç®€å•çš„å†…å­˜ç¼“å­˜
type Cache struct {
    data sync.Map
}

// cacheEntry ç¼“å­˜æ¡ç›®
type cacheEntry struct {
    value     interface{}
    expiredAt time.Time
}

// New åˆ›å»ºç¼“å­˜å®ä¾‹
func New() *Cache {
    return &Cache{}
}

// Get è·å–ç¼“å­˜å€¼
func (c *Cache) Get(key string) (interface{}, bool) {
    entry, ok := c.data.Load(key)
    if !ok {
        return nil, false
    }

    e := entry.(*cacheEntry)

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if time.Now().After(e.expiredAt) {
        c.data.Delete(key)  // æƒ°æ€§åˆ é™¤
        return nil, false
    }

    return e.value, true
}

// Set è®¾ç½®ç¼“å­˜å€¼
func (c *Cache) Set(key string, value interface{}, ttl time.Duration) {
    c.data.Store(key, &cacheEntry{
        value:     value,
        expiredAt: time.Now().Add(ttl),
    })
}

// Delete åˆ é™¤ç¼“å­˜
func (c *Cache) Delete(key string) {
    c.data.Delete(key)
}

// DeleteByPrefix åˆ é™¤æŒ‡å®šå‰ç¼€çš„æ‰€æœ‰ç¼“å­˜
func (c *Cache) DeleteByPrefix(prefix string) {
    c.data.Range(func(key, value interface{}) bool {
        k := key.(string)
        if len(k) >= len(prefix) && k[:len(prefix)] == prefix {
            c.data.Delete(key)
        }
        return true
    })
}

// Clear æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
func (c *Cache) Clear() {
    c.data.Range(func(key, value interface{}) bool {
        c.data.Delete(key)
        return true
    })
}

// CacheStats ç¼“å­˜ç»Ÿè®¡
type CacheStats struct {
    Count   int `json:"count"`
    Expired int `json:"expired"`
}

func (c *Cache) Stats() CacheStats {
    var stats CacheStats
    now := time.Now()

    c.data.Range(func(key, value interface{}) bool {
        stats.Count++
        e := value.(*cacheEntry)
        if now.After(e.expiredAt) {
            stats.Expired++
        }
        return true
    })

    return stats
}

// Cleanup æ¸…ç†è¿‡æœŸç¼“å­˜ï¼ˆå¯é€‰ï¼Œç”¨äºåå°å®šæœŸæ¸…ç†ï¼‰
func (c *Cache) Cleanup() int {
    var deleted int
    now := time.Now()

    c.data.Range(func(key, value interface{}) bool {
        e := value.(*cacheEntry)
        if now.After(e.expiredAt) {
            c.data.Delete(key)
            deleted++
        }
        return true
    })

    return deleted
}
```

---

### æ–‡ä»¶ 2: `cache/monitored_cache.go` - å¸¦ç›‘æ§çš„ç¼“å­˜åŒ…è£…å™¨

```go
package cache

import (
    "log"
    "sync/atomic"
    "time"
)

// MonitoredCache å¸¦ç›‘æ§çš„ç¼“å­˜
type MonitoredCache struct {
    *Cache
    hits   uint64
    misses uint64
}

// NewMonitored åˆ›å»ºå¸¦ç›‘æ§çš„ç¼“å­˜
func NewMonitored() *MonitoredCache {
    return &MonitoredCache{
        Cache: New(),
    }
}

// Get è·å–ç¼“å­˜ï¼ˆå¸¦ç»Ÿè®¡ï¼‰
func (c *MonitoredCache) Get(key string) (interface{}, bool) {
    value, ok := c.Cache.Get(key)
    if ok {
        atomic.AddUint64(&c.hits, 1)
    } else {
        atomic.AddUint64(&c.misses, 1)
    }
    return value, ok
}

// HitRate è·å–å‘½ä¸­ç‡
func (c *MonitoredCache) HitRate() float64 {
    hits := atomic.LoadUint64(&c.hits)
    misses := atomic.LoadUint64(&c.misses)
    total := hits + misses
    if total == 0 {
        return 0
    }
    return float64(hits) / float64(total) * 100
}

// CacheMetrics ç¼“å­˜æŒ‡æ ‡
type CacheMetrics struct {
    Hits    uint64  `json:"hits"`
    Misses  uint64  `json:"misses"`
    HitRate float64 `json:"hit_rate"`
    Count   int     `json:"count"`
}

func (c *MonitoredCache) Metrics() CacheMetrics {
    hits := atomic.LoadUint64(&c.hits)
    misses := atomic.LoadUint64(&c.misses)
    stats := c.Cache.Stats()

    var hitRate float64
    if total := hits + misses; total > 0 {
        hitRate = float64(hits) / float64(total) * 100
    }

    return CacheMetrics{
        Hits:    hits,
        Misses:  misses,
        HitRate: hitRate,
        Count:   stats.Count,
    }
}

// ResetMetrics é‡ç½®ç»Ÿè®¡
func (c *MonitoredCache) ResetMetrics() {
    atomic.StoreUint64(&c.hits, 0)
    atomic.StoreUint64(&c.misses, 0)
}

// LogMetrics è®°å½•ç¼“å­˜æŒ‡æ ‡åˆ°æ—¥å¿—
func (c *MonitoredCache) LogMetrics() {
    m := c.Metrics()
    log.Printf("ç¼“å­˜æŒ‡æ ‡: hits=%d, misses=%d, hit_rate=%.2f%%, count=%d",
        m.Hits, m.Misses, m.HitRate, m.Count)
}
```

---

### æ–‡ä»¶ 3: `handler/handler.go` - é›†æˆç¼“å­˜ï¼ˆå¢é‡ä¿®æ”¹ï¼‰

> **æ³¨æ„**ï¼šä»¥ä¸‹æ˜¯å¢é‡ä¿®æ”¹ï¼Œéœ€è¦ä¸ç°æœ‰ä»£ç åˆå¹¶ã€‚
> Handler ç¤ºä¾‹ä½¿ç”¨ `context.WithTimeout` ä¿æŒä¸é¡¹ç›®ç°æœ‰é£æ ¼ä¸€è‡´ã€‚

**ç¬¬ 1 æ­¥**ï¼šä¿®æ”¹ Handler ç»“æ„ä½“

```go
import (
    "context"
    // ... å…¶ä»– import
    "todo-list/cache"
)

// ç¼“å­˜ Key å¸¸é‡
const (
    CacheKeyStats     = "stats"
    CacheKeyTodosList = "todos:list"
    CacheTTLStats     = 1 * time.Minute  // ç»Ÿè®¡ä¿¡æ¯ç¼“å­˜ 1 åˆ†é’Ÿ
    CacheTTLTodosList = 30 * time.Second // åˆ—è¡¨ç¼“å­˜ 30 ç§’
)

// Handler å¤„ç†å™¨ç»“æ„ä½“
type Handler struct {
    db    *database.DB
    cache *cache.MonitoredCache
}

// NewHandler åˆ›å»ºæ–°çš„å¤„ç†å™¨
func NewHandler(db *database.DB) *Handler {
    return &Handler{
        db:    db,
        cache: cache.NewMonitored(),
    }
}
```

**ç¬¬ 2 æ­¥**ï¼šä¿®æ”¹ GetStats æ–¹æ³•ï¼ˆå¸¦ç¼“å­˜ + Context æ”¯æŒï¼‰

```go
// GetStats è·å–ç»Ÿè®¡ä¿¡æ¯ï¼ˆå¸¦ç¼“å­˜ï¼‰
func (h *Handler) GetStats(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Contextï¼ˆä¸é¡¹ç›®ç°æœ‰é£æ ¼ä¸€è‡´ï¼‰
    ctx, cancel := context.WithTimeout(r.Context(), StatsTimeout)
    defer cancel()

    // 1. å…ˆæŸ¥ç¼“å­˜
    if cached, ok := h.cache.Get(CacheKeyStats); ok {
        log.Printf("ç¼“å­˜å‘½ä¸­: key=%s", CacheKeyStats)
        h.sendJSON(w, http.StatusOK, Response{
            Success: true,
            Data:    cached,
            Message: "è·å–ç»Ÿè®¡ä¿¡æ¯æˆåŠŸ(ç¼“å­˜)",
        })
        return
    }

    // 2. ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
    log.Printf("ç¼“å­˜æœªå‘½ä¸­: key=%s", CacheKeyStats)
    stats, err := h.db.GetStatsContext(ctx)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸é¡¹ç›®ç°æœ‰é£æ ¼ä¸€è‡´ï¼‰
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("GetStats timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è·å–ç»Ÿè®¡ä¿¡æ¯è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("GetStats canceled: %v", err)
            return // å®¢æˆ·ç«¯å–æ¶ˆï¼Œä¸å“åº”
        }
        h.sendError(w, http.StatusInternalServerError, "GET_STATS_ERROR", "è·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥")
        return
    }

    // 3. å†™å…¥ç¼“å­˜
    h.cache.Set(CacheKeyStats, stats, CacheTTLStats)

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    stats,
        Message: "è·å–ç»Ÿè®¡ä¿¡æ¯æˆåŠŸ",
    })
}
```

**ç¬¬ 3 æ­¥**ï¼šæ·»åŠ ç¼“å­˜å¤±æ•ˆæ–¹æ³•

```go
// InvalidateCache ä½¿ç¼“å­˜å¤±æ•ˆï¼ˆå†™æ“ä½œåè°ƒç”¨ï¼‰
func (h *Handler) InvalidateCache() {
    h.cache.Delete(CacheKeyStats)
    h.cache.DeleteByPrefix("todos:")
    log.Printf("ç¼“å­˜å·²å¤±æ•ˆ")
}
```

**ç¬¬ 4 æ­¥**ï¼šåœ¨å†™æ“ä½œåè°ƒç”¨ç¼“å­˜å¤±æ•ˆ

```go
// CreateTodo åˆ›å»ºå¾…åŠäº‹é¡¹
func (h *Handler) CreateTodo(w http.ResponseWriter, r *http.Request) {
    // ... åŸæœ‰é€»è¾‘ ...

    if err := h.db.CreateTodo(todo); err != nil {
        // ...
    }

    // åˆ›å»ºæˆåŠŸåå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›å“åº” ...
}

// UpdateTodo æ›´æ–°å¾…åŠäº‹é¡¹
func (h *Handler) UpdateTodo(w http.ResponseWriter, r *http.Request) {
    // ... åŸæœ‰é€»è¾‘ ...

    // æ›´æ–°æˆåŠŸåå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›å“åº” ...
}

// DeleteTodo åˆ é™¤å¾…åŠäº‹é¡¹
func (h *Handler) DeleteTodo(w http.ResponseWriter, r *http.Request) {
    // ... åŸæœ‰é€»è¾‘ ...

    // åˆ é™¤æˆåŠŸåå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›å“åº” ...
}

// æ‰¹é‡æ“ä½œä¹Ÿéœ€è¦å¤±æ•ˆç¼“å­˜
func (h *Handler) BatchCompleteTodosPartial(w http.ResponseWriter, r *http.Request) {
    // ... åŸæœ‰é€»è¾‘ ...

    // æ‰¹é‡æ“ä½œæˆåŠŸåå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›å“åº” ...
}

func (h *Handler) BatchDeleteTodosPartial(w http.ResponseWriter, r *http.Request) {
    // ... åŸæœ‰é€»è¾‘ ...

    // æ‰¹é‡æ“ä½œæˆåŠŸåå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›å“åº” ...
}
```

**ç¬¬ 5 æ­¥**ï¼šæ·»åŠ ç¼“å­˜æŒ‡æ ‡æ¥å£

```go
// GetCacheMetrics è·å–ç¼“å­˜æŒ‡æ ‡ï¼ˆè°ƒè¯•ç”¨ï¼‰
func (h *Handler) GetCacheMetrics(w http.ResponseWriter, r *http.Request) {
    metrics := h.cache.Metrics()

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    metrics,
        Message: "è·å–ç¼“å­˜æŒ‡æ ‡æˆåŠŸ",
    })
}
```

---

### æ–‡ä»¶ 4: `database/db.go` - æ·»åŠ å¸¦ Context çš„ GetStats æ–¹æ³•

> **æ³¨æ„**ï¼šå¦‚æœ `GetStats` æ–¹æ³•ä¸å­˜åœ¨æˆ–ä¸æ”¯æŒ Contextï¼Œéœ€è¦æ·»åŠ ã€‚
> å‘½åéµå¾ªé¡¹ç›®ç°æœ‰é£æ ¼ï¼š`GetStatsContext`ã€‚

```go
// GetStatsContext è·å–ç»Ÿè®¡ä¿¡æ¯ï¼ˆå¸¦ Context æ”¯æŒï¼‰
func (db *DB) GetStatsContext(ctx context.Context) (*TodoStats, error) {
    query := `
        SELECT
            COUNT(*) as total,
            SUM(CASE WHEN status = 'pending' THEN 1 ELSE 0 END) as pending,
            SUM(CASE WHEN status = 'completed' THEN 1 ELSE 0 END) as completed
        FROM todos
        WHERE deleted_at IS NULL
    `

    var stats TodoStats
    err := db.conn.QueryRowContext(ctx, query).Scan(
        &stats.Total,
        &stats.Pending,
        &stats.Completed,
    )
    if err != nil {
        return nil, fmt.Errorf("failed to get stats: %w", err)
    }

    return &stats, nil
}

// TodoStats ç»Ÿè®¡ç»“æ„ä½“ï¼ˆå¦‚æœä¸å­˜åœ¨éœ€è¦æ·»åŠ ï¼‰
type TodoStats struct {
    Total     int `json:"total"`
    Pending   int `json:"pending"`
    Completed int `json:"completed"`
}
```

---

### æ–‡ä»¶ 5: `api/routes.go` - æ³¨å†Œç¼“å­˜æŒ‡æ ‡è·¯ç”±

> **æ³¨æ„**ï¼šåŒæ—¶æ”¯æŒ `/api/v1/` å’Œ `/api/` è·¯å¾„ï¼ˆä¸é¡¹ç›®ç°æœ‰é£æ ¼ä¸€è‡´ï¼‰ã€‚

```go
registerTodoRoutes := func(base string) {
    // ... ç°æœ‰è·¯ç”± ...

    // ç¼“å­˜æŒ‡æ ‡ï¼ˆè°ƒè¯•ç”¨ï¼Œç”Ÿäº§ç¯å¢ƒå¯ä»¥å…³é—­ï¼‰
    mux.HandleFunc("GET "+base+"/cache/metrics", withMiddlewares(h.GetCacheMetrics))
    mux.HandleFunc("OPTIONS "+base+"/cache/metrics", withMiddlewares(optionsHandler))
}

// æ³¨å†Œè·¯ç”±ï¼ˆåŒæ—¶æ”¯æŒ /api/v1 å’Œ /apiï¼‰
registerTodoRoutes("/api/v1/todos")
registerTodoRoutes("/api/todos")
```

---

## âš ï¸ å…³é”®ç‚¹è§£æ

### 1. ç¼“å­˜ç²’åº¦é€‰æ‹©

**ç²—ç²’åº¦**ï¼šæ•´ä¸ªåˆ—è¡¨ç¼“å­˜
```go
// ä»»ä½•æ•°æ®å˜åŒ–éƒ½è¦å¤±æ•ˆæ•´ä¸ªç¼“å­˜
cache.Delete("todos_list")
```

**ç»†ç²’åº¦**ï¼šå•ä¸ªæ•°æ®ç¼“å­˜
```go
// åªå¤±æ•ˆå˜åŒ–çš„æ•°æ®
cache.Delete(fmt.Sprintf("todo:%d", todoID))
```

**æ¨è**ï¼šç»Ÿè®¡ä¿¡æ¯ç”¨ç²—ç²’åº¦ï¼Œå•ä¸ª Todo æŸ¥è¯¢ç”¨ç»†ç²’åº¦

---

### 2. ç¼“å­˜ç©ºç»“æœï¼ˆé˜²æ­¢ç¼“å­˜ç©¿é€ï¼‰

```go
func (h *Handler) GetTodoByID(id int) (*model.Todo, error) {
    key := fmt.Sprintf("todo:%d", id)

    if cached, ok := h.cache.Get(key); ok {
        if cached == nil {
            return nil, nil  // ç¼“å­˜äº†ç©ºç»“æœ
        }
        return cached.(*model.Todo), nil
    }

    todo, err := h.db.GetTodoByID(id)
    if err != nil {
        return nil, err
    }

    // å³ä½¿ç»“æœä¸ºç©ºä¹Ÿç¼“å­˜ï¼ˆçŸ­TTLï¼‰
    if todo == nil {
        h.cache.Set(key, nil, 1*time.Minute)
    } else {
        h.cache.Set(key, todo, 5*time.Minute)
    }

    return todo, nil
}
```

---

### 3. é˜²æ­¢ç¼“å­˜å‡»ç©¿ï¼ˆSingleFlightï¼‰

```go
import "golang.org/x/sync/singleflight"

var sfGroup singleflight.Group

func (h *Handler) GetStatsWithSingleFlight(ctx context.Context) (*database.TodoStats, error) {
    key := "stats"

    if cached, ok := h.cache.Get(key); ok {
        return cached.(*database.TodoStats), nil
    }

    // ç›¸åŒ key çš„å¹¶å‘è¯·æ±‚åªæ‰§è¡Œä¸€æ¬¡
    v, err, _ := sfGroup.Do(key, func() (interface{}, error) {
        stats, err := h.db.GetStatsContext(ctx)
        if err != nil {
            return nil, err
        }
        h.cache.Set(key, stats, CacheTTLStats)
        return stats, nil
    })

    if err != nil {
        return nil, err
    }
    return v.(*database.TodoStats), nil
}
```

---

### 4. éšæœº TTLï¼ˆé˜²æ­¢ç¼“å­˜é›ªå´©ï¼‰

```go
import "math/rand"

func randomTTL(base time.Duration) time.Duration {
    // åœ¨ base çš„ 80% - 120% ä¹‹é—´éšæœº
    jitter := float64(base) * 0.2
    return base + time.Duration(rand.Float64()*jitter*2-jitter)
}

// ä½¿ç”¨
h.cache.Set("key", value, randomTTL(5*time.Minute))
```

---

## ğŸ› ï¸ å®ç°æ­¥éª¤å»ºè®®

### æ¸è¿›å¼å®ç°ï¼ˆåˆ† 5 æ­¥ï¼‰

**ç¬¬ 1 æ­¥**ï¼šåˆ›å»º `cache/cache.go`ï¼Œå®ç°åŸºæœ¬ç¼“å­˜

æµ‹è¯•ï¼š
```go
c := cache.New()
c.Set("test", "value", time.Minute)
v, ok := c.Get("test")
fmt.Println(v, ok)  // value true
```

---

**ç¬¬ 2 æ­¥**ï¼šåˆ›å»º `cache/monitored_cache.go`ï¼Œæ·»åŠ ç›‘æ§

æµ‹è¯•ï¼š
```go
c := cache.NewMonitored()
c.Get("miss")
c.Set("hit", "value", time.Minute)
c.Get("hit")
fmt.Printf("å‘½ä¸­ç‡: %.2f%%\n", c.HitRate())  // 50.00%
```

---

**ç¬¬ 3 æ­¥**ï¼šä¿®æ”¹ `handler/handler.go`ï¼Œé›†æˆç¼“å­˜

- æ·»åŠ  `cache` å­—æ®µåˆ° Handler
- ä¿®æ”¹ `NewHandler` åˆå§‹åŒ–ç¼“å­˜
- æ·»åŠ ç¼“å­˜å¸¸é‡

---

**ç¬¬ 4 æ­¥**ï¼šä¿®æ”¹ `GetStats`ï¼Œæ·»åŠ ç¼“å­˜é€»è¾‘

- å…ˆæŸ¥ç¼“å­˜
- ç¼“å­˜æœªå‘½ä¸­æ—¶æŸ¥æ•°æ®åº“
- æŸ¥è¯¢ç»“æœå†™å…¥ç¼“å­˜
- ä¿æŒ Context è¶…æ—¶æ”¯æŒ

---

**ç¬¬ 5 æ­¥**ï¼šåœ¨å†™æ“ä½œä¸­æ·»åŠ ç¼“å­˜å¤±æ•ˆ

- CreateTodoã€UpdateTodoã€DeleteTodo
- BatchCompleteTodosPartialã€BatchDeleteTodosPartial
- ä»»ä½•ä¿®æ”¹æ•°æ®çš„æ“ä½œéƒ½è¦å¤±æ•ˆç›¸å…³ç¼“å­˜

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### å®Œæ•´æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1"

echo "=== 1. é¦–æ¬¡è¯·æ±‚ç»Ÿè®¡ï¼ˆåº”è¯¥æŸ¥è¯¢æ•°æ®åº“ï¼‰==="
time curl -s "$BASE_URL/todos/stats" | jq '.message'

echo -e "\n=== 2. ç¬¬äºŒæ¬¡è¯·æ±‚ï¼ˆåº”è¯¥å‘½ä¸­ç¼“å­˜ï¼Œæ›´å¿«ï¼‰==="
time curl -s "$BASE_URL/todos/stats" | jq '.message'

echo -e "\n=== 3. æŸ¥çœ‹ç¼“å­˜æŒ‡æ ‡ ==="
curl -s "$BASE_URL/todos/cache/metrics" | jq '.'

echo -e "\n=== 4. åˆ›å»ºæ•°æ®ï¼ˆåº”è¯¥å¤±æ•ˆç¼“å­˜ï¼‰==="
curl -s -X POST "$BASE_URL/todos" \
  -H "Content-Type: application/json" \
  -d '{"title": "æµ‹è¯•ç¼“å­˜å¤±æ•ˆ"}' > /dev/null

echo -e "\n=== 5. å†æ¬¡è¯·æ±‚ç»Ÿè®¡ï¼ˆç¼“å­˜å·²å¤±æ•ˆï¼Œé‡æ–°æŸ¥è¯¢ï¼‰==="
curl -s "$BASE_URL/todos/stats" | jq '.message'

echo -e "\n=== 6. æŸ¥çœ‹æœ€ç»ˆç¼“å­˜æŒ‡æ ‡ ==="
curl -s "$BASE_URL/todos/cache/metrics" | jq '.'
# åº”è¯¥çœ‹åˆ°:
# - hits: 1 (ç¬¬äºŒæ¬¡è¯·æ±‚å‘½ä¸­)
# - misses: 2 (é¦–æ¬¡ + å¤±æ•ˆå)
# - hit_rate: 33.33%

echo -e "\n=== 7. å‹åŠ›æµ‹è¯•ï¼ˆ100æ¬¡è¯·æ±‚ï¼‰==="
for i in {1..100}; do
  curl -s "$BASE_URL/todos/stats" > /dev/null &
done
wait

curl -s "$BASE_URL/todos/cache/metrics" | jq '.'
# åº”è¯¥çœ‹åˆ° hit_rate æ¥è¿‘ 99%

echo -e "\n=== 8. å‘åå…¼å®¹æµ‹è¯•ï¼ˆ/api/todos/ï¼‰==="
curl -s "http://localhost:7789/api/todos/cache/metrics" | jq '.'
```

ä¿å­˜ä¸º `scripts/test-cache.sh`ï¼Œç„¶åæ‰§è¡Œï¼š
```bash
chmod +x scripts/test-cache.sh
./scripts/test-cache.sh
```

### åŸºå‡†æµ‹è¯•

```go
// cache/cache_test.go
package cache

import (
    "testing"
    "time"
)

func BenchmarkCacheGet(b *testing.B) {
    c := New()
    c.Set("key", "value", time.Hour)

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        c.Get("key")
    }
}

func BenchmarkCacheSet(b *testing.B) {
    c := New()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        c.Set("key", "value", time.Hour)
    }
}

func BenchmarkCacheParallel(b *testing.B) {
    c := New()
    c.Set("key", "value", time.Hour)

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            c.Get("key")
        }
    })
}
```

è¿è¡Œï¼š`go test -bench=. -benchmem ./cache/`

---

## âœ… éªŒè¯æ¸…å•

å®ç°å®Œæˆåï¼Œè¯·æ£€æŸ¥ï¼š

**ç¼“å­˜åŸºç¡€**ï¼š
- [ ] `Cache` ç»“æ„ä½“ä½¿ç”¨ `sync.Map`
- [ ] `Get` æ–¹æ³•å®ç°æƒ°æ€§åˆ é™¤
- [ ] `Set` æ–¹æ³•æ”¯æŒ TTL
- [ ] `Delete` æ–¹æ³•åˆ é™¤å•ä¸ª key
- [ ] `DeleteByPrefix` æ‰¹é‡åˆ é™¤

**ç›‘æ§ç»Ÿè®¡**ï¼š
- [ ] è®°å½•å‘½ä¸­æ¬¡æ•°ï¼ˆä½¿ç”¨ atomicï¼‰
- [ ] è®°å½•æœªå‘½ä¸­æ¬¡æ•°ï¼ˆä½¿ç”¨ atomicï¼‰
- [ ] è®¡ç®—å‘½ä¸­ç‡
- [ ] `/api/v1/todos/cache/metrics` æ¥å£
- [ ] `/api/todos/cache/metrics` æ¥å£ï¼ˆå‘åå…¼å®¹ï¼‰

**Context æ”¯æŒ**ï¼ˆä¸é¡¹ç›®ç°æœ‰é£æ ¼ä¸€è‡´ï¼‰ï¼š
- [ ] `GetStats` ä½¿ç”¨ `context.WithTimeout`
- [ ] åŒºåˆ† `context.DeadlineExceeded` å’Œ `context.Canceled`
- [ ] æ•°æ®åº“æŸ¥è¯¢ä½¿ç”¨ `QueryRowContext`

**é›†æˆ**ï¼š
- [ ] Handler ç»“æ„ä½“åŒ…å« `cache` å­—æ®µ
- [ ] `GetStats` ä½¿ç”¨ç¼“å­˜
- [ ] CreateTodo åå¤±æ•ˆç¼“å­˜
- [ ] UpdateTodo åå¤±æ•ˆç¼“å­˜
- [ ] DeleteTodo åå¤±æ•ˆç¼“å­˜
- [ ] æ‰¹é‡æ“ä½œåå¤±æ•ˆç¼“å­˜

**å®‰å…¨æ€§**ï¼š
- [ ] å¹¶å‘å®‰å…¨ï¼ˆä½¿ç”¨ sync.Mapï¼‰
- [ ] TTL è¿‡æœŸæœºåˆ¶
- [ ] åˆç†çš„ç¼“å­˜æ—¶é—´

**ä»£ç è´¨é‡**ï¼š
- [ ] ä½¿ç”¨ `log.Printf` è¿›è¡Œæ—¥å¿—è®°å½•ï¼ˆä¸é¡¹ç›®é£æ ¼ä¸€è‡´ï¼‰
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] æœ‰æ¸…æ™°çš„æ³¨é‡Š
- [ ] ä»£ç æ ¼å¼ç¬¦åˆ gofmt

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: ä»€ä¹ˆæ—¶å€™éœ€è¦ç”¨ Redisï¼Ÿ

**ç­”**ï¼šä»¥ä¸‹æƒ…å†µéœ€è¦ Redisï¼š
- å¤šå®ä¾‹éƒ¨ç½²ï¼ˆç¼“å­˜éœ€è¦å…±äº«ï¼‰
- ç¼“å­˜æ•°æ®é‡å¤§ï¼ˆè¶…è¿‡å†…å­˜é™åˆ¶ï¼‰
- éœ€è¦æŒä¹…åŒ–ç¼“å­˜
- éœ€è¦é«˜çº§æ•°æ®ç»“æ„ï¼ˆæœ‰åºé›†åˆã€å‘å¸ƒè®¢é˜…ç­‰ï¼‰

å•æœºåº”ç”¨ç”¨å†…å­˜ç¼“å­˜å°±å¤Ÿäº†ã€‚

### Q2: ç¼“å­˜ TTL è®¾ç½®å¤šé•¿åˆé€‚ï¼Ÿ

**ç­”**ï¼š
- å˜åŒ–é¢‘ç¹çš„æ•°æ®ï¼š10-30 ç§’
- ç›¸å¯¹ç¨³å®šçš„æ•°æ®ï¼š1-5 åˆ†é’Ÿ
- å¾ˆå°‘å˜åŒ–çš„æ•°æ®ï¼š10-30 åˆ†é’Ÿ
- å‡ ä¹ä¸å˜çš„æ•°æ®ï¼š1 å°æ—¶æˆ–æ›´é•¿

### Q3: ç¼“å­˜ vs æ•°æ®åº“ç´¢å¼•ï¼Œå“ªä¸ªæ›´é‡è¦ï¼Ÿ

**ç­”**ï¼šå…ˆä¼˜åŒ–æ•°æ®åº“ç´¢å¼•ï¼Œå†è€ƒè™‘ç¼“å­˜ã€‚
- ç´¢å¼•æ˜¯æ²»æœ¬ï¼ˆå‡å°‘æŸ¥è¯¢æ—¶é—´ï¼‰
- ç¼“å­˜æ˜¯æ²»æ ‡ï¼ˆå‡å°‘æŸ¥è¯¢æ¬¡æ•°ï¼‰

### Q4: å¦‚ä½•å¤„ç†ç¼“å­˜å’Œæ•°æ®åº“ä¸ä¸€è‡´ï¼Ÿ

**ç­”**ï¼š
1. **å†™å…¥æ—¶å¤±æ•ˆ**ï¼šå†™æ•°æ®åº“åç«‹å³åˆ é™¤ç¼“å­˜
2. **å»¶è¿ŸåŒåˆ **ï¼šå†™å‰åˆ é™¤ â†’ å†™æ•°æ®åº“ â†’ å»¶è¿Ÿå†åˆ é™¤ä¸€æ¬¡
3. **è®¾ç½®åˆç† TTL**ï¼šå³ä½¿ä¸ä¸€è‡´ï¼Œå¾ˆå¿«ä¹Ÿä¼šè¿‡æœŸ

### Q5: ä¸ºä»€ä¹ˆä¸ç”¨ slog è€Œç”¨ log.Printfï¼Ÿ

**ç­”**ï¼šä¸ºäº†ä¿æŒä¸é¡¹ç›®ç°æœ‰ä»£ç é£æ ¼ä¸€è‡´ã€‚é¡¹ç›®ä¸­å…¶ä»– Handler éƒ½ä½¿ç”¨ `log.Printf`ï¼Œæ–°ä»£ç åº”éµå¾ªç›¸åŒé£æ ¼ã€‚å¦‚æœå°†æ¥é¡¹ç›®ç»Ÿä¸€è¿ç§»åˆ° slogï¼Œå†ä¸€èµ·ä¿®æ”¹ã€‚

---

## ğŸ“– æ‰©å±•é˜…è¯»

### Go å¹¶å‘
- [sync.Map å®˜æ–¹æ–‡æ¡£](https://pkg.go.dev/sync#Map)
- [sync/atomic åŒ…](https://pkg.go.dev/sync/atomic)

### ç¼“å­˜ç­–ç•¥
- [ç¼“å­˜ç©¿é€ã€å‡»ç©¿ã€é›ªå´©](https://segmentfault.com/a/1190000023937024)
- [SingleFlight æ¨¡å¼](https://pkg.go.dev/golang.org/x/sync/singleflight)

### æ€§èƒ½æµ‹è¯•
- [Go Benchmark æŒ‡å—](https://pkg.go.dev/testing#hdr-Benchmarks)

---

## ğŸš€ å¼€å§‹å®ç°å§ï¼

ç°åœ¨è¯·ä½ æŒ‰ç…§ä»¥ä¸Šæ­¥éª¤ï¼š

1. **åˆ›å»º `cache/cache.go`**ï¼šå®ç°åŸºæœ¬ç¼“å­˜åŠŸèƒ½
2. **åˆ›å»º `cache/monitored_cache.go`**ï¼šæ·»åŠ ç›‘æ§ç»Ÿè®¡
3. **ä¿®æ”¹ `handler/handler.go`**ï¼šé›†æˆç¼“å­˜åˆ° Handler
4. **ä¿®æ”¹ `database/db.go`**ï¼šæ·»åŠ  `GetStatsContext` æ–¹æ³•ï¼ˆå¦‚æœéœ€è¦ï¼‰
5. **ä¿®æ”¹ `api/routes.go`**ï¼šæ³¨å†Œç¼“å­˜æŒ‡æ ‡è·¯ç”±
6. **æµ‹è¯•**ï¼šä½¿ç”¨æµ‹è¯•è„šæœ¬éªŒè¯åŠŸèƒ½

**è®°ä½**ï¼š
- ä½¿ç”¨ `sync.Map` ä¿è¯å¹¶å‘å®‰å…¨
- TTL è¿‡æœŸ + æƒ°æ€§åˆ é™¤
- å†™å…¥æ—¶å¤±æ•ˆç›¸å…³ç¼“å­˜
- ä¿æŒä¸é¡¹ç›®ç°æœ‰ä»£ç é£æ ¼ä¸€è‡´ï¼ˆ`log.Printf`ã€Context è¶…æ—¶ï¼‰

é‡åˆ°é—®é¢˜éšæ—¶é—®æˆ‘ï¼
