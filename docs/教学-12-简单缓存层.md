# æ•™å­¦ Part 12: ç®€å•ç¼“å­˜å±‚

> **å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / æ€§èƒ½ä¼˜åŒ–
> **å‰ç½®è¦æ±‚**: å·²æŽŒæ¡ Go å¹¶å‘åŸºç¡€ã€sync åŒ…
> **å­¦ä¹ ç›®æ ‡**: ç†è§£ç¼“å­˜ç­–ç•¥ã€æŽŒæ¡ `sync.Map` å’Œ `sync.RWMutex`ã€å®žçŽ° TTL ç¼“å­˜
> **æ—¶é—´æŠ•å…¥**: 2-3 å°æ—¶(ç†è§£åŽŸç† + å®žçŽ° + æµ‹è¯•)

---

## ðŸŽ¯ åŠŸèƒ½åˆ†æž - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®žé—®é¢˜**:
- ç»Ÿè®¡ä¿¡æ¯ API æ¯æ¬¡éƒ½è¦æ‰«æå…¨è¡¨ â†’ å“åº”æ…¢
- åŒä¸€æ•°æ®è¢«é¢‘ç¹è¯·æ±‚ â†’ æ•°æ®åº“åŽ‹åŠ›å¤§
- é¦–é¡µåŠ è½½æ…¢ â†’ ç”¨æˆ·ä½“éªŒå·®

**çœŸå®žåœºæ™¯**:
```
ç”¨æˆ· A: GET /api/v1/todos/stats  â†’ æŸ¥è¯¢æ•°æ®åº“ 50ms
ç”¨æˆ· B: GET /api/v1/todos/stats  â†’ å†æ¬¡æŸ¥è¯¢æ•°æ®åº“ 50ms
ç”¨æˆ· C: GET /api/v1/todos/stats  â†’ å†æ¬¡æŸ¥è¯¢æ•°æ®åº“ 50ms
...
ä¸€åˆ†é’Ÿå†… 100 æ¬¡è¯·æ±‚ â†’ 100 æ¬¡æ•°æ®åº“æŸ¥è¯¢
```

**åŠ å…¥ç¼“å­˜åŽ**:
```
ç”¨æˆ· A: GET /api/v1/todos/stats  â†’ æŸ¥è¯¢æ•°æ®åº“ 50ms â†’ ç¼“å­˜ç»“æžœ
ç”¨æˆ· B: GET /api/v1/todos/stats  â†’ å‘½ä¸­ç¼“å­˜ 0.1ms
ç”¨æˆ· C: GET /api/v1/todos/stats  â†’ å‘½ä¸­ç¼“å­˜ 0.1ms
...
ä¸€åˆ†é’Ÿå†… 100 æ¬¡è¯·æ±‚ â†’ 1 æ¬¡æ•°æ®åº“æŸ¥è¯¢ + 99 æ¬¡ç¼“å­˜å‘½ä¸­
```

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ðŸ’¡ **æ ¸å¿ƒæ€è·¯**: å†…å­˜ç¼“å­˜ + TTL è¿‡æœŸ

**ä¸éœ€è¦ Redis**: å•æœºåº”ç”¨ç”¨å†…å­˜ç¼“å­˜å°±å¤Ÿäº†

```go
// ç®€å•çš„ç¼“å­˜ç»“æž„
type Cache struct {
    data sync.Map
}

type cacheEntry struct {
    value     interface{}
    expiredAt time.Time
}
```

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£Žé™©**:
- ç¼“å­˜æ•°æ®è¿‡æœŸ â†’ ç”¨æˆ·çœ‹åˆ°æ—§æ•°æ®
- å†…å­˜æ³„æ¼ â†’ ç¼“å­˜æ•°æ®ä¸æ¸…ç†
- å¹¶å‘é—®é¢˜ â†’ æ•°æ®ç«žäº‰

âœ… **å®‰å…¨è®¾è®¡**:
- TTL è¿‡æœŸæœºåˆ¶
- å†™å…¥æ—¶å¤±æ•ˆç­–ç•¥
- ä½¿ç”¨ `sync.Map` ä¿è¯å¹¶å‘å®‰å…¨

---

## ðŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. ç¼“å­˜çš„åŸºæœ¬æ¦‚å¿µ

**ç¼“å­˜å‘½ä¸­ (Cache Hit)**: æ•°æ®åœ¨ç¼“å­˜ä¸­ï¼Œç›´æŽ¥è¿”å›ž
**ç¼“å­˜æœªå‘½ä¸­ (Cache Miss)**: æ•°æ®ä¸åœ¨ç¼“å­˜ä¸­ï¼Œéœ€è¦æŸ¥è¯¢æ•°æ®æº

**å…³é”®æŒ‡æ ‡**:
- **å‘½ä¸­çŽ‡**: å‘½ä¸­æ¬¡æ•° / æ€»è¯·æ±‚æ¬¡æ•°
- **TTL (Time To Live)**: ç¼“å­˜æ•°æ®çš„å­˜æ´»æ—¶é—´

---

### 2. Go çš„å¹¶å‘å®‰å…¨ Map

**æ™®é€š map ä¸æ˜¯å¹¶å‘å®‰å…¨çš„**:
```go
// âŒ ä¼š panic: concurrent map writes
m := make(map[string]int)
go func() { m["a"] = 1 }()
go func() { m["b"] = 2 }()
```

**æ–¹æ¡ˆ A: sync.RWMutex**
```go
type Cache struct {
    mu   sync.RWMutex
    data map[string]interface{}
}

func (c *Cache) Get(key string) (interface{}, bool) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    v, ok := c.data[key]
    return v, ok
}

func (c *Cache) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()
    c.data[key] = value
}
```

**æ–¹æ¡ˆ B: sync.Map** (æŽ¨èç”¨äºŽè¯»å¤šå†™å°‘åœºæ™¯)
```go
var cache sync.Map

// å­˜å‚¨
cache.Store("key", value)

// è¯»å–
if v, ok := cache.Load("key"); ok {
    // ä½¿ç”¨ v
}

// åˆ é™¤
cache.Delete("key")
```

**sync.Map çš„ä¼˜åŠ¿**:
- æ— é”è¯»å–(è¯»å¤šå†™å°‘æ—¶æ€§èƒ½å¥½)
- è‡ªåŠ¨å¤„ç†å¹¶å‘
- ä¸éœ€è¦åˆå§‹åŒ–

---

### 3. TTL å®žçŽ°ç­–ç•¥

**ç­–ç•¥ A: æƒ°æ€§åˆ é™¤** (æŽ¨è)
- è¯»å–æ—¶æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
- è¿‡æœŸåˆ™åˆ é™¤å¹¶è¿”å›žæœªå‘½ä¸­
- ä¼˜ç‚¹: ç®€å•ï¼Œæ— åŽå° goroutine

**ç­–ç•¥ B: å®šæœŸæ¸…ç†**
- åŽå° goroutine å®šæœŸæ‰«æè¿‡æœŸæ•°æ®
- ä¼˜ç‚¹: å†…å­˜åŠæ—¶é‡Šæ”¾
- ç¼ºç‚¹: å¢žåŠ å¤æ‚åº¦

**ç­–ç•¥ C: æƒ°æ€§ + å®šæœŸ**
- è¯»å–æ—¶æ£€æŸ¥ + å®šæœŸæ¸…ç†
- æœ€ä½³å®žè·µï¼Œä½†å¤æ‚åº¦æœ€é«˜

---

### 4. ç¼“å­˜å¤±æ•ˆç­–ç•¥

**å†™å…¥æ—¶å¤±æ•ˆ (Write-Through)**:
```go
func (h *Handler) CreateTodo(...) {
    // å†™å…¥æ•°æ®åº“
    h.db.CreateTodo(todo)
    // ç«‹å³å¤±æ•ˆç›¸å…³ç¼“å­˜
    h.cache.Delete("stats")
    h.cache.Delete("todos_list")
}
```

**å¸¸è§ç¼“å­˜é—®é¢˜**:

| é—®é¢˜ | æè¿° | è§£å†³æ–¹æ¡ˆ |
|------|------|----------|
| ç¼“å­˜ç©¿é€ | æŸ¥è¯¢ä¸å­˜åœ¨çš„æ•°æ® | ç¼“å­˜ç©ºç»“æžœ |
| ç¼“å­˜å‡»ç©¿ | çƒ­ç‚¹æ•°æ®è¿‡æœŸçž¬é—´å¤§é‡è¯·æ±‚ | åŠ é”æˆ–æ°¸ä¸è¿‡æœŸ |
| ç¼“å­˜é›ªå´© | å¤§é‡ç¼“å­˜åŒæ—¶è¿‡æœŸ | éšæœº TTL |

---

## ðŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: åˆ›å»ºç¼“å­˜æ¨¡å—

åˆ›å»º `cache/cache.go`:

```go
package cache

import (
    "sync"
    "time"
)

// Cache ç®€å•çš„å†…å­˜ç¼“å­˜
type Cache struct {
    data sync.Map
}

// cacheEntry ç¼“å­˜æ¡ç›®
type cacheEntry struct {
    value     interface{}
    expiredAt time.Time
}

// New åˆ›å»ºç¼“å­˜å®žä¾‹
func New() *Cache {
    return &Cache{}
}

// Get èŽ·å–ç¼“å­˜å€¼
func (c *Cache) Get(key string) (interface{}, bool) {
    entry, ok := c.data.Load(key)
    if !ok {
        return nil, false
    }

    e := entry.(*cacheEntry)

    // æ£€æŸ¥æ˜¯å¦è¿‡æœŸ
    if time.Now().After(e.expiredAt) {
        c.data.Delete(key)  // æƒ°æ€§åˆ é™¤
        return nil, false
    }

    return e.value, true
}

// Set è®¾ç½®ç¼“å­˜å€¼
func (c *Cache) Set(key string, value interface{}, ttl time.Duration) {
    c.data.Store(key, &cacheEntry{
        value:     value,
        expiredAt: time.Now().Add(ttl),
    })
}

// Delete åˆ é™¤ç¼“å­˜
func (c *Cache) Delete(key string) {
    c.data.Delete(key)
}

// DeleteByPrefix åˆ é™¤æŒ‡å®šå‰ç¼€çš„æ‰€æœ‰ç¼“å­˜
func (c *Cache) DeleteByPrefix(prefix string) {
    c.data.Range(func(key, value interface{}) bool {
        k := key.(string)
        if len(k) >= len(prefix) && k[:len(prefix)] == prefix {
            c.data.Delete(key)
        }
        return true
    })
}

// Clear æ¸…ç©ºæ‰€æœ‰ç¼“å­˜
func (c *Cache) Clear() {
    c.data.Range(func(key, value interface{}) bool {
        c.data.Delete(key)
        return true
    })
}

// Stats èŽ·å–ç¼“å­˜ç»Ÿè®¡
type CacheStats struct {
    Count   int `json:"count"`
    Expired int `json:"expired"`
}

func (c *Cache) Stats() CacheStats {
    var stats CacheStats
    now := time.Now()

    c.data.Range(func(key, value interface{}) bool {
        stats.Count++
        e := value.(*cacheEntry)
        if now.After(e.expiredAt) {
            stats.Expired++
        }
        return true
    })

    return stats
}

// Cleanup æ¸…ç†è¿‡æœŸç¼“å­˜(å¯é€‰ï¼Œç”¨äºŽåŽå°å®šæœŸæ¸…ç†)
func (c *Cache) Cleanup() int {
    var deleted int
    now := time.Now()

    c.data.Range(func(key, value interface{}) bool {
        e := value.(*cacheEntry)
        if now.After(e.expiredAt) {
            c.data.Delete(key)
            deleted++
        }
        return true
    })

    return deleted
}
```

---

### æ­¥éª¤ 2: å¸¦ç›‘æŽ§çš„ç¼“å­˜åŒ…è£…å™¨

åˆ›å»º `cache/monitored_cache.go`:

```go
package cache

import (
    "log/slog"
    "sync/atomic"
    "time"
)

// MonitoredCache å¸¦ç›‘æŽ§çš„ç¼“å­˜
type MonitoredCache struct {
    *Cache
    hits   uint64
    misses uint64
}

// NewMonitored åˆ›å»ºå¸¦ç›‘æŽ§çš„ç¼“å­˜
func NewMonitored() *MonitoredCache {
    return &MonitoredCache{
        Cache: New(),
    }
}

// Get èŽ·å–ç¼“å­˜(å¸¦ç»Ÿè®¡)
func (c *MonitoredCache) Get(key string) (interface{}, bool) {
    value, ok := c.Cache.Get(key)
    if ok {
        atomic.AddUint64(&c.hits, 1)
    } else {
        atomic.AddUint64(&c.misses, 1)
    }
    return value, ok
}

// HitRate èŽ·å–å‘½ä¸­çŽ‡
func (c *MonitoredCache) HitRate() float64 {
    hits := atomic.LoadUint64(&c.hits)
    misses := atomic.LoadUint64(&c.misses)
    total := hits + misses
    if total == 0 {
        return 0
    }
    return float64(hits) / float64(total) * 100
}

// Metrics èŽ·å–ç¼“å­˜æŒ‡æ ‡
type CacheMetrics struct {
    Hits    uint64  `json:"hits"`
    Misses  uint64  `json:"misses"`
    HitRate float64 `json:"hit_rate"`
    Count   int     `json:"count"`
}

func (c *MonitoredCache) Metrics() CacheMetrics {
    hits := atomic.LoadUint64(&c.hits)
    misses := atomic.LoadUint64(&c.misses)
    stats := c.Cache.Stats()

    var hitRate float64
    if total := hits + misses; total > 0 {
        hitRate = float64(hits) / float64(total) * 100
    }

    return CacheMetrics{
        Hits:    hits,
        Misses:  misses,
        HitRate: hitRate,
        Count:   stats.Count,
    }
}

// ResetMetrics é‡ç½®ç»Ÿè®¡
func (c *MonitoredCache) ResetMetrics() {
    atomic.StoreUint64(&c.hits, 0)
    atomic.StoreUint64(&c.misses, 0)
}

// LogMetrics è®°å½•ç¼“å­˜æŒ‡æ ‡åˆ°æ—¥å¿—
func (c *MonitoredCache) LogMetrics() {
    m := c.Metrics()
    slog.Info("ç¼“å­˜æŒ‡æ ‡",
        "hits", m.Hits,
        "misses", m.Misses,
        "hit_rate", m.HitRate,
        "count", m.Count,
    )
}
```

---

### æ­¥éª¤ 3: é›†æˆåˆ° Handler

æ›´æ–° `handler/handler.go`:

```go
package handler

import (
    "time"
    "todo-list/cache"
    "todo-list/database"
)

// ç¼“å­˜ Key å¸¸é‡
const (
    CacheKeyStats      = "stats"
    CacheKeyTodosList  = "todos:list"
    CacheTTLStats      = 1 * time.Minute   // ç»Ÿè®¡ä¿¡æ¯ç¼“å­˜ 1 åˆ†é’Ÿ
    CacheTTLTodosList  = 30 * time.Second  // åˆ—è¡¨ç¼“å­˜ 30 ç§’
)

// Handler å¤„ç†å™¨ç»“æž„ä½“
type Handler struct {
    db    *database.DB
    cache *cache.MonitoredCache
}

// NewHandler åˆ›å»ºæ–°çš„å¤„ç†å™¨
func NewHandler(db *database.DB) *Handler {
    return &Handler{
        db:    db,
        cache: cache.NewMonitored(),
    }
}

// GetStats èŽ·å–ç»Ÿè®¡ä¿¡æ¯(å¸¦ç¼“å­˜)
func (h *Handler) GetStats(w http.ResponseWriter, r *http.Request) {
    // 1. å…ˆæŸ¥ç¼“å­˜
    if cached, ok := h.cache.Get(CacheKeyStats); ok {
        slog.Debug("ç¼“å­˜å‘½ä¸­", "key", CacheKeyStats)
        h.sendJSON(w, http.StatusOK, Response{
            Success: true,
            Data:    cached,
            Message: "èŽ·å–ç»Ÿè®¡ä¿¡æ¯æˆåŠŸ(ç¼“å­˜)",
        })
        return
    }

    // 2. ç¼“å­˜æœªå‘½ä¸­ï¼ŒæŸ¥æ•°æ®åº“
    slog.Debug("ç¼“å­˜æœªå‘½ä¸­", "key", CacheKeyStats)
    stats, err := h.db.GetStats()
    if err != nil {
        h.sendError(w, http.StatusInternalServerError, "GET_STATS_ERROR", "èŽ·å–ç»Ÿè®¡ä¿¡æ¯å¤±è´¥")
        return
    }

    // 3. å†™å…¥ç¼“å­˜
    h.cache.Set(CacheKeyStats, stats, CacheTTLStats)

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    stats,
        Message: "èŽ·å–ç»Ÿè®¡ä¿¡æ¯æˆåŠŸ",
    })
}

// InvalidateCache ä½¿ç¼“å­˜å¤±æ•ˆ(å†™æ“ä½œåŽè°ƒç”¨)
func (h *Handler) InvalidateCache() {
    h.cache.Delete(CacheKeyStats)
    h.cache.DeleteByPrefix("todos:")
    slog.Debug("ç¼“å­˜å·²å¤±æ•ˆ")
}

// CreateTodo åˆ›å»ºå¾…åŠžäº‹é¡¹
func (h *Handler) CreateTodo(w http.ResponseWriter, r *http.Request) {
    // ... åŽŸæœ‰é€»è¾‘ ...

    if err := h.db.CreateTodo(todo); err != nil {
        // ...
    }

    // åˆ›å»ºæˆåŠŸåŽå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›žå“åº” ...
}

// UpdateTodo æ›´æ–°å¾…åŠžäº‹é¡¹
func (h *Handler) UpdateTodo(w http.ResponseWriter, r *http.Request) {
    // ... åŽŸæœ‰é€»è¾‘ ...

    if err := h.db.UpdateTodo(todo); err != nil {
        // ...
    }

    // æ›´æ–°æˆåŠŸåŽå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›žå“åº” ...
}

// DeleteTodo åˆ é™¤å¾…åŠžäº‹é¡¹
func (h *Handler) DeleteTodo(w http.ResponseWriter, r *http.Request) {
    // ... åŽŸæœ‰é€»è¾‘ ...

    if err := h.db.SoftDeleteTodo(id); err != nil {
        // ...
    }

    // åˆ é™¤æˆåŠŸåŽå¤±æ•ˆç¼“å­˜
    h.InvalidateCache()

    // ... è¿”å›žå“åº” ...
}

// GetCacheMetrics èŽ·å–ç¼“å­˜æŒ‡æ ‡(è°ƒè¯•ç”¨)
func (h *Handler) GetCacheMetrics(w http.ResponseWriter, r *http.Request) {
    metrics := h.cache.Metrics()

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    metrics,
        Message: "èŽ·å–ç¼“å­˜æŒ‡æ ‡æˆåŠŸ",
    })
}
```

---

### æ­¥éª¤ 4: æ·»åŠ ç¼“å­˜æ¸…ç†å®šæ—¶ä»»åŠ¡

åœ¨ `scheduler/scheduler.go` ä¸­æ·»åŠ :

```go
// cleanupCache æ¸…ç†è¿‡æœŸç¼“å­˜
func (s *Scheduler) cleanupCache() {
    if s.cache == nil {
        return
    }

    deleted := s.cache.Cleanup()
    if deleted > 0 {
        slog.Debug("æ¸…ç†è¿‡æœŸç¼“å­˜", "deleted", deleted)
    }

    // è®°å½•ç¼“å­˜æŒ‡æ ‡
    s.cache.LogMetrics()
}

// åœ¨ Start() ä¸­æ·»åŠ 
func (s *Scheduler) Start() {
    // ... å…¶ä»–ä»»åŠ¡ ...

    // æ¯ 5 åˆ†é’Ÿæ¸…ç†è¿‡æœŸç¼“å­˜
    s.wg.Add(1)
    go s.runTask("æ¸…ç†ç¼“å­˜", 5*time.Minute, s.cleanupCache)
}
```

---

### æ­¥éª¤ 5: æ³¨å†Œè·¯ç”±

åœ¨ `api/routes.go` ä¸­æ·»åŠ :

```go
// ç¼“å­˜æŒ‡æ ‡(è°ƒè¯•ç”¨ï¼Œç”Ÿäº§çŽ¯å¢ƒå¯ä»¥å…³é—­)
mux.HandleFunc("GET /api/v1/cache/metrics", withMiddlewares(h.GetCacheMetrics))
```

---

## âš ï¸ å…³é”®ç‚¹è§£æž

### 1. ç¼“å­˜ç²’åº¦é€‰æ‹©

**ç²—ç²’åº¦**: æ•´ä¸ªåˆ—è¡¨ç¼“å­˜
```go
// ä»»ä½•æ•°æ®å˜åŒ–éƒ½è¦å¤±æ•ˆæ•´ä¸ªç¼“å­˜
cache.Delete("todos_list")
```

**ç»†ç²’åº¦**: å•ä¸ªæ•°æ®ç¼“å­˜
```go
// åªå¤±æ•ˆå˜åŒ–çš„æ•°æ®
cache.Delete(fmt.Sprintf("todo:%d", todoID))
```

**æŽ¨è**: ç»Ÿè®¡ä¿¡æ¯ç”¨ç²—ç²’åº¦ï¼Œå•ä¸ª Todo æŸ¥è¯¢ç”¨ç»†ç²’åº¦

---

### 2. ç¼“å­˜ç©ºç»“æžœ(é˜²æ­¢ç¼“å­˜ç©¿é€)

```go
func (h *Handler) GetTodoByID(id int) (*model.Todo, error) {
    key := fmt.Sprintf("todo:%d", id)

    if cached, ok := h.cache.Get(key); ok {
        if cached == nil {
            return nil, nil  // ç¼“å­˜äº†ç©ºç»“æžœ
        }
        return cached.(*model.Todo), nil
    }

    todo, err := h.db.GetTodoByID(id)
    if err != nil {
        return nil, err
    }

    // å³ä½¿ç»“æžœä¸ºç©ºä¹Ÿç¼“å­˜(çŸ­TTL)
    if todo == nil {
        h.cache.Set(key, nil, 1*time.Minute)
    } else {
        h.cache.Set(key, todo, 5*time.Minute)
    }

    return todo, nil
}
```

---

### 3. é˜²æ­¢ç¼“å­˜å‡»ç©¿(SingleFlight)

```go
import "golang.org/x/sync/singleflight"

var sfGroup singleflight.Group

func (h *Handler) GetStatsWithSingleFlight() (*database.TodoStats, error) {
    key := "stats"

    if cached, ok := h.cache.Get(key); ok {
        return cached.(*database.TodoStats), nil
    }

    // ç›¸åŒ key çš„å¹¶å‘è¯·æ±‚åªæ‰§è¡Œä¸€æ¬¡
    v, err, _ := sfGroup.Do(key, func() (interface{}, error) {
        stats, err := h.db.GetStats()
        if err != nil {
            return nil, err
        }
        h.cache.Set(key, stats, CacheTTLStats)
        return stats, nil
    })

    if err != nil {
        return nil, err
    }
    return v.(*database.TodoStats), nil
}
```

---

### 4. éšæœº TTL(é˜²æ­¢ç¼“å­˜é›ªå´©)

```go
import "math/rand"

func randomTTL(base time.Duration) time.Duration {
    // åœ¨ base çš„ 80% - 120% ä¹‹é—´éšæœº
    jitter := float64(base) * 0.2
    return base + time.Duration(rand.Float64()*jitter*2-jitter)
}

// ä½¿ç”¨
h.cache.Set("key", value, randomTTL(5*time.Minute))
```

---

## ðŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1"

echo "=== 1. é¦–æ¬¡è¯·æ±‚ç»Ÿè®¡(åº”è¯¥æŸ¥è¯¢æ•°æ®åº“) ==="
time curl -s "$BASE_URL/todos/stats" | jq '.message'

echo -e "\n=== 2. ç¬¬äºŒæ¬¡è¯·æ±‚(åº”è¯¥å‘½ä¸­ç¼“å­˜ï¼Œæ›´å¿«) ==="
time curl -s "$BASE_URL/todos/stats" | jq '.message'

echo -e "\n=== 3. æŸ¥çœ‹ç¼“å­˜æŒ‡æ ‡ ==="
curl -s "$BASE_URL/cache/metrics" | jq '.'

echo -e "\n=== 4. åˆ›å»ºæ•°æ®(åº”è¯¥å¤±æ•ˆç¼“å­˜) ==="
curl -s -X POST "$BASE_URL/todos" \
  -H "Content-Type: application/json" \
  -d '{"title": "æµ‹è¯•ç¼“å­˜å¤±æ•ˆ"}' > /dev/null

echo -e "\n=== 5. å†æ¬¡è¯·æ±‚ç»Ÿè®¡(ç¼“å­˜å·²å¤±æ•ˆï¼Œé‡æ–°æŸ¥è¯¢) ==="
curl -s "$BASE_URL/todos/stats" | jq '.message'

echo -e "\n=== 6. æŸ¥çœ‹æœ€ç»ˆç¼“å­˜æŒ‡æ ‡ ==="
curl -s "$BASE_URL/cache/metrics" | jq '.'
# åº”è¯¥çœ‹åˆ°:
# - hits: 1 (ç¬¬äºŒæ¬¡è¯·æ±‚å‘½ä¸­)
# - misses: 2 (é¦–æ¬¡ + å¤±æ•ˆåŽ)
# - hit_rate: 33.33%

echo -e "\n=== 7. åŽ‹åŠ›æµ‹è¯•(100æ¬¡è¯·æ±‚) ==="
for i in {1..100}; do
  curl -s "$BASE_URL/todos/stats" > /dev/null &
done
wait

curl -s "$BASE_URL/cache/metrics" | jq '.'
# åº”è¯¥çœ‹åˆ° hit_rate æŽ¥è¿‘ 99%
```

### åŸºå‡†æµ‹è¯•

```go
// cache/cache_test.go
package cache

import (
    "testing"
    "time"
)

func BenchmarkCacheGet(b *testing.B) {
    c := New()
    c.Set("key", "value", time.Hour)

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        c.Get("key")
    }
}

func BenchmarkCacheSet(b *testing.B) {
    c := New()

    b.ResetTimer()
    for i := 0; i < b.N; i++ {
        c.Set("key", "value", time.Hour)
    }
}

func BenchmarkCacheParallel(b *testing.B) {
    c := New()
    c.Set("key", "value", time.Hour)

    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            c.Get("key")
        }
    })
}
```

è¿è¡Œ: `go test -bench=. -benchmem ./cache/`

---

## âœ… å®žçŽ°æ£€æŸ¥æ¸…å•

**ç¼“å­˜åŸºç¡€**:
- [ ] `Cache` ç»“æž„ä½“ä½¿ç”¨ `sync.Map`
- [ ] `Get` æ–¹æ³•å®žçŽ°æƒ°æ€§åˆ é™¤
- [ ] `Set` æ–¹æ³•æ”¯æŒ TTL
- [ ] `Delete` æ–¹æ³•åˆ é™¤å•ä¸ª key
- [ ] `DeleteByPrefix` æ‰¹é‡åˆ é™¤

**ç›‘æŽ§ç»Ÿè®¡**:
- [ ] è®°å½•å‘½ä¸­æ¬¡æ•°
- [ ] è®°å½•æœªå‘½ä¸­æ¬¡æ•°
- [ ] è®¡ç®—å‘½ä¸­çŽ‡
- [ ] `/api/v1/cache/metrics` æŽ¥å£

**é›†æˆ**:
- [ ] `GetStats` ä½¿ç”¨ç¼“å­˜
- [ ] å†™æ“ä½œåŽå¤±æ•ˆç¼“å­˜
- [ ] å®šæ—¶æ¸…ç†è¿‡æœŸç¼“å­˜

**å®‰å…¨æ€§**:
- [ ] å¹¶å‘å®‰å…¨(ä½¿ç”¨ sync.Map)
- [ ] TTL è¿‡æœŸæœºåˆ¶
- [ ] åˆç†çš„ç¼“å­˜æ—¶é—´

---

## ðŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: ä»€ä¹ˆæ—¶å€™éœ€è¦ç”¨ Redis?

**ç­”**: ä»¥ä¸‹æƒ…å†µéœ€è¦ Redis:
- å¤šå®žä¾‹éƒ¨ç½²(ç¼“å­˜éœ€è¦å…±äº«)
- ç¼“å­˜æ•°æ®é‡å¤§(è¶…è¿‡å†…å­˜é™åˆ¶)
- éœ€è¦æŒä¹…åŒ–ç¼“å­˜
- éœ€è¦é«˜çº§æ•°æ®ç»“æž„(æœ‰åºé›†åˆã€å‘å¸ƒè®¢é˜…ç­‰)

å•æœºåº”ç”¨ç”¨å†…å­˜ç¼“å­˜å°±å¤Ÿäº†ã€‚

### Q2: ç¼“å­˜ TTL è®¾ç½®å¤šé•¿åˆé€‚?

**ç­”**:
- å˜åŒ–é¢‘ç¹çš„æ•°æ®: 10-30 ç§’
- ç›¸å¯¹ç¨³å®šçš„æ•°æ®: 1-5 åˆ†é’Ÿ
- å¾ˆå°‘å˜åŒ–çš„æ•°æ®: 10-30 åˆ†é’Ÿ
- å‡ ä¹Žä¸å˜çš„æ•°æ®: 1 å°æ—¶æˆ–æ›´é•¿

### Q3: ç¼“å­˜ vs æ•°æ®åº“ç´¢å¼•ï¼Œå“ªä¸ªæ›´é‡è¦?

**ç­”**: å…ˆä¼˜åŒ–æ•°æ®åº“ç´¢å¼•ï¼Œå†è€ƒè™‘ç¼“å­˜ã€‚
- ç´¢å¼•æ˜¯æ²»æœ¬(å‡å°‘æŸ¥è¯¢æ—¶é—´)
- ç¼“å­˜æ˜¯æ²»æ ‡(å‡å°‘æŸ¥è¯¢æ¬¡æ•°)

### Q4: å¦‚ä½•å¤„ç†ç¼“å­˜å’Œæ•°æ®åº“ä¸ä¸€è‡´?

**ç­”**:
1. **å†™å…¥æ—¶å¤±æ•ˆ**: å†™æ•°æ®åº“åŽç«‹å³åˆ é™¤ç¼“å­˜
2. **å»¶è¿ŸåŒåˆ **: å†™å‰åˆ é™¤ â†’ å†™æ•°æ®åº“ â†’ å»¶è¿Ÿå†åˆ é™¤ä¸€æ¬¡
3. **è®¾ç½®åˆç† TTL**: å³ä½¿ä¸ä¸€è‡´ï¼Œå¾ˆå¿«ä¹Ÿä¼šè¿‡æœŸ

---

## ðŸš€ å®žçŽ°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: åˆ›å»º `cache/cache.go`ï¼Œå®žçŽ°åŸºæœ¬ç¼“å­˜

**ç¬¬ 2 æ­¥**: åˆ›å»º `cache/monitored_cache.go`ï¼Œæ·»åŠ ç›‘æŽ§

**ç¬¬ 3 æ­¥**: åœ¨ `Handler` ä¸­é›†æˆç¼“å­˜

**ç¬¬ 4 æ­¥**: å®žçŽ°å†™æ“ä½œåŽçš„ç¼“å­˜å¤±æ•ˆ

**ç¬¬ 5 æ­¥**: æ·»åŠ ç¼“å­˜æŒ‡æ ‡æŽ¥å£

**ç¬¬ 6 æ­¥**: æµ‹è¯•ç¼“å­˜å‘½ä¸­çŽ‡

---

**çŽ°åœ¨ï¼Œå¼€å§‹å®žçŽ°ç®€å•ç¼“å­˜å±‚å§ï¼è®°ä½ï¼šsync.Mapã€TTL è¿‡æœŸã€å†™å…¥æ—¶å¤±æ•ˆã€‚** ðŸš€
