# æ•™å­¦ Part 8: è½¯åˆ é™¤ä¸å›æ”¶ç«™

> **ğŸ“Œ å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / æ•°æ®åº“è®¾è®¡æ¨¡å¼
> **å‰ç½®è¦æ±‚**: å·²å®Œæˆæ•™å­¦-5/6/7ï¼ˆäº‹åŠ¡ã€Contextã€æ‰¹é‡æ“ä½œã€å¯¼å…¥å¯¼å‡ºï¼‰
> **å­¦ä¹ ç›®æ ‡**: ç†è§£è½¯åˆ é™¤æ¨¡å¼ã€å®ç°å›æ”¶ç«™åŠŸèƒ½ã€æ•°æ®åº“è¿ç§»å®è·µ
> **æ—¶é—´æŠ•å…¥**: 3-4 å°æ—¶(ç†è§£åŸç† + å®ç° + æµ‹è¯•)

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®é—®é¢˜**:
- ç”¨æˆ·è¯¯åˆ é‡è¦å¾…åŠäº‹é¡¹ â†’ æ•°æ®æ°¸ä¹…ä¸¢å¤± â†’ ç”¨æˆ·æ„¤æ€’
- éœ€è¦å®¡è®¡è¿½è¸ª â†’ è°åœ¨ä»€ä¹ˆæ—¶å€™åˆ é™¤äº†ä»€ä¹ˆ
- æ³•è§„è¦æ±‚ â†’ æŸäº›æ•°æ®å¿…é¡»ä¿ç•™ä¸€æ®µæ—¶é—´

**çœŸå®åœºæ™¯**:
```
15:00 - ç”¨æˆ·ä¸å°å¿ƒç‚¹å‡»"åˆ é™¤"
15:01 - "ç³Ÿç³•ï¼é‚£ä¸ªä»»åŠ¡è¿˜æœ‰é‡è¦ä¿¡æ¯ï¼"
15:02 - è”ç³»å®¢æœï¼š"èƒ½æ¢å¤å—ï¼Ÿ"
15:03 - å®¢æœï¼š"æŠ±æ­‰ï¼Œæ— æ³•æ¢å¤..."
```

**ä¸ºä»€ä¹ˆéœ€è¦è½¯åˆ é™¤?**
- **ç”¨æˆ·å‹å¥½**: æä¾›"åæ‚”è¯"
- **æ•°æ®å®Œæ•´æ€§**: ä¿ç•™å…³è”æ•°æ®çš„å¼•ç”¨
- **å®¡è®¡éœ€æ±‚**: çŸ¥é“æ•°æ®ä½•æ—¶è¢«"åˆ é™¤"
- **åˆè§„è¦æ±‚**: GDPR ç­‰æ³•è§„çš„æ•°æ®ä¿ç•™è¦æ±‚

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**: æ ‡è®°åˆ é™¤è€Œéç‰©ç†åˆ é™¤

**ç¡¬åˆ é™¤**(ä¸å¯æ¢å¤):
```sql
DELETE FROM todos WHERE id = 1;  -- æ•°æ®æ°¸ä¹…æ¶ˆå¤±
```

**è½¯åˆ é™¤**(å¯æ¢å¤):
```sql
UPDATE todos SET deleted_at = NOW() WHERE id = 1;  -- åªæ˜¯æ ‡è®°
-- æŸ¥è¯¢æ—¶è¿‡æ»¤
SELECT * FROM todos WHERE deleted_at IS NULL;
```

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£é™©**:
- æ‰€æœ‰æŸ¥è¯¢éƒ½è¦åŠ  `WHERE deleted_at IS NULL` â†’ å®¹æ˜“é—æ¼
- æ•°æ®é‡è†¨èƒ€ â†’ å›æ”¶ç«™æ•°æ®è¶Šæ¥è¶Šå¤š
- å”¯ä¸€çº¦æŸé—®é¢˜ â†’ åˆ é™¤åæ— æ³•åˆ›å»ºåŒåæ•°æ®

âœ… **å®‰å…¨è®¾è®¡**:
- é»˜è®¤è¿‡æ»¤å·²åˆ é™¤æ•°æ®
- å®šæœŸæ¸…ç†å›æ”¶ç«™(30å¤©åè‡ªåŠ¨æ°¸ä¹…åˆ é™¤)
- è€ƒè™‘å”¯ä¸€çº¦æŸçš„è½¯åˆ é™¤å…¼å®¹

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. è½¯åˆ é™¤çš„è®¾è®¡æ¨¡å¼

**æ–¹æ¡ˆ A: å¸ƒå°”æ ‡è®°** (ç®€å•ä½†ä¿¡æ¯å°‘)
```sql
ALTER TABLE todos ADD COLUMN is_deleted BOOLEAN DEFAULT FALSE;
```

**æ–¹æ¡ˆ B: æ—¶é—´æˆ³æ ‡è®°** (æ¨èï¼Œä¿¡æ¯æ›´ä¸°å¯Œ)
```sql
ALTER TABLE todos ADD COLUMN deleted_at DATETIME DEFAULT NULL;
```

**ä¸ºä»€ä¹ˆé€‰æ‹©æ—¶é—´æˆ³?**
- çŸ¥é“"ä»€ä¹ˆæ—¶å€™"åˆ é™¤çš„
- `NULL` è¡¨ç¤ºæœªåˆ é™¤ï¼Œæœ‰å€¼è¡¨ç¤ºå·²åˆ é™¤
- å¯ä»¥å®ç°"30å¤©åè‡ªåŠ¨æ¸…ç†"

---

### 2. æ•°æ®åº“è¿ç§»

**SQLite çš„é™åˆ¶**: ä¸æ”¯æŒ `ALTER TABLE ... DROP COLUMN`

**è¿ç§»ç­–ç•¥**:
```go
// æ£€æŸ¥åˆ—æ˜¯å¦å­˜åœ¨
func (db *DB) ensureDeletedAtColumn() error {
    rows, err := db.conn.Query(`PRAGMA table_info(todos);`)
    // ...

    if !hasDeletedAtColumn {
        _, err := db.conn.Exec(`
            ALTER TABLE todos ADD COLUMN deleted_at DATETIME DEFAULT NULL
        `)
        if err != nil {
            return err
        }
        log.Println("Added deleted_at column to todos table")
    }
    return nil
}
```

---

### 3. æŸ¥è¯¢æ—¶è‡ªåŠ¨è¿‡æ»¤

**é—®é¢˜**: æ¯æ¬¡æŸ¥è¯¢éƒ½è¦è®°å¾—åŠ æ¡ä»¶
```go
// âŒ å®¹æ˜“å¿˜è®°
db.Query("SELECT * FROM todos")

// âŒ æ¯æ¬¡éƒ½è¦å†™
db.Query("SELECT * FROM todos WHERE deleted_at IS NULL")
```

**è§£å†³æ–¹æ¡ˆ**: åœ¨æ•°æ®åº“å±‚ç»Ÿä¸€å¤„ç†
```go
// âœ… é»˜è®¤åªæŸ¥è¯¢æœªåˆ é™¤çš„
func (db *DB) ListTodosContext(ctx context.Context, filter TodoFilter) ([]model.Todo, int, error) {
    baseQuery := "SELECT ... FROM todos WHERE deleted_at IS NULL"
    // ...
}

// âœ… æ˜¾å¼æŸ¥è¯¢å›æ”¶ç«™
func (db *DB) ListTrashContext(ctx context.Context) ([]model.Todo, error) {
    query := "SELECT ... FROM todos WHERE deleted_at IS NOT NULL"
    // ...
}
```

---

### 4. å›æ”¶ç«™åŠŸèƒ½è®¾è®¡

**API è®¾è®¡**:
```
DELETE /api/v1/todos/{id}           â†’ è½¯åˆ é™¤(ç§»å…¥å›æ”¶ç«™)
GET    /api/v1/todos/trash          â†’ æŸ¥çœ‹å›æ”¶ç«™
POST   /api/v1/todos/{id}/restore   â†’ æ¢å¤
DELETE /api/v1/todos/{id}/permanent â†’ æ°¸ä¹…åˆ é™¤
DELETE /api/v1/todos/trash          â†’ æ¸…ç©ºå›æ”¶ç«™
```

**æ•°æ®æµ**:
```
æ­£å¸¸åˆ—è¡¨                    å›æ”¶ç«™
[Todo 1]  --åˆ é™¤-->        [Todo 1 (deleted_at: 2024-01-01)]
[Todo 2]                   [Todo 3 (deleted_at: 2024-01-02)]
[Todo 4]  <--æ¢å¤--
                           --æ°¸ä¹…åˆ é™¤--> ç‰©ç†åˆ é™¤
```

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: æ›´æ–°æ•°æ®æ¨¡å‹

åœ¨ `model/todo.go` ä¸­æ·»åŠ :

```go
type Todo struct {
    ID          int        `json:"id"`
    Version     int        `json:"version"`
    Title       string     `json:"title"`
    Description string     `json:"description"`
    Status      string     `json:"status"`
    DueDate     *time.Time `json:"due_date,omitempty"`
    CreatedAt   time.Time  `json:"created_at"`
    UpdatedAt   time.Time  `json:"updated_at"`
    CompletedAt *time.Time `json:"completed_at,omitempty"`
    DeletedAt   *time.Time `json:"deleted_at,omitempty"`  // æ–°å¢: è½¯åˆ é™¤æ—¶é—´
}

// IsDeleted æ£€æŸ¥æ˜¯å¦å·²åˆ é™¤
func (t *Todo) IsDeleted() bool {
    return t.DeletedAt != nil
}
```

---

### æ­¥éª¤ 2: æ•°æ®åº“è¿ç§»

åœ¨ `database/db.go` çš„ `initSchema()` ä¸­æ·»åŠ :

```go
func (db *DB) initSchema() error {
    schema := `
        CREATE TABLE IF NOT EXISTS todos (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            version INTEGER NOT NULL DEFAULT 1,
            title TEXT NOT NULL,
            description TEXT,
            status TEXT NOT NULL DEFAULT 'pending',
            priority INTEGER NOT NULL DEFAULT 1,
            due_date TEXT,
            created_at DATETIME NOT NULL,
            updated_at DATETIME NOT NULL,
            completed_at DATETIME,
            deleted_at DATETIME DEFAULT NULL
        );

        CREATE INDEX IF NOT EXISTS idx_status ON todos(status);
        CREATE INDEX IF NOT EXISTS idx_created_at ON todos(created_at DESC);
        CREATE INDEX IF NOT EXISTS idx_deleted_at ON todos(deleted_at);
    `

    if _, err := db.conn.Exec(schema); err != nil {
        return err
    }

    // æ•°æ®åº“è¿ç§»: ç¡®ä¿ deleted_at åˆ—å­˜åœ¨
    if err := db.ensureDeletedAtColumn(); err != nil {
        return err
    }

    return db.ensureVersionColumn()
}

// ensureDeletedAtColumn ç¡®ä¿ deleted_at åˆ—å­˜åœ¨(å‘åå…¼å®¹)
func (db *DB) ensureDeletedAtColumn() error {
    rows, err := db.conn.Query(`PRAGMA table_info(todos);`)
    if err != nil {
        return fmt.Errorf("failed to inspect todos table: %w", err)
    }
    defer rows.Close()

    hasDeletedAtColumn := false
    for rows.Next() {
        var (
            cid        int
            name       string
            dataType   string
            notNull    int
            defaultVal sql.NullString
            pk         int
        )
        if err := rows.Scan(&cid, &name, &dataType, &notNull, &defaultVal, &pk); err != nil {
            return fmt.Errorf("failed to scan todos schema: %w", err)
        }
        if name == "deleted_at" {
            hasDeletedAtColumn = true
            break
        }
    }

    if err := rows.Err(); err != nil {
        return fmt.Errorf("failed to iterate todos schema: %w", err)
    }

    if hasDeletedAtColumn {
        return nil
    }

    // æ·»åŠ  deleted_at åˆ—
    alterStmt := `ALTER TABLE todos ADD COLUMN deleted_at DATETIME DEFAULT NULL`
    if _, err := db.conn.Exec(alterStmt); err != nil {
        return fmt.Errorf("failed to add deleted_at column: %w", err)
    }

    log.Println("Database migration: added deleted_at column")
    return nil
}
```

---

### æ­¥éª¤ 3: æ•°æ®åº“å±‚ - è½¯åˆ é™¤æ“ä½œ

> **æ³¨æ„**ï¼šå‡½æ•°å‘½åå¸¦ `Context` åç¼€ï¼Œä¸æ•™å­¦-5/6/7 ä¿æŒä¸€è‡´ã€‚
> æ‰€æœ‰å‡½æ•°æ”¯æŒ Contextï¼Œä½¿ç”¨ `ExecContext`/`QueryContext`ã€‚

åœ¨ `database/db.go` ä¸­æ·»åŠ :

```go
// SoftDeleteTodoContext è½¯åˆ é™¤å¾…åŠäº‹é¡¹(ç§»å…¥å›æ”¶ç«™ï¼Œæ”¯æŒ Context)
func (db *DB) SoftDeleteTodoContext(ctx context.Context, id int) error {
    query := `
        UPDATE todos
        SET deleted_at = ?, updated_at = ?
        WHERE id = ? AND deleted_at IS NULL
    `

    // åœ¨ Go å±‚ç”Ÿæˆæ—¶é—´æˆ³ï¼ˆç»Ÿä¸€ä½¿ç”¨ UTCï¼Œä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
    now := time.Now().UTC()
    result, err := db.conn.ExecContext(ctx, query, now, now, id)
    if err != nil {
        return fmt.Errorf("è½¯åˆ é™¤å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return fmt.Errorf("å¾…åŠäº‹é¡¹ä¸å­˜åœ¨æˆ–å·²åœ¨å›æ”¶ç«™ä¸­")
    }

    return nil
}

// RestoreTodoContext ä»å›æ”¶ç«™æ¢å¤å¾…åŠäº‹é¡¹(æ”¯æŒ Context)
func (db *DB) RestoreTodoContext(ctx context.Context, id int) error {
    query := `
        UPDATE todos
        SET deleted_at = NULL, updated_at = ?
        WHERE id = ? AND deleted_at IS NOT NULL
    `

    now := time.Now().UTC()
    result, err := db.conn.ExecContext(ctx, query, now, id)
    if err != nil {
        return fmt.Errorf("æ¢å¤å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return fmt.Errorf("å¾…åŠäº‹é¡¹ä¸åœ¨å›æ”¶ç«™ä¸­")
    }

    return nil
}

// PermanentDeleteTodoContext æ°¸ä¹…åˆ é™¤å¾…åŠäº‹é¡¹(æ”¯æŒ Context)
func (db *DB) PermanentDeleteTodoContext(ctx context.Context, id int) error {
    // åªèƒ½æ°¸ä¹…åˆ é™¤å›æ”¶ç«™ä¸­çš„é¡¹ç›®(å®‰å…¨æªæ–½)
    query := `DELETE FROM todos WHERE id = ? AND deleted_at IS NOT NULL`

    result, err := db.conn.ExecContext(ctx, query, id)
    if err != nil {
        return fmt.Errorf("æ°¸ä¹…åˆ é™¤å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return fmt.Errorf("å¾…åŠäº‹é¡¹ä¸åœ¨å›æ”¶ç«™ä¸­ï¼Œæ— æ³•æ°¸ä¹…åˆ é™¤")
    }

    return nil
}

// ListTrashContext è·å–å›æ”¶ç«™åˆ—è¡¨(æ”¯æŒ Context)
func (db *DB) ListTrashContext(ctx context.Context) ([]model.Todo, error) {
    query := `
        SELECT id, version, title, description, status, due_date,
               created_at, updated_at, completed_at, deleted_at
        FROM todos
        WHERE deleted_at IS NOT NULL
        ORDER BY deleted_at DESC
    `

    rows, err := db.conn.QueryContext(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢å›æ”¶ç«™å¤±è´¥: %w", err)
    }
    defer rows.Close()

    var todos []model.Todo
    for rows.Next() {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }

        var todo model.Todo
        var dueDate, completedAt, deletedAt sql.NullString

        err := rows.Scan(
            &todo.ID,
            &todo.Version,
            &todo.Title,
            &todo.Description,
            &todo.Status,
            &dueDate,
            &todo.CreatedAt,
            &todo.UpdatedAt,
            &completedAt,
            &deletedAt,
        )
        if err != nil {
            return nil, fmt.Errorf("æ‰«æå¤±è´¥: %w", err)
        }

        if dueDate.Valid {
            t, _ := time.Parse(time.RFC3339, dueDate.String)
            todo.DueDate = &t
        }
        if completedAt.Valid {
            t, _ := time.Parse(time.RFC3339, completedAt.String)
            todo.CompletedAt = &t
        }
        if deletedAt.Valid {
            t, _ := time.Parse(time.RFC3339, deletedAt.String)
            todo.DeletedAt = &t
        }

        todos = append(todos, todo)
    }

    if err := rows.Err(); err != nil {
        return nil, fmt.Errorf("è¿­ä»£è¡Œå¤±è´¥: %w", err)
    }

    return todos, nil
}

// ClearTrashContext æ¸…ç©ºå›æ”¶ç«™(æ”¯æŒ Context)
func (db *DB) ClearTrashContext(ctx context.Context) (int, error) {
    query := `DELETE FROM todos WHERE deleted_at IS NOT NULL`

    result, err := db.conn.ExecContext(ctx, query)
    if err != nil {
        return 0, fmt.Errorf("æ¸…ç©ºå›æ”¶ç«™å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return 0, fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    return int(rows), nil
}

// CleanupOldTrashContext æ¸…ç†è¶…è¿‡æŒ‡å®šå¤©æ•°çš„å›æ”¶ç«™æ•°æ®(æ”¯æŒ Context)
func (db *DB) CleanupOldTrashContext(ctx context.Context, days int) (int, error) {
    cutoff := time.Now().UTC().AddDate(0, 0, -days)

    query := `DELETE FROM todos WHERE deleted_at IS NOT NULL AND deleted_at < ?`

    result, err := db.conn.ExecContext(ctx, query, cutoff)
    if err != nil {
        return 0, fmt.Errorf("æ¸…ç†æ—§æ•°æ®å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return 0, fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    return int(rows), nil
}

// GetTrashStatsContext è·å–å›æ”¶ç«™ç»Ÿè®¡ä¿¡æ¯(æ”¯æŒ Context)
func (db *DB) GetTrashStatsContext(ctx context.Context) (int, error) {
    var count int
    err := db.conn.QueryRowContext(ctx, `SELECT COUNT(*) FROM todos WHERE deleted_at IS NOT NULL`).Scan(&count)
    if err != nil {
        return 0, fmt.Errorf("æŸ¥è¯¢å›æ”¶ç«™ç»Ÿè®¡å¤±è´¥: %w", err)
    }
    return count, nil
}
```

---

### æ­¥éª¤ 4: æ›´æ–°ç°æœ‰æŸ¥è¯¢(è¿‡æ»¤å·²åˆ é™¤æ•°æ®)

ä¿®æ”¹ `ListTodosContext` å‡½æ•°ï¼ˆå‡è®¾ä½ å·²ç»æŒ‰æ•™å­¦-5/6/7çš„è§„èŒƒå®ç°äº† Context ç‰ˆæœ¬ï¼‰:

```go
func (db *DB) ListTodosContext(ctx context.Context, filter TodoFilter) ([]model.Todo, int, error) {
    // ... è®¾ç½®é»˜è®¤å€¼ ...

    // å…³é”®æ”¹åŠ¨: é»˜è®¤æ’é™¤å·²åˆ é™¤çš„æ•°æ®
    baseQuery := `SELECT id, version, title, description, status, due_date,
                         created_at, updated_at, completed_at
                  FROM todos
                  WHERE deleted_at IS NULL`  // åªæŸ¥è¯¢æœªåˆ é™¤çš„
    args := []interface{}{}

    // ... å…¶ä½™ä»£ç ä¸å˜ ...
}
```

åŒæ ·æ›´æ–° `GetTodoByIDContext`:

```go
func (db *DB) GetTodoByIDContext(ctx context.Context, id int) (*model.Todo, error) {
    query := `
        SELECT id, version, title, description, status, due_date,
               created_at, updated_at, completed_at
        FROM todos
        WHERE id = ? AND deleted_at IS NULL
    `
    // ... å…¶ä½™ä»£ç ä¸å˜ï¼Œä½¿ç”¨ QueryRowContext ...
}
```

---

### æ­¥éª¤ 5: Handler å±‚å®ç°

> **æ³¨æ„**ï¼šHandler å±‚æ·»åŠ  Context è¶…æ—¶æ§åˆ¶ï¼Œä¸æ•™å­¦-5/6/7 ä¿æŒä¸€è‡´ã€‚

**ç¬¬ 1 æ­¥**ï¼šç¡®ä¿è¶…æ—¶å¸¸é‡å·²æ·»åŠ ï¼ˆå¦‚æœæ•™å­¦-5/6/7æœªæ·»åŠ ï¼‰:
```go
const (
    // ... å…¶ä»–è¶…æ—¶å¸¸é‡ ...
    TrashTimeout = 5 * time.Second // å›æ”¶ç«™æ“ä½œè¶…æ—¶
)
```

**ç¬¬ 2 æ­¥**ï¼šåœ¨ `handler/handler.go` ä¸­æ·»åŠ :

```go
// DeleteTodo åˆ é™¤å¾…åŠäº‹é¡¹(è½¯åˆ é™¤ï¼Œå¸¦è¶…æ—¶æ§åˆ¶)
func (h *Handler) DeleteTodo(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Contextï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
    ctx, cancel := context.WithTimeout(r.Context(), DeleteTimeout)
    defer cancel()

    idStr := r.PathValue("id")
    id, err := strconv.Atoi(idStr)
    if err != nil || id <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„ ID")
        return
    }

    // ä½¿ç”¨è½¯åˆ é™¤æ›¿ä»£ç¡¬åˆ é™¤ï¼ˆä½¿ç”¨ Context ç‰ˆæœ¬ï¼‰
    if err := h.db.SoftDeleteTodoContext(ctx, id); err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("SoftDeleteTodo timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "æ“ä½œè¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("SoftDeleteTodo canceled: %v", err)
            return // å®¢æˆ·ç«¯å–æ¶ˆï¼Œä¸å“åº”
        }
        log.Printf("è½¯åˆ é™¤å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "DELETE_ERROR", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Message: "å·²ç§»å…¥å›æ”¶ç«™",
    })
}

// ListTrash è·å–å›æ”¶ç«™åˆ—è¡¨(å¸¦è¶…æ—¶æ§åˆ¶)
func (h *Handler) ListTrash(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), TrashTimeout)
    defer cancel()

    todos, err := h.db.ListTrashContext(ctx)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("ListTrash timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è·å–å›æ”¶ç«™è¶…æ—¶")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("ListTrash canceled: %v", err)
            return
        }
        log.Printf("è·å–å›æ”¶ç«™å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "TRASH_ERROR", "è·å–å›æ”¶ç«™å¤±è´¥")
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data: map[string]interface{}{
            "todos": todos,
            "count": len(todos),
        },
        Message: "è·å–å›æ”¶ç«™æˆåŠŸ",
    })
}

// RestoreTodo ä»å›æ”¶ç«™æ¢å¤(å¸¦è¶…æ—¶æ§åˆ¶)
func (h *Handler) RestoreTodo(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), TrashTimeout)
    defer cancel()

    idStr := r.PathValue("id")
    id, err := strconv.Atoi(idStr)
    if err != nil || id <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„ ID")
        return
    }

    if err := h.db.RestoreTodoContext(ctx, id); err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("RestoreTodo timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "æ¢å¤æ“ä½œè¶…æ—¶")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("RestoreTodo canceled: %v", err)
            return
        }
        log.Printf("æ¢å¤å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "RESTORE_ERROR", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Message: "æ¢å¤æˆåŠŸ",
    })
}

// PermanentDeleteTodo æ°¸ä¹…åˆ é™¤(å¸¦è¶…æ—¶æ§åˆ¶)
func (h *Handler) PermanentDeleteTodo(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), TrashTimeout)
    defer cancel()

    idStr := r.PathValue("id")
    id, err := strconv.Atoi(idStr)
    if err != nil || id <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„ ID")
        return
    }

    if err := h.db.PermanentDeleteTodoContext(ctx, id); err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("PermanentDeleteTodo timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "æ°¸ä¹…åˆ é™¤è¶…æ—¶")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("PermanentDeleteTodo canceled: %v", err)
            return
        }
        log.Printf("æ°¸ä¹…åˆ é™¤å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "DELETE_ERROR", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Message: "å·²æ°¸ä¹…åˆ é™¤",
    })
}

// ClearTrash æ¸…ç©ºå›æ”¶ç«™(å¸¦è¶…æ—¶æ§åˆ¶)
func (h *Handler) ClearTrash(w http.ResponseWriter, r *http.Request) {
    ctx, cancel := context.WithTimeout(r.Context(), TrashTimeout)
    defer cancel()

    count, err := h.db.ClearTrashContext(ctx)
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("ClearTrash timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "æ¸…ç©ºå›æ”¶ç«™è¶…æ—¶")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("ClearTrash canceled: %v", err)
            return
        }
        log.Printf("æ¸…ç©ºå›æ”¶ç«™å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "CLEAR_ERROR", "æ¸…ç©ºå›æ”¶ç«™å¤±è´¥")
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data: map[string]interface{}{
            "deleted": count,
        },
        Message: fmt.Sprintf("å·²æ°¸ä¹…åˆ é™¤ %d æ¡æ•°æ®", count),
    })
}
```

---

### æ­¥éª¤ 6: æ³¨å†Œè·¯ç”±

åœ¨ `api/routes.go` çš„ `registerTodoRoutes` é—­åŒ…ä¸­æ·»åŠ ï¼ˆå‚è€ƒå½“å‰é¡¹ç›®ç»“æ„ï¼‰:

```go
registerTodoRoutes := func(base string) {
    mux.HandleFunc("GET "+base, withMiddlewares(h.ListTodos))
    mux.HandleFunc("POST "+base, withMiddlewares(h.CreateTodo))
    mux.HandleFunc("OPTIONS "+base, withMiddlewares(optionsHandler))

    mux.HandleFunc("GET "+base+"/stats", withMiddlewares(h.GetStats))

    // æ•™å­¦-5/6ï¼šæ‰¹é‡æ“ä½œè·¯ç”±ï¼ˆå¦‚æœå·²å®ç°ï¼‰
    // mux.HandleFunc("POST "+base+"/batch/complete", ...)
    // mux.HandleFunc("POST "+base+"/batch/delete", ...)

    // æ•™å­¦-7ï¼šå¯¼å…¥å¯¼å‡ºè·¯ç”±ï¼ˆå¦‚æœå·²å®ç°ï¼‰
    // mux.HandleFunc("GET "+base+"/export", ...)
    // mux.HandleFunc("POST "+base+"/import", ...)

    // æ•™å­¦-8ï¼šå›æ”¶ç«™è·¯ç”±(æ³¨æ„é¡ºåº: å…·ä½“è·¯ç”±è¦åœ¨é€šé…ç¬¦è·¯ç”±ä¹‹å‰)
    mux.HandleFunc("GET "+base+"/trash", withMiddlewares(h.ListTrash))
    mux.HandleFunc("DELETE "+base+"/trash", withMiddlewares(h.ClearTrash))
    mux.HandleFunc("OPTIONS "+base+"/trash", withMiddlewares(optionsHandler))

    // å•ä¸ªé¡¹ç›®çš„æ¢å¤å’Œæ°¸ä¹…åˆ é™¤
    mux.HandleFunc("POST "+base+"/{id}/restore", withMiddlewares(h.RestoreTodo))
    mux.HandleFunc("DELETE "+base+"/{id}/permanent", withMiddlewares(h.PermanentDeleteTodo))
    mux.HandleFunc("OPTIONS "+base+"/{id}/restore", withMiddlewares(optionsHandler))
    mux.HandleFunc("OPTIONS "+base+"/{id}/permanent", withMiddlewares(optionsHandler))

    // åŸæœ‰çš„åˆ é™¤è·¯ç”±ç°åœ¨å˜æˆè½¯åˆ é™¤
    mux.HandleFunc("PUT "+base+"/{id}", withMiddlewares(h.UpdateTodo))
    mux.HandleFunc("DELETE "+base+"/{id}", withMiddlewares(h.DeleteTodo))
    mux.HandleFunc("OPTIONS "+base+"/{id}", withMiddlewares(optionsHandler))
}
```

**è·¯ç”±é¡ºåºè¯´æ˜**ï¼š
- `/trash` å’Œ `/{id}/restore`ã€`/{id}/permanent` å¿…é¡»åœ¨ `/{id}` ä¹‹å‰æ³¨å†Œ
- Go 1.22+ ä¼šè‡ªåŠ¨é€‰æ‹©æ›´å…·ä½“çš„æ¨¡å¼
- å‚è€ƒå½“å‰é¡¹ç›®çš„ `api/routes.go` çš„æ³¨å†Œé¡ºåº

---

## âš ï¸ å…³é”®ç‚¹è§£æ

### 1. å‘åå…¼å®¹æ€§

**é—®é¢˜**: æ—§ä»£ç å¯èƒ½ç›´æ¥æŸ¥è¯¢ `todos` è¡¨

**è§£å†³æ–¹æ¡ˆ**:
```go
// æ‰€æœ‰ç°æœ‰æŸ¥è¯¢éƒ½åŠ ä¸Šæ¡ä»¶
WHERE deleted_at IS NULL

// æˆ–è€…åˆ›å»ºè§†å›¾(æ•°æ®åº“å±‚é¢çš„è§£å†³æ–¹æ¡ˆ)
CREATE VIEW active_todos AS
SELECT * FROM todos WHERE deleted_at IS NULL;
```

---

### 2. å”¯ä¸€çº¦æŸé—®é¢˜

**é—®é¢˜**: å¦‚æœæœ‰å”¯ä¸€çº¦æŸ(å¦‚ `title` å”¯ä¸€)ï¼Œè½¯åˆ é™¤åæ— æ³•åˆ›å»ºåŒåæ•°æ®

**è§£å†³æ–¹æ¡ˆ**:
```sql
-- æ–¹æ¡ˆ A: å¤åˆå”¯ä¸€çº¦æŸ
CREATE UNIQUE INDEX idx_title_unique ON todos(title) WHERE deleted_at IS NULL;

-- æ–¹æ¡ˆ B: è½¯åˆ é™¤æ—¶ä¿®æ”¹æ•°æ®
UPDATE todos SET title = title || '_deleted_' || id WHERE id = 1;
```

**å¯¹äºæœ¬é¡¹ç›®**: Todo æ²¡æœ‰å”¯ä¸€çº¦æŸï¼Œä¸å­˜åœ¨è¿™ä¸ªé—®é¢˜

---

### 3. æ€§èƒ½ä¼˜åŒ–

**æ·»åŠ ç´¢å¼•**:
```sql
-- åŠ é€ŸæŸ¥è¯¢æœªåˆ é™¤æ•°æ®
CREATE INDEX idx_deleted_at ON todos(deleted_at);

-- å¤åˆç´¢å¼•(æ›´é«˜æ•ˆ)
CREATE INDEX idx_active_todos ON todos(deleted_at, created_at DESC);
```

---

### 4. è‡ªåŠ¨æ¸…ç†ç­–ç•¥

**å®šæ—¶æ¸…ç† 30 å¤©å‰çš„å›æ”¶ç«™æ•°æ®**:
```go
// å¯ä»¥åœ¨å¯åŠ¨æ—¶æˆ–å®šæ—¶ä»»åŠ¡ä¸­æ‰§è¡Œ
func (db *DB) CleanupOldTrashContext(ctx context.Context, days int) (int, error) {
    cutoff := time.Now().UTC().AddDate(0, 0, -days)
    result, err := db.conn.ExecContext(ctx,
        `DELETE FROM todos WHERE deleted_at IS NOT NULL AND deleted_at < ?`,
        cutoff,
    )
    // ...
}

// ä½¿ç”¨
ctx := context.Background()
cleaned, _ := db.CleanupOldTrashContext(ctx, 30)  // æ¸…ç† 30 å¤©å‰çš„æ•°æ®
log.Printf("è‡ªåŠ¨æ¸…ç†äº† %d æ¡è¿‡æœŸå›æ”¶ç«™æ•°æ®", cleaned)
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1/todos"

echo "=== 1. åˆ›å»ºæµ‹è¯•æ•°æ® ==="
TODO_ID=$(curl -s -X POST "$BASE_URL" \
  -H "Content-Type: application/json" \
  -d '{"title": "æµ‹è¯•è½¯åˆ é™¤"}' | jq -r '.data.id')
echo "åˆ›å»ºäº† Todo ID: $TODO_ID"

echo -e "\n=== 2. è½¯åˆ é™¤(ç§»å…¥å›æ”¶ç«™) ==="
curl -X DELETE "$BASE_URL/$TODO_ID"

echo -e "\n\n=== 3. ç¡®è®¤ä¸»åˆ—è¡¨ä¸­å·²ä¸å­˜åœ¨ ==="
curl -s "$BASE_URL" | jq '.data.todos | length'

echo -e "\n=== 4. æŸ¥çœ‹å›æ”¶ç«™ ==="
curl -s "$BASE_URL/trash" | jq '.data'

echo -e "\n=== 5. ä»å›æ”¶ç«™æ¢å¤ ==="
curl -X POST "$BASE_URL/$TODO_ID/restore"

echo -e "\n\n=== 6. ç¡®è®¤å·²æ¢å¤åˆ°ä¸»åˆ—è¡¨ ==="
curl -s "$BASE_URL" | jq '.data.todos[] | select(.id == '$TODO_ID')'

echo -e "\n=== 7. å†æ¬¡è½¯åˆ é™¤ ==="
curl -X DELETE "$BASE_URL/$TODO_ID"

echo -e "\n\n=== 8. æ°¸ä¹…åˆ é™¤ ==="
curl -X DELETE "$BASE_URL/$TODO_ID/permanent"

echo -e "\n\n=== 9. ç¡®è®¤å›æ”¶ç«™å·²æ¸…ç©º ==="
curl -s "$BASE_URL/trash" | jq '.data.count'

echo -e "\n=== 10. æµ‹è¯•æ¸…ç©ºå›æ”¶ç«™ ==="
# å…ˆåˆ›å»ºä¸€äº›æ•°æ®æ”¾å…¥å›æ”¶ç«™
for i in {1..3}; do
  ID=$(curl -s -X POST "$BASE_URL" \
    -H "Content-Type: application/json" \
    -d "{\"title\": \"å¾…åˆ é™¤ $i\"}" | jq -r '.data.id')
  curl -s -X DELETE "$BASE_URL/$ID" > /dev/null
done

echo "å›æ”¶ç«™æ•°é‡:"
curl -s "$BASE_URL/trash" | jq '.data.count'

echo "æ¸…ç©ºå›æ”¶ç«™:"
curl -X DELETE "$BASE_URL/trash"

echo -e "\næ¸…ç©ºåå›æ”¶ç«™æ•°é‡:"
curl -s "$BASE_URL/trash" | jq '.data.count'
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

**æ•°æ®åº“å±‚**:
- [ ] `deleted_at` åˆ—è¿ç§»æˆåŠŸ
- [ ] `SoftDeleteTodoContext` å®ç°æ­£ç¡®
- [ ] `RestoreTodoContext` å®ç°æ­£ç¡®
- [ ] `PermanentDeleteTodoContext` å®ç°æ­£ç¡®
- [ ] `ListTrashContext` å®ç°æ­£ç¡®
- [ ] `ClearTrashContext` å®ç°æ­£ç¡®
- [ ] ç°æœ‰æŸ¥è¯¢å·²è¿‡æ»¤å·²åˆ é™¤æ•°æ®

**Context æ”¯æŒ**ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰:
- [ ] ä½¿ç”¨ `ExecContext` è€Œä¸æ˜¯ `Exec`
- [ ] ä½¿ç”¨ `QueryContext` è€Œä¸æ˜¯ `Query`
- [ ] ä½¿ç”¨ `QueryRowContext` è€Œä¸æ˜¯ `QueryRow`
- [ ] åœ¨å¾ªç¯ä¸­æ£€æŸ¥ `ctx.Done()`ï¼ˆ`ListTrashContext`ï¼‰
- [ ] Handler å±‚ä½¿ç”¨ `context.WithTimeout`
- [ ] åŒºåˆ† `context.DeadlineExceeded` å’Œ `context.Canceled`

**API å±‚**:
- [ ] `DELETE /todos/{id}` å˜ä¸ºè½¯åˆ é™¤
- [ ] `GET /todos/trash` è¿”å›å›æ”¶ç«™åˆ—è¡¨
- [ ] `POST /todos/{id}/restore` æ¢å¤åŠŸèƒ½
- [ ] `DELETE /todos/{id}/permanent` æ°¸ä¹…åˆ é™¤
- [ ] `DELETE /todos/trash` æ¸…ç©ºå›æ”¶ç«™
- [ ] è¶…æ—¶æƒ…å†µè¿”å›æ­£ç¡®çš„é”™è¯¯ç ï¼ˆ408ï¼‰

**ä»£ç è´¨é‡**ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰:
- [ ] å‡½æ•°å‘½åå¸¦ `Context` åç¼€
- [ ] æ—¶é—´æˆ³ä½¿ç”¨ `time.Now().UTC()`
- [ ] é”™è¯¯å¤„ç†å®Œå–„
- [ ] ä»£ç æ ¼å¼ç¬¦åˆ gofmt

**å®‰å…¨æ€§**:
- [ ] åªèƒ½æ°¸ä¹…åˆ é™¤å›æ”¶ç«™ä¸­çš„æ•°æ®
- [ ] ä¸èƒ½æ¢å¤ä¸åœ¨å›æ”¶ç«™ä¸­çš„æ•°æ®
- [ ] ä¸»åˆ—è¡¨ä¸æ˜¾ç¤ºå·²åˆ é™¤æ•°æ®

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: è½¯åˆ é™¤ä¼šå½±å“æ€§èƒ½å—?

**ç­”**: ä¼šæœ‰è½»å¾®å½±å“:
- æ¯æ¬¡æŸ¥è¯¢éƒ½è¦åŠ  `WHERE deleted_at IS NULL`
- è¡¨æ•°æ®é‡ä¼šæ¯”å®é™…æ´»è·ƒæ•°æ®å¤§

**ä¼˜åŒ–**:
1. æ·»åŠ  `deleted_at` ç´¢å¼•
2. å®šæœŸæ¸…ç†è¿‡æœŸçš„å›æ”¶ç«™æ•°æ®
3. å¯¹äºå¤§è¡¨ï¼Œè€ƒè™‘åˆ†åŒº(æ´»è·ƒæ•°æ®å’Œå·²åˆ é™¤æ•°æ®åˆ†å¼€å­˜å‚¨)

### Q2: å¦‚ä½•å¤„ç†å…³è”æ•°æ®?

**ç­”**: å¦‚æœ Todo æœ‰å­ä»»åŠ¡ï¼Œåˆ é™¤æ—¶:
- æ–¹æ¡ˆ A: çº§è”è½¯åˆ é™¤(å­ä»»åŠ¡ä¹Ÿæ ‡è®°åˆ é™¤)
- æ–¹æ¡ˆ B: é˜»æ­¢åˆ é™¤(æœ‰å­ä»»åŠ¡æ—¶ä¸å…è®¸åˆ é™¤)
- æ–¹æ¡ˆ C: å­¤å„¿æ•°æ®(å­ä»»åŠ¡ä¿ç•™ï¼Œæ˜¾ç¤º"çˆ¶ä»»åŠ¡å·²åˆ é™¤")

### Q3: å¦‚ä½•å®ç°"æ’¤é”€"åŠŸèƒ½?

**ç­”**: è½¯åˆ é™¤å¤©ç„¶æ”¯æŒæ’¤é”€:
```go
// åˆ é™¤åç«‹å³æ˜¾ç¤º"æ’¤é”€"æŒ‰é’®
// ç‚¹å‡»æ’¤é”€è°ƒç”¨ restore æ¥å£
POST /api/v1/todos/{id}/restore
```

### Q4: GDPR æ•°æ®åˆ é™¤æ€ä¹ˆå¤„ç†?

**ç­”**: GDPR è¦æ±‚"è¢«é—å¿˜æƒ"ï¼Œéœ€è¦çœŸæ­£åˆ é™¤:
```go
// æä¾›çœŸæ­£çš„æ•°æ®æ¸…é™¤æ¥å£(ä»…é™ç®¡ç†å‘˜)
func (db *DB) GDPRDeleteContext(ctx context.Context, userID int) error {
    // ç‰©ç†åˆ é™¤è¯¥ç”¨æˆ·çš„æ‰€æœ‰æ•°æ®
    _, err := db.conn.ExecContext(ctx, "DELETE FROM todos WHERE user_id = ?", userID)
    return err
}
```

---

## ğŸš€ å®ç°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: æ·»åŠ  `ensureDeletedAtColumn` è¿ç§»å‡½æ•°

**ç¬¬ 2 æ­¥**: æ›´æ–° `model.Todo` æ·»åŠ  `DeletedAt` å­—æ®µ

**ç¬¬ 3 æ­¥**: å®ç°æ•°æ®åº“å±‚çš„è½¯åˆ é™¤æ“ä½œï¼ˆå¸¦ `Context` åç¼€ï¼‰

**ç¬¬ 4 æ­¥**: ä¿®æ”¹ç°æœ‰æŸ¥è¯¢ï¼Œæ·»åŠ  `WHERE deleted_at IS NULL`

**ç¬¬ 5 æ­¥**: æ·»åŠ  Handler å±‚è¶…æ—¶å¸¸é‡ï¼ˆå¦‚ `TrashTimeout`ï¼‰

**ç¬¬ 6 æ­¥**: å®ç° Handler å±‚çš„å›æ”¶ç«™åŠŸèƒ½ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰

**ç¬¬ 7 æ­¥**: æ³¨å†Œè·¯ç”±

**ç¬¬ 8 æ­¥**: æµ‹è¯•æ‰€æœ‰åœºæ™¯

---

**ä¸æ•™å­¦-5/6/7çš„ä¸€è‡´æ€§**ï¼š
- **å‡½æ•°å‘½å**ï¼š`xxxContext` åç¼€
- **Context æ”¯æŒ**ï¼š`ExecContext`ã€`QueryContext`ã€`QueryRowContext`
- **æ—¶é—´æˆ³**ï¼š`time.Now().UTC()`
- **Handler è¶…æ—¶**ï¼š`context.WithTimeout` + é”™è¯¯åŒºåˆ†
- **å¾ªç¯ä¸­æ£€æŸ¥**ï¼š`ctx.Done()`

**ç°åœ¨ï¼Œå¼€å§‹å®ç°è½¯åˆ é™¤ä¸å›æ”¶ç«™åŠŸèƒ½å§ï¼è®°ä½ï¼šæ ‡è®°åˆ é™¤ã€é»˜è®¤è¿‡æ»¤ã€æä¾›æ¢å¤ã€Context æ”¯æŒã€‚** ğŸš€
