# æ•™å­¦ Part 11: å­ä»»åŠ¡/æ£€æŸ¥æ¸…å•

> **ğŸ“Œ å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / å¤æ‚æ•°æ®ç»“æ„
> **å‰ç½®è¦æ±‚**: å·²æŒæ¡åŸºç¡€ CRUDã€SQL å¤–é”®ã€Contextï¼ˆæ•™å­¦-5/6/7ï¼‰
> **å­¦ä¹ ç›®æ ‡**: ç†è§£ä¸€å¯¹å¤šå…³ç³»ã€å®ç°åµŒå¥—æ•°æ®ç»“æ„ã€è¿›åº¦è®¡ç®—
> **æ—¶é—´æŠ•å…¥**: 3-4 å°æ—¶(ç†è§£åŸç† + å®ç° + æµ‹è¯•)

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®é—®é¢˜**:
- "å‡†å¤‡é¢è¯•"è¿™ä¸ªä»»åŠ¡å¤ªå¤§ â†’ éœ€è¦æ‹†åˆ†æˆå°æ­¥éª¤
- è´­ç‰©æ¸…å•æœ‰å¤šä¸ªé¡¹ç›® â†’ é€ä¸€å‹¾é€‰
- é¡¹ç›®è¿›åº¦ä¸ç›´è§‚ â†’ æƒ³çœ‹å®Œæˆç™¾åˆ†æ¯”

**çœŸå®åœºæ™¯**:
```
ğŸ“‹ å‡†å¤‡æŠ€æœ¯é¢è¯•
â”œâ”€â”€ [ ] å¤ä¹  Go è¯­è¨€åŸºç¡€
â”œâ”€â”€ [x] åˆ· LeetCode 50 é¢˜
â”œâ”€â”€ [x] å‡†å¤‡é¡¹ç›®ä»‹ç»
â”œâ”€â”€ [ ] æ¨¡æ‹Ÿé¢è¯•
â””â”€â”€ è¿›åº¦: 50% (2/4)
```

**ä¸ºä»€ä¹ˆéœ€è¦å­ä»»åŠ¡?**
- **ä»»åŠ¡åˆ†è§£**: å¤§ä»»åŠ¡æ‹†æˆå¯æ‰§è¡Œçš„å°æ­¥éª¤
- **è¿›åº¦è¿½è¸ª**: ç›´è§‚æ˜¾ç¤ºå®Œæˆæ¯”ä¾‹
- **çµæ´»ç®¡ç†**: ç‹¬ç«‹å®Œæˆ/åˆ é™¤å­ä»»åŠ¡

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**: å•ç‹¬çš„å­ä»»åŠ¡è¡¨ + å¤–é”®å…³è”

**æ–¹æ¡ˆ A: JSON å­—æ®µå­˜å‚¨** (ç®€å•ä½†ä¸çµæ´»)
```sql
-- å­ä»»åŠ¡å­˜åœ¨ Todo çš„ JSON å­—æ®µé‡Œ
UPDATE todos SET items = '[{"content":"ä»»åŠ¡1","done":true}]' WHERE id = 1;
```
- ä¼˜ç‚¹: ä¸éœ€è¦æ–°è¡¨
- ç¼ºç‚¹: æ— æ³•å•ç‹¬æŸ¥è¯¢/æ›´æ–°å­ä»»åŠ¡

**æ–¹æ¡ˆ B: ç‹¬ç«‹è¡¨ + å¤–é”®** (æ¨è)
```sql
CREATE TABLE checklist_items (
    id INTEGER PRIMARY KEY,
    todo_id INTEGER REFERENCES todos(id),
    content TEXT NOT NULL,
    completed BOOLEAN DEFAULT 0
);
```
- ä¼˜ç‚¹: çµæ´»ï¼Œæ”¯æŒå•ç‹¬æ“ä½œ
- ç¼ºç‚¹: éœ€è¦ JOIN æŸ¥è¯¢

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£é™©**:
- åˆ é™¤ Todo æ—¶å­ä»»åŠ¡å˜æˆå­¤å„¿æ•°æ®
- æŸ¥è¯¢æ—¶å¿˜è®° JOIN â†’ å­ä»»åŠ¡ä¸¢å¤±
- N+1 æŸ¥è¯¢é—®é¢˜ â†’ æ€§èƒ½ä¸‹é™

âœ… **å®‰å…¨è®¾è®¡**:
- å¤–é”®çº¦æŸ + çº§è”åˆ é™¤
- ç»Ÿä¸€çš„æ•°æ®åŠ è½½å‡½æ•°
- æ‰¹é‡æŸ¥è¯¢å­ä»»åŠ¡

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. ä¸€å¯¹å¤šå…³ç³»è®¾è®¡

**æ•°æ®åº“è®¾è®¡**:
```
todos (çˆ¶è¡¨)
â”œâ”€â”€ id
â”œâ”€â”€ title
â””â”€â”€ ...

checklist_items (å­è¡¨)
â”œâ”€â”€ id
â”œâ”€â”€ todo_id â†’ todos.id (å¤–é”®)
â”œâ”€â”€ content
â”œâ”€â”€ completed
â””â”€â”€ position (æ’åº)
```

**å¤–é”®çº¦æŸ**:
```sql
CREATE TABLE checklist_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    todo_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    completed BOOLEAN NOT NULL DEFAULT 0,
    position INTEGER NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL,
    -- å¤–é”®: todo åˆ é™¤æ—¶ï¼Œå­ä»»åŠ¡ä¹Ÿåˆ é™¤
    FOREIGN KEY (todo_id) REFERENCES todos(id) ON DELETE CASCADE
);
```

---

### 2. SQLite å¤–é”®æ”¯æŒ

**é‡è¦**: SQLite é»˜è®¤**ä¸å¯ç”¨**å¤–é”®çº¦æŸï¼

```go
// å¿…é¡»æ˜¾å¼å¼€å¯
db.Exec("PRAGMA foreign_keys = ON")
```

**éªŒè¯å¤–é”®æ˜¯å¦ç”Ÿæ•ˆ**:
```sql
PRAGMA foreign_keys;  -- è¿”å› 1 è¡¨ç¤ºå·²å¼€å¯
```

---

### 3. N+1 æŸ¥è¯¢é—®é¢˜

**é—®é¢˜**: æŸ¥è¯¢ N ä¸ª Todoï¼Œæ¯ä¸ªéƒ½è¦å•ç‹¬æŸ¥å­ä»»åŠ¡

```go
// âŒ N+1 æŸ¥è¯¢
todos := db.ListTodos()
for _, todo := range todos {
    todo.Items = db.GetItemsByTodoID(todo.ID)  // N æ¬¡æŸ¥è¯¢
}
```

**è§£å†³æ–¹æ¡ˆ A: æ‰¹é‡æŸ¥è¯¢**
```go
// âœ… åªéœ€ 2 æ¬¡æŸ¥è¯¢
todos := db.ListTodos()
todoIDs := extractIDs(todos)
itemsMap := db.GetItemsByTodoIDs(todoIDs)  // ä¸€æ¬¡æŸ¥è¯¢æ‰€æœ‰å­ä»»åŠ¡
for i := range todos {
    todos[i].Items = itemsMap[todos[i].ID]
}
```

**è§£å†³æ–¹æ¡ˆ B: LEFT JOIN**
```sql
SELECT t.*, i.id as item_id, i.content, i.completed
FROM todos t
LEFT JOIN checklist_items i ON t.id = i.todo_id
```

---

### 4. è¿›åº¦è®¡ç®—

```go
// åœ¨æ¨¡å‹ä¸­è®¡ç®—
func (t *Todo) CalculateProgress() int {
    if len(t.Items) == 0 {
        return 0  // æˆ–è€…è¿”å› 100ï¼ˆæ²¡æœ‰å­ä»»åŠ¡è§†ä¸ºå®Œæˆï¼‰
    }

    completed := 0
    for _, item := range t.Items {
        if item.Completed {
            completed++
        }
    }

    return completed * 100 / len(t.Items)
}
```

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: å®šä¹‰æ•°æ®æ¨¡å‹

åˆ›å»º `model/checklist.go`:

```go
package model

import "time"

// ChecklistItem æ£€æŸ¥æ¸…å•é¡¹
type ChecklistItem struct {
    ID        int       `json:"id"`
    TodoID    int       `json:"todo_id"`
    Content   string    `json:"content"`
    Completed bool      `json:"completed"`
    Position  int       `json:"position"`
    CreatedAt time.Time `json:"created_at"`
}

// NewChecklistItem åˆ›å»ºæ–°çš„æ£€æŸ¥é¡¹
func NewChecklistItem(todoID int, content string) *ChecklistItem {
    return &ChecklistItem{
        TodoID:    todoID,
        Content:   content,
        Completed: false,
        Position:  0,
        CreatedAt: time.Now(),
    }
}
```

æ›´æ–° `model/todo.go`:

```go
type Todo struct {
    ID          int              `json:"id"`
    Version     int              `json:"version"`
    Title       string           `json:"title"`
    Description string           `json:"description"`
    Status      string           `json:"status"`
    DueDate     *time.Time       `json:"due_date,omitempty"`
    CreatedAt   time.Time        `json:"created_at"`
    UpdatedAt   time.Time        `json:"updated_at"`
    CompletedAt *time.Time       `json:"completed_at,omitempty"`
    DeletedAt   *time.Time       `json:"deleted_at,omitempty"`
    Items       []ChecklistItem  `json:"items,omitempty"`   // æ–°å¢: å­ä»»åŠ¡åˆ—è¡¨
    Progress    int              `json:"progress"`          // æ–°å¢: å®Œæˆè¿›åº¦ 0-100
}

// CalculateProgress è®¡ç®—å®Œæˆè¿›åº¦
func (t *Todo) CalculateProgress() {
    if len(t.Items) == 0 {
        t.Progress = 0
        return
    }

    completed := 0
    for _, item := range t.Items {
        if item.Completed {
            completed++
        }
    }

    t.Progress = completed * 100 / len(t.Items)
}
```

---

### æ­¥éª¤ 2: æ•°æ®åº“è¿ç§»

åœ¨ `database/db.go` ä¸­æ·»åŠ :

```go
func (db *DB) initSchema() error {
    // å¼€å¯å¤–é”®æ”¯æŒ(SQLite é»˜è®¤å…³é—­)
    if _, err := db.conn.Exec("PRAGMA foreign_keys = ON"); err != nil {
        return fmt.Errorf("å¯ç”¨å¤–é”®æ”¯æŒå¤±è´¥: %w", err)
    }

    schema := `
        CREATE TABLE IF NOT EXISTS todos (
            -- ... ç°æœ‰å­—æ®µ
        );

        CREATE TABLE IF NOT EXISTS checklist_items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            todo_id INTEGER NOT NULL,
            content TEXT NOT NULL,
            completed BOOLEAN NOT NULL DEFAULT 0,
            position INTEGER NOT NULL DEFAULT 0,
            created_at DATETIME NOT NULL,
            FOREIGN KEY (todo_id) REFERENCES todos(id) ON DELETE CASCADE
        );

        CREATE INDEX IF NOT EXISTS idx_checklist_todo_id ON checklist_items(todo_id);
        CREATE INDEX IF NOT EXISTS idx_checklist_position ON checklist_items(todo_id, position);
    `

    if _, err := db.conn.Exec(schema); err != nil {
        return err
    }

    // ... å…¶ä»–è¿ç§»
    return nil
}
```

---

### æ­¥éª¤ 3: æ•°æ®åº“å±‚ - å­ä»»åŠ¡æ“ä½œ

> **æ³¨æ„**ï¼šå‡½æ•°å‘½åå¸¦ `Context` åç¼€ï¼Œä½¿ç”¨å‘½åè¿”å›å€¼ï¼Œä¸æ•™å­¦-5/6/7ä¿æŒä¸€è‡´ã€‚

åˆ›å»º `database/checklist.go`:

```go
package database

import (
    "context"
    "database/sql"
    "fmt"
    "strings"
    "time"
    "todo-list/model"
)

// CreateChecklistItemContext åˆ›å»ºå­ä»»åŠ¡ï¼ˆæ”¯æŒ Contextï¼‰
// æ³¨æ„ï¼šä½¿ç”¨å‘½åè¿”å›å€¼ (err error)ï¼Œè®© defer èƒ½è®¿é—®åˆ°é”™è¯¯
func (db *DB) CreateChecklistItemContext(ctx context.Context, item *model.ChecklistItem) (err error) {
    // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
    select {
    case <-ctx.Done():
        return ctx.Err()
    default:
    }

    // è·å–å½“å‰æœ€å¤§ position
    var maxPos int
    err = db.conn.QueryRowContext(ctx,
        `SELECT COALESCE(MAX(position), -1) FROM checklist_items WHERE todo_id = ?`,
        item.TodoID,
    ).Scan(&maxPos)
    if err != nil {
        return fmt.Errorf("è·å–ä½ç½®å¤±è´¥: %w", err)
    }

    item.Position = maxPos + 1
    item.CreatedAt = time.Now().UTC()

    result, err := db.conn.ExecContext(ctx, `
        INSERT INTO checklist_items (todo_id, content, completed, position, created_at)
        VALUES (?, ?, ?, ?, ?)
    `, item.TodoID, item.Content, item.Completed, item.Position, item.CreatedAt)
    if err != nil {
        return fmt.Errorf("åˆ›å»ºå­ä»»åŠ¡å¤±è´¥: %w", err)
    }

    id, err := result.LastInsertId()
    if err != nil {
        return fmt.Errorf("è·å– ID å¤±è´¥: %w", err)
    }

    item.ID = int(id)
    return nil
}

// UpdateChecklistItemContext æ›´æ–°å­ä»»åŠ¡ï¼ˆæ”¯æŒ Contextï¼‰
func (db *DB) UpdateChecklistItemContext(ctx context.Context, item *model.ChecklistItem) error {
    result, err := db.conn.ExecContext(ctx, `
        UPDATE checklist_items
        SET content = ?, completed = ?, position = ?
        WHERE id = ?
    `, item.Content, item.Completed, item.Position, item.ID)
    if err != nil {
        return fmt.Errorf("æ›´æ–°å­ä»»åŠ¡å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return fmt.Errorf("å­ä»»åŠ¡ä¸å­˜åœ¨")
    }

    return nil
}

// ToggleChecklistItemContext åˆ‡æ¢å­ä»»åŠ¡å®ŒæˆçŠ¶æ€ï¼ˆæ”¯æŒ Contextï¼‰
func (db *DB) ToggleChecklistItemContext(ctx context.Context, id int) (*model.ChecklistItem, error) {
    result, err := db.conn.ExecContext(ctx, `
        UPDATE checklist_items
        SET completed = NOT completed
        WHERE id = ?
    `, id)
    if err != nil {
        return nil, fmt.Errorf("åˆ‡æ¢çŠ¶æ€å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return nil, fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return nil, fmt.Errorf("å­ä»»åŠ¡ä¸å­˜åœ¨")
    }

    // è¿”å›æ›´æ–°åçš„æ•°æ®
    return db.GetChecklistItemContext(ctx, id)
}

// DeleteChecklistItemContext åˆ é™¤å­ä»»åŠ¡ï¼ˆæ”¯æŒ Contextï¼‰
func (db *DB) DeleteChecklistItemContext(ctx context.Context, id int) error {
    result, err := db.conn.ExecContext(ctx, `DELETE FROM checklist_items WHERE id = ?`, id)
    if err != nil {
        return fmt.Errorf("åˆ é™¤å­ä»»åŠ¡å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return fmt.Errorf("å­ä»»åŠ¡ä¸å­˜åœ¨")
    }

    return nil
}

// GetChecklistItemContext è·å–å•ä¸ªå­ä»»åŠ¡ï¼ˆæ”¯æŒ Contextï¼‰
func (db *DB) GetChecklistItemContext(ctx context.Context, id int) (*model.ChecklistItem, error) {
    var item model.ChecklistItem
    err := db.conn.QueryRowContext(ctx, `
        SELECT id, todo_id, content, completed, position, created_at
        FROM checklist_items
        WHERE id = ?
    `, id).Scan(
        &item.ID, &item.TodoID, &item.Content,
        &item.Completed, &item.Position, &item.CreatedAt,
    )
    if err != nil {
        return nil, fmt.Errorf("è·å–å­ä»»åŠ¡å¤±è´¥: %w", err)
    }
    return &item, nil
}

// GetChecklistItemsByTodoIDContext è·å–æŸä¸ª Todo çš„æ‰€æœ‰å­ä»»åŠ¡ï¼ˆæ”¯æŒ Contextï¼‰
func (db *DB) GetChecklistItemsByTodoIDContext(ctx context.Context, todoID int) ([]model.ChecklistItem, error) {
    rows, err := db.conn.QueryContext(ctx, `
        SELECT id, todo_id, content, completed, position, created_at
        FROM checklist_items
        WHERE todo_id = ?
        ORDER BY position ASC
    `, todoID)
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢å­ä»»åŠ¡å¤±è´¥: %w", err)
    }
    defer rows.Close()

    var items []model.ChecklistItem
    for rows.Next() {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }

        var item model.ChecklistItem
        if err := rows.Scan(
            &item.ID, &item.TodoID, &item.Content,
            &item.Completed, &item.Position, &item.CreatedAt,
        ); err != nil {
            return nil, fmt.Errorf("æ‰«æå­ä»»åŠ¡å¤±è´¥: %w", err)
        }
        items = append(items, item)
    }

    return items, rows.Err()
}

// GetChecklistItemsByTodoIDsContext æ‰¹é‡è·å–å¤šä¸ª Todo çš„å­ä»»åŠ¡(è§£å†³ N+1 é—®é¢˜ï¼Œæ”¯æŒ Context)
func (db *DB) GetChecklistItemsByTodoIDsContext(ctx context.Context, todoIDs []int) (map[int][]model.ChecklistItem, error) {
    if len(todoIDs) == 0 {
        return make(map[int][]model.ChecklistItem), nil
    }

    // æ„å»º IN æŸ¥è¯¢
    placeholders := make([]string, len(todoIDs))
    args := make([]interface{}, len(todoIDs))
    for i, id := range todoIDs {
        placeholders[i] = "?"
        args[i] = id
    }

    query := fmt.Sprintf(`
        SELECT id, todo_id, content, completed, position, created_at
        FROM checklist_items
        WHERE todo_id IN (%s)
        ORDER BY todo_id, position ASC
    `, strings.Join(placeholders, ","))

    rows, err := db.conn.QueryContext(ctx, query, args...)
    if err != nil {
        return nil, fmt.Errorf("æ‰¹é‡æŸ¥è¯¢å­ä»»åŠ¡å¤±è´¥: %w", err)
    }
    defer rows.Close()

    result := make(map[int][]model.ChecklistItem)
    for rows.Next() {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }

        var item model.ChecklistItem
        if err := rows.Scan(
            &item.ID, &item.TodoID, &item.Content,
            &item.Completed, &item.Position, &item.CreatedAt,
        ); err != nil {
            return nil, fmt.Errorf("æ‰«æå­ä»»åŠ¡å¤±è´¥: %w", err)
        }
        result[item.TodoID] = append(result[item.TodoID], item)
    }

    return result, rows.Err()
}

// ReorderChecklistItemsContext é‡æ–°æ’åºå­ä»»åŠ¡ï¼ˆæ”¯æŒ Contextï¼‰
// æ³¨æ„ï¼šä½¿ç”¨å‘½åè¿”å›å€¼ (err error)ï¼Œè®© defer èƒ½è®¿é—®åˆ°é”™è¯¯
func (db *DB) ReorderChecklistItemsContext(ctx context.Context, todoID int, itemIDs []int) (err error) {
    // ä½¿ç”¨ BeginTx æ”¯æŒ Contextï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
    tx, err := db.conn.BeginTx(ctx, nil)
    if err != nil {
        return fmt.Errorf("å¼€å¯äº‹åŠ¡å¤±è´¥: %w", err)
    }

    defer func() {
        if err != nil {
            if rbErr := tx.Rollback(); rbErr != nil {
                log.Printf("å›æ»šå¤±è´¥: %v (åŸå§‹é”™è¯¯: %v)", rbErr, err)
            }
        }
    }()

    // é¢„å…ˆå£°æ˜ stmtï¼Œé¿å…ä½¿ç”¨ := å¸¦æ¥çš„æ½œåœ¨æ··æ·†ï¼ˆä¸æ•™å­¦-5/6/7é£æ ¼ä¸€è‡´ï¼‰
    var stmt *sql.Stmt
    stmt, err = tx.PrepareContext(ctx, `UPDATE checklist_items SET position = ? WHERE id = ? AND todo_id = ?`)
    if err != nil {
        return fmt.Errorf("å‡†å¤‡è¯­å¥å¤±è´¥: %w", err)
    }
    defer stmt.Close()

    for i, id := range itemIDs {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
        select {
        case <-ctx.Done():
            err = ctx.Err()  // èµ‹å€¼ç»™å‘½åè¿”å›å€¼ï¼Œè§¦å‘ defer å›æ»š
            return err
        default:
        }

        _, err = stmt.ExecContext(ctx, i, id, todoID)
        if err != nil {
            return fmt.Errorf("æ›´æ–°ä½ç½®å¤±è´¥: %w", err)
        }
    }

    if err = tx.Commit(); err != nil {
        return fmt.Errorf("æäº¤äº‹åŠ¡å¤±è´¥: %w", err)
    }

    return nil
}
```

---

### æ­¥éª¤ 4: æ›´æ–° ListTodos åŠ è½½å­ä»»åŠ¡

> **æ³¨æ„**ï¼šä½¿ç”¨ Context ç‰ˆæœ¬çš„æ‰¹é‡æŸ¥è¯¢å‡½æ•°ã€‚

åœ¨ `database/db.go` ä¸­ä¿®æ”¹:

```go
func (db *DB) ListTodosContext(ctx context.Context, filter TodoFilter) ([]model.Todo, int, error) {
    // ... ç°æœ‰æŸ¥è¯¢é€»è¾‘ ...

    todos, total, err := db.queryTodosContext(ctx, filter)
    if err != nil {
        return nil, 0, err
    }

    // æ‰¹é‡åŠ è½½å­ä»»åŠ¡(é¿å… N+1 é—®é¢˜)
    if len(todos) > 0 {
        todoIDs := make([]int, len(todos))
        for i, t := range todos {
            todoIDs[i] = t.ID
        }

        itemsMap, err := db.GetChecklistItemsByTodoIDsContext(ctx, todoIDs)
        if err != nil {
            return nil, 0, fmt.Errorf("åŠ è½½å­ä»»åŠ¡å¤±è´¥: %w", err)
        }

        for i := range todos {
            todos[i].Items = itemsMap[todos[i].ID]
            todos[i].CalculateProgress()
        }
    }

    return todos, total, nil
}
```

---

### æ­¥éª¤ 5: Handler å±‚å®ç°

> **æ³¨æ„**ï¼šHandler å±‚æ·»åŠ  Context è¶…æ—¶æ§åˆ¶ï¼Œä¸æ•™å­¦-5/6/7ä¿æŒä¸€è‡´ã€‚

**ç¬¬ 1 æ­¥**ï¼šç¡®ä¿è¶…æ—¶å¸¸é‡å·²æ·»åŠ ï¼ˆå¦‚æœæ•™å­¦-5/6/7æœªæ·»åŠ ï¼‰ï¼š
```go
const (
    // ... å…¶ä»–è¶…æ—¶å¸¸é‡ ...
    ChecklistTimeout = 3 * time.Second  // å­ä»»åŠ¡æ“ä½œè¶…æ—¶
)
```

**ç¬¬ 2 æ­¥**ï¼šåœ¨ `handler/handler.go` ä¸­æ·»åŠ :

```go
import (
    "context"
    "encoding/json"
    "errors"
    "fmt"
    "log"
    "net/http"
    "strconv"
    "strings"
    "time"
)

// ChecklistItemRequest å­ä»»åŠ¡è¯·æ±‚
type ChecklistItemRequest struct {
    Content   string `json:"content"`
    Completed *bool  `json:"completed,omitempty"`
}

// CreateChecklistItem åˆ›å»ºå­ä»»åŠ¡ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰
func (h *Handler) CreateChecklistItem(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Contextï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
    ctx, cancel := context.WithTimeout(r.Context(), ChecklistTimeout)
    defer cancel()

    todoID, err := strconv.Atoi(r.PathValue("id"))
    if err != nil || todoID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„ Todo ID")
        return
    }

    // éªŒè¯ Todo å­˜åœ¨ï¼ˆä½¿ç”¨ Context ç‰ˆæœ¬ï¼‰
    todo, err := h.db.GetTodoByIDContext(ctx, todoID)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("CreateChecklistItem timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("CreateChecklistItem canceled: %v", err)
            return // å®¢æˆ·ç«¯å–æ¶ˆï¼Œä¸å“åº”
        }
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", "Todo ä¸å­˜åœ¨")
        return
    }
    if todo == nil {
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", "Todo ä¸å­˜åœ¨")
        return
    }

    defer r.Body.Close()

    var req ChecklistItemRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, http.StatusBadRequest, "INVALID_JSON", "JSON è§£æå¤±è´¥")
        return
    }

    if strings.TrimSpace(req.Content) == "" {
        h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", "å†…å®¹ä¸èƒ½ä¸ºç©º")
        return
    }

    item := model.NewChecklistItem(todoID, strings.TrimSpace(req.Content))

    if err := h.db.CreateChecklistItemContext(ctx, item); err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("CreateChecklistItem timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("CreateChecklistItem canceled: %v", err)
            return
        }
        log.Printf("åˆ›å»ºå­ä»»åŠ¡å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "DATABASE_ERROR", "åˆ›å»ºå¤±è´¥")
        return
    }

    h.sendJSON(w, http.StatusCreated, Response{
        Success: true,
        Data:    item,
        Message: "åˆ›å»ºå­ä»»åŠ¡æˆåŠŸ",
    })
}

// UpdateChecklistItem æ›´æ–°å­ä»»åŠ¡ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰
func (h *Handler) UpdateChecklistItem(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Context
    ctx, cancel := context.WithTimeout(r.Context(), ChecklistTimeout)
    defer cancel()

    todoID, _ := strconv.Atoi(r.PathValue("id"))
    itemID, err := strconv.Atoi(r.PathValue("itemId"))
    if err != nil || itemID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„å­ä»»åŠ¡ ID")
        return
    }

    // è·å–ç°æœ‰å­ä»»åŠ¡ï¼ˆä½¿ç”¨ Context ç‰ˆæœ¬ï¼‰
    item, err := h.db.GetChecklistItemContext(ctx, itemID)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("UpdateChecklistItem timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("UpdateChecklistItem canceled: %v", err)
            return
        }
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", "å­ä»»åŠ¡ä¸å­˜åœ¨")
        return
    }

    // éªŒè¯å½’å±
    if item.TodoID != todoID {
        h.sendError(w, http.StatusBadRequest, "INVALID_RELATION", "å­ä»»åŠ¡ä¸å±äºè¯¥ Todo")
        return
    }

    defer r.Body.Close()

    var req ChecklistItemRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, http.StatusBadRequest, "INVALID_JSON", "JSON è§£æå¤±è´¥")
        return
    }

    // æ›´æ–°å­—æ®µ
    if req.Content != "" {
        item.Content = strings.TrimSpace(req.Content)
    }
    if req.Completed != nil {
        item.Completed = *req.Completed
    }

    if err := h.db.UpdateChecklistItemContext(ctx, item); err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("UpdateChecklistItem timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("UpdateChecklistItem canceled: %v", err)
            return
        }
        h.sendError(w, http.StatusInternalServerError, "DATABASE_ERROR", "æ›´æ–°å¤±è´¥")
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    item,
        Message: "æ›´æ–°æˆåŠŸ",
    })
}

// ToggleChecklistItem åˆ‡æ¢å­ä»»åŠ¡å®ŒæˆçŠ¶æ€ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰
func (h *Handler) ToggleChecklistItem(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Context
    ctx, cancel := context.WithTimeout(r.Context(), ChecklistTimeout)
    defer cancel()

    itemID, err := strconv.Atoi(r.PathValue("itemId"))
    if err != nil || itemID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„å­ä»»åŠ¡ ID")
        return
    }

    item, err := h.db.ToggleChecklistItemContext(ctx, itemID)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("ToggleChecklistItem timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("ToggleChecklistItem canceled: %v", err)
            return
        }
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    item,
        Message: "çŠ¶æ€å·²åˆ‡æ¢",
    })
}

// DeleteChecklistItem åˆ é™¤å­ä»»åŠ¡ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰
func (h *Handler) DeleteChecklistItem(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Context
    ctx, cancel := context.WithTimeout(r.Context(), ChecklistTimeout)
    defer cancel()

    itemID, err := strconv.Atoi(r.PathValue("itemId"))
    if err != nil || itemID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„å­ä»»åŠ¡ ID")
        return
    }

    if err := h.db.DeleteChecklistItemContext(ctx, itemID); err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("DeleteChecklistItem timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "è¯·æ±‚è¶…æ—¶ï¼Œè¯·ç¨åé‡è¯•")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("DeleteChecklistItem canceled: %v", err)
            return
        }
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Message: "åˆ é™¤æˆåŠŸ",
    })
}
```

---

### æ­¥éª¤ 6: æ³¨å†Œè·¯ç”±

åœ¨ `api/routes.go` ä¸­æ·»åŠ :

```go
// å­ä»»åŠ¡è·¯ç”±ï¼ˆåœ¨ /{id} ä¹‹å‰æ³¨å†Œï¼‰
mux.HandleFunc("POST "+base+"/{id}/items", withMiddlewares(h.CreateChecklistItem))
mux.HandleFunc("PUT "+base+"/{id}/items/{itemId}", withMiddlewares(h.UpdateChecklistItem))
mux.HandleFunc("POST "+base+"/{id}/items/{itemId}/toggle", withMiddlewares(h.ToggleChecklistItem))
mux.HandleFunc("DELETE "+base+"/{id}/items/{itemId}", withMiddlewares(h.DeleteChecklistItem))
mux.HandleFunc("OPTIONS "+base+"/{id}/items", withMiddlewares(optionsHandler))
mux.HandleFunc("OPTIONS "+base+"/{id}/items/{itemId}", withMiddlewares(optionsHandler))
mux.HandleFunc("OPTIONS "+base+"/{id}/items/{itemId}/toggle", withMiddlewares(optionsHandler))
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1/todos"

echo "=== 1. åˆ›å»º Todo ==="
TODO_ID=$(curl -s -X POST "$BASE_URL" \
  -H "Content-Type: application/json" \
  -d '{"title": "å­¦ä¹  Go è¯­è¨€"}' | jq -r '.data.id')
echo "Todo ID: $TODO_ID"

echo -e "\n=== 2. æ·»åŠ å­ä»»åŠ¡ ==="
curl -s -X POST "$BASE_URL/$TODO_ID/items" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹ åŸºç¡€è¯­æ³•"}' | jq '.data'

ITEM_ID=$(curl -s -X POST "$BASE_URL/$TODO_ID/items" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹ å¹¶å‘ç¼–ç¨‹"}' | jq -r '.data.id')

curl -s -X POST "$BASE_URL/$TODO_ID/items" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹ ç½‘ç»œç¼–ç¨‹"}' > /dev/null

echo "å­ä»»åŠ¡ ID: $ITEM_ID"

echo -e "\n=== 3. æŸ¥çœ‹ Todo(åŒ…å«å­ä»»åŠ¡å’Œè¿›åº¦) ==="
curl -s "$BASE_URL" | jq '.data.todos[0] | {title, progress, items}'

echo -e "\n=== 4. åˆ‡æ¢å­ä»»åŠ¡çŠ¶æ€ ==="
curl -s -X POST "$BASE_URL/$TODO_ID/items/$ITEM_ID/toggle" | jq '.data.completed'

echo -e "\n=== 5. å†æ¬¡æŸ¥çœ‹è¿›åº¦ ==="
curl -s "$BASE_URL" | jq '.data.todos[0] | {title, progress, items: [.items[] | {content, completed}]}'

echo -e "\n=== 6. æ›´æ–°å­ä»»åŠ¡å†…å®¹ ==="
curl -s -X PUT "$BASE_URL/$TODO_ID/items/$ITEM_ID" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹  goroutine å’Œ channel"}' | jq '.data'

echo -e "\n=== 7. åˆ é™¤å­ä»»åŠ¡ ==="
curl -s -X DELETE "$BASE_URL/$TODO_ID/items/$ITEM_ID"

echo -e "\n=== 8. åˆ é™¤ Todo(å­ä»»åŠ¡åº”è¯¥çº§è”åˆ é™¤) ==="
curl -s -X DELETE "$BASE_URL/$TODO_ID"

# éªŒè¯å­ä»»åŠ¡å·²åˆ é™¤(ç›´æ¥æŸ¥æ•°æ®åº“)
# sqlite3 todos.db "SELECT COUNT(*) FROM checklist_items WHERE todo_id=$TODO_ID"
```

### é¢„æœŸè¾“å‡º

```json
// åŒ…å«å­ä»»åŠ¡çš„ Todo
{
  "title": "å­¦ä¹  Go è¯­è¨€",
  "progress": 33,
  "items": [
    {"content": "å­¦ä¹ åŸºç¡€è¯­æ³•", "completed": false},
    {"content": "å­¦ä¹ å¹¶å‘ç¼–ç¨‹", "completed": true},
    {"content": "å­¦ä¹ ç½‘ç»œç¼–ç¨‹", "completed": false}
  ]
}
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

**æ•°æ®åº“å±‚**:
- [ ] `checklist_items` è¡¨åˆ›å»ºæˆåŠŸ
- [ ] å¤–é”®çº¦æŸç”Ÿæ•ˆ(`PRAGMA foreign_keys = ON`)
- [ ] `CreateChecklistItemContext` è‡ªåŠ¨è®¾ç½® position
- [ ] `ToggleChecklistItemContext` åˆ‡æ¢çŠ¶æ€
- [ ] `GetChecklistItemsByTodoIDsContext` æ‰¹é‡æŸ¥è¯¢
- [ ] `ReorderChecklistItemsContext` é‡æ–°æ’åº

**æ¨¡å‹å±‚**:
- [ ] `ChecklistItem` ç»“æ„ä½“å®šä¹‰
- [ ] `Todo.Items` å­—æ®µ
- [ ] `Todo.Progress` è®¡ç®—
- [ ] `CalculateProgress()` æ–¹æ³•

**API å±‚**:
- [ ] `POST /todos/{id}/items` åˆ›å»ºå­ä»»åŠ¡
- [ ] `PUT /todos/{id}/items/{itemId}` æ›´æ–°
- [ ] `POST /todos/{id}/items/{itemId}/toggle` åˆ‡æ¢çŠ¶æ€
- [ ] `DELETE /todos/{id}/items/{itemId}` åˆ é™¤

**Context æ”¯æŒ**ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰:
- [ ] æ•°æ®åº“å‡½æ•°ä½¿ç”¨ `xxxContext` å‘½ååç¼€
- [ ] ä½¿ç”¨ `BeginTx(ctx, nil)` è€Œä¸æ˜¯ `Begin()`
- [ ] ä½¿ç”¨ `ExecContext`ã€`QueryContext`ã€`PrepareContext`
- [ ] åœ¨å¾ªç¯ä¸­æ£€æŸ¥ `ctx.Done()`
- [ ] Handler å±‚ä½¿ç”¨ `context.WithTimeout`
- [ ] åŒºåˆ† `context.DeadlineExceeded` å’Œ `context.Canceled`

**ä»£ç è´¨é‡**ï¼ˆä¸æ•™å­¦-5/6/7ä¸€è‡´ï¼‰:
- [ ] ä½¿ç”¨å‘½åè¿”å›å€¼ `(err error)`
- [ ] é¢„å…ˆå£°æ˜å˜é‡ `var stmt *sql.Stmt`
- [ ] å¾ªç¯å†…ä½¿ç”¨ `=` èµ‹å€¼ï¼Œä¸ä½¿ç”¨ `:=`
- [ ] `ctx.Done()` åˆ†æ”¯æ­£ç¡®èµ‹å€¼ `err = ctx.Err()` åå† return
- [ ] å®šä¹‰è¶…æ—¶å¸¸é‡ï¼ˆå¦‚ `ChecklistTimeout`ï¼‰

**æ€§èƒ½**:
- [ ] ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢é¿å… N+1 é—®é¢˜
- [ ] æ·»åŠ  `todo_id` ç´¢å¼•

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: ä¸ºä»€ä¹ˆç”¨ç‹¬ç«‹è¡¨è€Œä¸æ˜¯ JSON å­—æ®µ?

**ç­”**:
- ç‹¬ç«‹è¡¨æ”¯æŒå•ç‹¬æŸ¥è¯¢/æ›´æ–°å­ä»»åŠ¡
- å¯ä»¥åˆ©ç”¨æ•°æ®åº“ç´¢å¼•
- å¤–é”®çº¦æŸä¿è¯æ•°æ®å®Œæ•´æ€§
- æ›´å®¹æ˜“åšå¤æ‚æŸ¥è¯¢(å¦‚"æŸ¥æ‰¾æ‰€æœ‰æœªå®Œæˆçš„å­ä»»åŠ¡")

### Q2: åˆ é™¤ Todo æ—¶å­ä»»åŠ¡æ€ä¹ˆåŠ?

**ç­”**: ä½¿ç”¨å¤–é”®çš„çº§è”åˆ é™¤
```sql
FOREIGN KEY (todo_id) REFERENCES todos(id) ON DELETE CASCADE
```

### Q3: å¦‚ä½•å®ç°æ‹–æ‹½æ’åº?

**ç­”**:
1. å‰ç«¯å‘é€æ–°çš„é¡ºåº `[id3, id1, id2]`
2. åç«¯æ‰¹é‡æ›´æ–° position
```go
// POST /todos/{id}/items/reorder
// Body: {"ids": [3, 1, 2]}
db.ReorderChecklistItemsContext(ctx, todoID, itemIDs)
```

### Q4: å­ä»»åŠ¡å…¨éƒ¨å®Œæˆæ—¶è‡ªåŠ¨å®Œæˆ Todo?

**ç­”**: å¯ä»¥åœ¨æ›´æ–°å­ä»»åŠ¡åæ£€æŸ¥
```go
func (h *Handler) afterItemUpdate(ctx context.Context, todoID int) {
    items, _ := h.db.GetChecklistItemsByTodoIDContext(ctx, todoID)
    allCompleted := len(items) > 0
    for _, item := range items {
        if !item.Completed {
            allCompleted = false
            break
        }
    }
    if allCompleted {
        h.db.CompleteTodoContext(ctx, todoID)
    }
}
```

---

## ğŸš€ å®ç°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: åˆ›å»º `model/checklist.go`ï¼Œå®šä¹‰ `ChecklistItem`

**ç¬¬ 2 æ­¥**: æ›´æ–° `model/todo.go`ï¼Œæ·»åŠ  `Items` å’Œ `Progress`

**ç¬¬ 3 æ­¥**: åœ¨ `database/db.go` ä¸­æ·»åŠ å»ºè¡¨è¯­å¥

**ç¬¬ 4 æ­¥**: åˆ›å»º `database/checklist.go`ï¼Œå®ç° CRUD
- æ‰€æœ‰å‡½æ•°ä½¿ç”¨ `xxxContext` å‘½ååç¼€
- ä½¿ç”¨ `BeginTx`ã€`ExecContext`ã€`QueryContext`ã€`PrepareContext`
- ä½¿ç”¨å‘½åè¿”å›å€¼å’Œé¢„å…ˆå£°æ˜å˜é‡

**ç¬¬ 5 æ­¥**: æ›´æ–° `ListTodosContext` æ‰¹é‡åŠ è½½å­ä»»åŠ¡

**ç¬¬ 6 æ­¥**: å®ç° Handler å’Œè·¯ç”±
- æ·»åŠ  `ChecklistTimeout` è¶…æ—¶å¸¸é‡
- ä½¿ç”¨ `context.WithTimeout`
- åŒºåˆ†è¶…æ—¶/å–æ¶ˆé”™è¯¯

**ç¬¬ 7 æ­¥**: æµ‹è¯•æ‰€æœ‰åœºæ™¯

---

**ä¸æ•™å­¦-5/6/7çš„ä¸€è‡´æ€§**ï¼š
- **å‡½æ•°å‘½å**ï¼š`xxxContext` åç¼€
- **äº‹åŠ¡å¤„ç†**ï¼š`BeginTx(ctx, nil)` + `defer Rollback`
- **SQL æ‰§è¡Œ**ï¼š`ExecContext`ã€`QueryContext`ã€`PrepareContext`
- **å‘½åè¿”å›å€¼**ï¼š`(err error)`
- **é¢„å…ˆå£°æ˜å˜é‡**ï¼š`var stmt *sql.Stmt`ï¼Œå¾ªç¯å†…ç”¨ `=` èµ‹å€¼
- **ctx.Done() å¤„ç†**ï¼šæ­£ç¡®èµ‹å€¼ `err = ctx.Err()` åå† return
- **è¶…æ—¶æ§åˆ¶**ï¼š`context.WithTimeout` + é”™è¯¯åŒºåˆ†

**ç°åœ¨ï¼Œå¼€å§‹å®ç°å­ä»»åŠ¡åŠŸèƒ½å§ï¼è®°ä½ï¼šå¤–é”®çº¦æŸã€Context æ”¯æŒã€æ‰¹é‡æŸ¥è¯¢ã€è¿›åº¦è®¡ç®—ã€‚** ğŸš€
