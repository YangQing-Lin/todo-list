# æ•™å­¦ Part 11: å­ä»»åŠ¡/æ£€æŸ¥æ¸…å•

> **å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / å¤æ‚æ•°æ®ç»“æ„
> **å‰ç½®è¦æ±‚**: å·²æŒæ¡åŸºç¡€ CRUDã€SQL å¤–é”®
> **å­¦ä¹ ç›®æ ‡**: ç†è§£ä¸€å¯¹å¤šå…³ç³»ã€å®ç°åµŒå¥—æ•°æ®ç»“æ„ã€è¿›åº¦è®¡ç®—
> **æ—¶é—´æŠ•å…¥**: 3-4 å°æ—¶(ç†è§£åŸç† + å®ç° + æµ‹è¯•)

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®é—®é¢˜**:
- "å‡†å¤‡é¢è¯•"è¿™ä¸ªä»»åŠ¡å¤ªå¤§ â†’ éœ€è¦æ‹†åˆ†æˆå°æ­¥éª¤
- è´­ç‰©æ¸…å•æœ‰å¤šä¸ªé¡¹ç›® â†’ é€ä¸€å‹¾é€‰
- é¡¹ç›®è¿›åº¦ä¸ç›´è§‚ â†’ æƒ³çœ‹å®Œæˆç™¾åˆ†æ¯”

**çœŸå®åœºæ™¯**:
```
ğŸ“‹ å‡†å¤‡æŠ€æœ¯é¢è¯•
â”œâ”€â”€ [ ] å¤ä¹  Go è¯­è¨€åŸºç¡€
â”œâ”€â”€ [x] åˆ· LeetCode 50 é¢˜
â”œâ”€â”€ [x] å‡†å¤‡é¡¹ç›®ä»‹ç»
â”œâ”€â”€ [ ] æ¨¡æ‹Ÿé¢è¯•
â””â”€â”€ è¿›åº¦: 50% (2/4)
```

**ä¸ºä»€ä¹ˆéœ€è¦å­ä»»åŠ¡?**
- **ä»»åŠ¡åˆ†è§£**: å¤§ä»»åŠ¡æ‹†æˆå¯æ‰§è¡Œçš„å°æ­¥éª¤
- **è¿›åº¦è¿½è¸ª**: ç›´è§‚æ˜¾ç¤ºå®Œæˆæ¯”ä¾‹
- **çµæ´»ç®¡ç†**: ç‹¬ç«‹å®Œæˆ/åˆ é™¤å­ä»»åŠ¡

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**: å•ç‹¬çš„å­ä»»åŠ¡è¡¨ + å¤–é”®å…³è”

**æ–¹æ¡ˆ A: JSON å­—æ®µå­˜å‚¨** (ç®€å•ä½†ä¸çµæ´»)
```sql
-- å­ä»»åŠ¡å­˜åœ¨ Todo çš„ JSON å­—æ®µé‡Œ
UPDATE todos SET items = '[{"content":"ä»»åŠ¡1","done":true}]' WHERE id = 1;
```
- ä¼˜ç‚¹: ä¸éœ€è¦æ–°è¡¨
- ç¼ºç‚¹: æ— æ³•å•ç‹¬æŸ¥è¯¢/æ›´æ–°å­ä»»åŠ¡

**æ–¹æ¡ˆ B: ç‹¬ç«‹è¡¨ + å¤–é”®** (æ¨è)
```sql
CREATE TABLE checklist_items (
    id INTEGER PRIMARY KEY,
    todo_id INTEGER REFERENCES todos(id),
    content TEXT NOT NULL,
    completed BOOLEAN DEFAULT 0
);
```
- ä¼˜ç‚¹: çµæ´»ï¼Œæ”¯æŒå•ç‹¬æ“ä½œ
- ç¼ºç‚¹: éœ€è¦ JOIN æŸ¥è¯¢

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£é™©**:
- åˆ é™¤ Todo æ—¶å­ä»»åŠ¡å˜æˆå­¤å„¿æ•°æ®
- æŸ¥è¯¢æ—¶å¿˜è®° JOIN â†’ å­ä»»åŠ¡ä¸¢å¤±
- N+1 æŸ¥è¯¢é—®é¢˜ â†’ æ€§èƒ½ä¸‹é™

âœ… **å®‰å…¨è®¾è®¡**:
- å¤–é”®çº¦æŸ + çº§è”åˆ é™¤
- ç»Ÿä¸€çš„æ•°æ®åŠ è½½å‡½æ•°
- æ‰¹é‡æŸ¥è¯¢å­ä»»åŠ¡

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. ä¸€å¯¹å¤šå…³ç³»è®¾è®¡

**æ•°æ®åº“è®¾è®¡**:
```
todos (çˆ¶è¡¨)
â”œâ”€â”€ id
â”œâ”€â”€ title
â””â”€â”€ ...

checklist_items (å­è¡¨)
â”œâ”€â”€ id
â”œâ”€â”€ todo_id â†’ todos.id (å¤–é”®)
â”œâ”€â”€ content
â”œâ”€â”€ completed
â””â”€â”€ position (æ’åº)
```

**å¤–é”®çº¦æŸ**:
```sql
CREATE TABLE checklist_items (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    todo_id INTEGER NOT NULL,
    content TEXT NOT NULL,
    completed BOOLEAN NOT NULL DEFAULT 0,
    position INTEGER NOT NULL DEFAULT 0,
    created_at DATETIME NOT NULL,
    -- å¤–é”®: todo åˆ é™¤æ—¶ï¼Œå­ä»»åŠ¡ä¹Ÿåˆ é™¤
    FOREIGN KEY (todo_id) REFERENCES todos(id) ON DELETE CASCADE
);
```

---

### 2. SQLite å¤–é”®æ”¯æŒ

**é‡è¦**: SQLite é»˜è®¤**ä¸å¯ç”¨**å¤–é”®çº¦æŸï¼

```go
// å¿…é¡»æ˜¾å¼å¼€å¯
db.Exec("PRAGMA foreign_keys = ON")
```

**éªŒè¯å¤–é”®æ˜¯å¦ç”Ÿæ•ˆ**:
```sql
PRAGMA foreign_keys;  -- è¿”å› 1 è¡¨ç¤ºå·²å¼€å¯
```

---

### 3. N+1 æŸ¥è¯¢é—®é¢˜

**é—®é¢˜**: æŸ¥è¯¢ N ä¸ª Todoï¼Œæ¯ä¸ªéƒ½è¦å•ç‹¬æŸ¥å­ä»»åŠ¡

```go
// âŒ N+1 æŸ¥è¯¢
todos := db.ListTodos()
for _, todo := range todos {
    todo.Items = db.GetItemsByTodoID(todo.ID)  // N æ¬¡æŸ¥è¯¢
}
```

**è§£å†³æ–¹æ¡ˆ A: æ‰¹é‡æŸ¥è¯¢**
```go
// âœ… åªéœ€ 2 æ¬¡æŸ¥è¯¢
todos := db.ListTodos()
todoIDs := extractIDs(todos)
itemsMap := db.GetItemsByTodoIDs(todoIDs)  // ä¸€æ¬¡æŸ¥è¯¢æ‰€æœ‰å­ä»»åŠ¡
for i := range todos {
    todos[i].Items = itemsMap[todos[i].ID]
}
```

**è§£å†³æ–¹æ¡ˆ B: LEFT JOIN**
```sql
SELECT t.*, i.id as item_id, i.content, i.completed
FROM todos t
LEFT JOIN checklist_items i ON t.id = i.todo_id
```

---

### 4. è¿›åº¦è®¡ç®—

```go
// åœ¨æ¨¡å‹ä¸­è®¡ç®—
func (t *Todo) CalculateProgress() int {
    if len(t.Items) == 0 {
        return 0  // æˆ–è€…è¿”å› 100ï¼ˆæ²¡æœ‰å­ä»»åŠ¡è§†ä¸ºå®Œæˆï¼‰
    }

    completed := 0
    for _, item := range t.Items {
        if item.Completed {
            completed++
        }
    }

    return completed * 100 / len(t.Items)
}
```

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: å®šä¹‰æ•°æ®æ¨¡å‹

åˆ›å»º `model/checklist.go`:

```go
package model

import "time"

// ChecklistItem æ£€æŸ¥æ¸…å•é¡¹
type ChecklistItem struct {
    ID        int       `json:"id"`
    TodoID    int       `json:"todo_id"`
    Content   string    `json:"content"`
    Completed bool      `json:"completed"`
    Position  int       `json:"position"`
    CreatedAt time.Time `json:"created_at"`
}

// NewChecklistItem åˆ›å»ºæ–°çš„æ£€æŸ¥é¡¹
func NewChecklistItem(todoID int, content string) *ChecklistItem {
    return &ChecklistItem{
        TodoID:    todoID,
        Content:   content,
        Completed: false,
        Position:  0,
        CreatedAt: time.Now(),
    }
}
```

æ›´æ–° `model/todo.go`:

```go
type Todo struct {
    ID          int              `json:"id"`
    Version     int              `json:"version"`
    Title       string           `json:"title"`
    Description string           `json:"description"`
    Status      string           `json:"status"`
    DueDate     *time.Time       `json:"due_date,omitempty"`
    CreatedAt   time.Time        `json:"created_at"`
    UpdatedAt   time.Time        `json:"updated_at"`
    CompletedAt *time.Time       `json:"completed_at,omitempty"`
    DeletedAt   *time.Time       `json:"deleted_at,omitempty"`
    Items       []ChecklistItem  `json:"items,omitempty"`   // æ–°å¢: å­ä»»åŠ¡åˆ—è¡¨
    Progress    int              `json:"progress"`          // æ–°å¢: å®Œæˆè¿›åº¦ 0-100
}

// CalculateProgress è®¡ç®—å®Œæˆè¿›åº¦
func (t *Todo) CalculateProgress() {
    if len(t.Items) == 0 {
        t.Progress = 0
        return
    }

    completed := 0
    for _, item := range t.Items {
        if item.Completed {
            completed++
        }
    }

    t.Progress = completed * 100 / len(t.Items)
}
```

---

### æ­¥éª¤ 2: æ•°æ®åº“è¿ç§»

åœ¨ `database/db.go` ä¸­æ·»åŠ :

```go
func (db *DB) initSchema() error {
    // å¼€å¯å¤–é”®æ”¯æŒ(SQLite é»˜è®¤å…³é—­)
    if _, err := db.conn.Exec("PRAGMA foreign_keys = ON"); err != nil {
        return fmt.Errorf("å¯ç”¨å¤–é”®æ”¯æŒå¤±è´¥: %w", err)
    }

    schema := `
        CREATE TABLE IF NOT EXISTS todos (
            -- ... ç°æœ‰å­—æ®µ
        );

        CREATE TABLE IF NOT EXISTS checklist_items (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            todo_id INTEGER NOT NULL,
            content TEXT NOT NULL,
            completed BOOLEAN NOT NULL DEFAULT 0,
            position INTEGER NOT NULL DEFAULT 0,
            created_at DATETIME NOT NULL,
            FOREIGN KEY (todo_id) REFERENCES todos(id) ON DELETE CASCADE
        );

        CREATE INDEX IF NOT EXISTS idx_checklist_todo_id ON checklist_items(todo_id);
        CREATE INDEX IF NOT EXISTS idx_checklist_position ON checklist_items(todo_id, position);
    `

    if _, err := db.conn.Exec(schema); err != nil {
        return err
    }

    // ... å…¶ä»–è¿ç§»
    return nil
}
```

---

### æ­¥éª¤ 3: æ•°æ®åº“å±‚ - å­ä»»åŠ¡æ“ä½œ

åˆ›å»º `database/checklist.go`:

```go
package database

import (
    "fmt"
    "time"
    "todo-list/model"
)

// CreateChecklistItem åˆ›å»ºå­ä»»åŠ¡
func (db *DB) CreateChecklistItem(item *model.ChecklistItem) error {
    // è·å–å½“å‰æœ€å¤§ position
    var maxPos int
    err := db.conn.QueryRow(
        `SELECT COALESCE(MAX(position), -1) FROM checklist_items WHERE todo_id = ?`,
        item.TodoID,
    ).Scan(&maxPos)
    if err != nil {
        return fmt.Errorf("è·å–ä½ç½®å¤±è´¥: %w", err)
    }

    item.Position = maxPos + 1
    item.CreatedAt = time.Now()

    result, err := db.conn.Exec(`
        INSERT INTO checklist_items (todo_id, content, completed, position, created_at)
        VALUES (?, ?, ?, ?, ?)
    `, item.TodoID, item.Content, item.Completed, item.Position, item.CreatedAt)
    if err != nil {
        return fmt.Errorf("åˆ›å»ºå­ä»»åŠ¡å¤±è´¥: %w", err)
    }

    id, err := result.LastInsertId()
    if err != nil {
        return fmt.Errorf("è·å– ID å¤±è´¥: %w", err)
    }

    item.ID = int(id)
    return nil
}

// UpdateChecklistItem æ›´æ–°å­ä»»åŠ¡
func (db *DB) UpdateChecklistItem(item *model.ChecklistItem) error {
    result, err := db.conn.Exec(`
        UPDATE checklist_items
        SET content = ?, completed = ?, position = ?
        WHERE id = ?
    `, item.Content, item.Completed, item.Position, item.ID)
    if err != nil {
        return fmt.Errorf("æ›´æ–°å­ä»»åŠ¡å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return fmt.Errorf("å­ä»»åŠ¡ä¸å­˜åœ¨")
    }

    return nil
}

// ToggleChecklistItem åˆ‡æ¢å­ä»»åŠ¡å®ŒæˆçŠ¶æ€
func (db *DB) ToggleChecklistItem(id int) (*model.ChecklistItem, error) {
    result, err := db.conn.Exec(`
        UPDATE checklist_items
        SET completed = NOT completed
        WHERE id = ?
    `, id)
    if err != nil {
        return nil, fmt.Errorf("åˆ‡æ¢çŠ¶æ€å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return nil, fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return nil, fmt.Errorf("å­ä»»åŠ¡ä¸å­˜åœ¨")
    }

    // è¿”å›æ›´æ–°åçš„æ•°æ®
    return db.GetChecklistItem(id)
}

// DeleteChecklistItem åˆ é™¤å­ä»»åŠ¡
func (db *DB) DeleteChecklistItem(id int) error {
    result, err := db.conn.Exec(`DELETE FROM checklist_items WHERE id = ?`, id)
    if err != nil {
        return fmt.Errorf("åˆ é™¤å­ä»»åŠ¡å¤±è´¥: %w", err)
    }

    rows, err := result.RowsAffected()
    if err != nil {
        return fmt.Errorf("è·å–å½±å“è¡Œæ•°å¤±è´¥: %w", err)
    }

    if rows == 0 {
        return fmt.Errorf("å­ä»»åŠ¡ä¸å­˜åœ¨")
    }

    return nil
}

// GetChecklistItem è·å–å•ä¸ªå­ä»»åŠ¡
func (db *DB) GetChecklistItem(id int) (*model.ChecklistItem, error) {
    var item model.ChecklistItem
    err := db.conn.QueryRow(`
        SELECT id, todo_id, content, completed, position, created_at
        FROM checklist_items
        WHERE id = ?
    `, id).Scan(
        &item.ID, &item.TodoID, &item.Content,
        &item.Completed, &item.Position, &item.CreatedAt,
    )
    if err != nil {
        return nil, fmt.Errorf("è·å–å­ä»»åŠ¡å¤±è´¥: %w", err)
    }
    return &item, nil
}

// GetChecklistItemsByTodoID è·å–æŸä¸ª Todo çš„æ‰€æœ‰å­ä»»åŠ¡
func (db *DB) GetChecklistItemsByTodoID(todoID int) ([]model.ChecklistItem, error) {
    rows, err := db.conn.Query(`
        SELECT id, todo_id, content, completed, position, created_at
        FROM checklist_items
        WHERE todo_id = ?
        ORDER BY position ASC
    `, todoID)
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢å­ä»»åŠ¡å¤±è´¥: %w", err)
    }
    defer rows.Close()

    var items []model.ChecklistItem
    for rows.Next() {
        var item model.ChecklistItem
        if err := rows.Scan(
            &item.ID, &item.TodoID, &item.Content,
            &item.Completed, &item.Position, &item.CreatedAt,
        ); err != nil {
            return nil, fmt.Errorf("æ‰«æå­ä»»åŠ¡å¤±è´¥: %w", err)
        }
        items = append(items, item)
    }

    return items, rows.Err()
}

// GetChecklistItemsByTodoIDs æ‰¹é‡è·å–å¤šä¸ª Todo çš„å­ä»»åŠ¡(è§£å†³ N+1 é—®é¢˜)
func (db *DB) GetChecklistItemsByTodoIDs(todoIDs []int) (map[int][]model.ChecklistItem, error) {
    if len(todoIDs) == 0 {
        return make(map[int][]model.ChecklistItem), nil
    }

    // æ„å»º IN æŸ¥è¯¢
    placeholders := make([]string, len(todoIDs))
    args := make([]interface{}, len(todoIDs))
    for i, id := range todoIDs {
        placeholders[i] = "?"
        args[i] = id
    }

    query := fmt.Sprintf(`
        SELECT id, todo_id, content, completed, position, created_at
        FROM checklist_items
        WHERE todo_id IN (%s)
        ORDER BY todo_id, position ASC
    `, strings.Join(placeholders, ","))

    rows, err := db.conn.Query(query, args...)
    if err != nil {
        return nil, fmt.Errorf("æ‰¹é‡æŸ¥è¯¢å­ä»»åŠ¡å¤±è´¥: %w", err)
    }
    defer rows.Close()

    result := make(map[int][]model.ChecklistItem)
    for rows.Next() {
        var item model.ChecklistItem
        if err := rows.Scan(
            &item.ID, &item.TodoID, &item.Content,
            &item.Completed, &item.Position, &item.CreatedAt,
        ); err != nil {
            return nil, fmt.Errorf("æ‰«æå­ä»»åŠ¡å¤±è´¥: %w", err)
        }
        result[item.TodoID] = append(result[item.TodoID], item)
    }

    return result, rows.Err()
}

// ReorderChecklistItems é‡æ–°æ’åºå­ä»»åŠ¡
func (db *DB) ReorderChecklistItems(todoID int, itemIDs []int) error {
    tx, err := db.conn.Begin()
    if err != nil {
        return fmt.Errorf("å¼€å¯äº‹åŠ¡å¤±è´¥: %w", err)
    }

    defer func() {
        if err != nil {
            tx.Rollback()
        }
    }()

    stmt, err := tx.Prepare(`UPDATE checklist_items SET position = ? WHERE id = ? AND todo_id = ?`)
    if err != nil {
        return fmt.Errorf("å‡†å¤‡è¯­å¥å¤±è´¥: %w", err)
    }
    defer stmt.Close()

    for i, id := range itemIDs {
        _, err = stmt.Exec(i, id, todoID)
        if err != nil {
            return fmt.Errorf("æ›´æ–°ä½ç½®å¤±è´¥: %w", err)
        }
    }

    return tx.Commit()
}
```

---

### æ­¥éª¤ 4: æ›´æ–° ListTodos åŠ è½½å­ä»»åŠ¡

åœ¨ `database/db.go` ä¸­ä¿®æ”¹:

```go
func (db *DB) ListTodos(filter TodoFilter) ([]model.Todo, int, error) {
    // ... ç°æœ‰æŸ¥è¯¢é€»è¾‘ ...

    todos, total, err := db.queryTodos(filter)
    if err != nil {
        return nil, 0, err
    }

    // æ‰¹é‡åŠ è½½å­ä»»åŠ¡(é¿å… N+1 é—®é¢˜)
    if len(todos) > 0 {
        todoIDs := make([]int, len(todos))
        for i, t := range todos {
            todoIDs[i] = t.ID
        }

        itemsMap, err := db.GetChecklistItemsByTodoIDs(todoIDs)
        if err != nil {
            return nil, 0, fmt.Errorf("åŠ è½½å­ä»»åŠ¡å¤±è´¥: %w", err)
        }

        for i := range todos {
            todos[i].Items = itemsMap[todos[i].ID]
            todos[i].CalculateProgress()
        }
    }

    return todos, total, nil
}
```

---

### æ­¥éª¤ 5: Handler å±‚å®ç°

åœ¨ `handler/handler.go` ä¸­æ·»åŠ :

```go
// ChecklistItemRequest å­ä»»åŠ¡è¯·æ±‚
type ChecklistItemRequest struct {
    Content   string `json:"content"`
    Completed *bool  `json:"completed,omitempty"`
}

// CreateChecklistItem åˆ›å»ºå­ä»»åŠ¡
func (h *Handler) CreateChecklistItem(w http.ResponseWriter, r *http.Request) {
    todoID, err := strconv.Atoi(r.PathValue("id"))
    if err != nil || todoID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„ Todo ID")
        return
    }

    // éªŒè¯ Todo å­˜åœ¨
    todo, err := h.db.GetTodoByID(todoID)
    if err != nil || todo == nil {
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", "Todo ä¸å­˜åœ¨")
        return
    }

    var req ChecklistItemRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, http.StatusBadRequest, "INVALID_JSON", "JSON è§£æå¤±è´¥")
        return
    }

    if strings.TrimSpace(req.Content) == "" {
        h.sendError(w, http.StatusBadRequest, "VALIDATION_ERROR", "å†…å®¹ä¸èƒ½ä¸ºç©º")
        return
    }

    item := model.NewChecklistItem(todoID, strings.TrimSpace(req.Content))

    if err := h.db.CreateChecklistItem(item); err != nil {
        log.Printf("åˆ›å»ºå­ä»»åŠ¡å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "DATABASE_ERROR", "åˆ›å»ºå¤±è´¥")
        return
    }

    h.sendJSON(w, http.StatusCreated, Response{
        Success: true,
        Data:    item,
        Message: "åˆ›å»ºå­ä»»åŠ¡æˆåŠŸ",
    })
}

// UpdateChecklistItem æ›´æ–°å­ä»»åŠ¡
func (h *Handler) UpdateChecklistItem(w http.ResponseWriter, r *http.Request) {
    todoID, _ := strconv.Atoi(r.PathValue("id"))
    itemID, err := strconv.Atoi(r.PathValue("itemId"))
    if err != nil || itemID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„å­ä»»åŠ¡ ID")
        return
    }

    // è·å–ç°æœ‰å­ä»»åŠ¡
    item, err := h.db.GetChecklistItem(itemID)
    if err != nil {
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", "å­ä»»åŠ¡ä¸å­˜åœ¨")
        return
    }

    // éªŒè¯å½’å±
    if item.TodoID != todoID {
        h.sendError(w, http.StatusBadRequest, "INVALID_RELATION", "å­ä»»åŠ¡ä¸å±äºè¯¥ Todo")
        return
    }

    var req ChecklistItemRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        h.sendError(w, http.StatusBadRequest, "INVALID_JSON", "JSON è§£æå¤±è´¥")
        return
    }

    // æ›´æ–°å­—æ®µ
    if req.Content != "" {
        item.Content = strings.TrimSpace(req.Content)
    }
    if req.Completed != nil {
        item.Completed = *req.Completed
    }

    if err := h.db.UpdateChecklistItem(item); err != nil {
        h.sendError(w, http.StatusInternalServerError, "DATABASE_ERROR", "æ›´æ–°å¤±è´¥")
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    item,
        Message: "æ›´æ–°æˆåŠŸ",
    })
}

// ToggleChecklistItem åˆ‡æ¢å­ä»»åŠ¡å®ŒæˆçŠ¶æ€
func (h *Handler) ToggleChecklistItem(w http.ResponseWriter, r *http.Request) {
    itemID, err := strconv.Atoi(r.PathValue("itemId"))
    if err != nil || itemID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„å­ä»»åŠ¡ ID")
        return
    }

    item, err := h.db.ToggleChecklistItem(itemID)
    if err != nil {
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data:    item,
        Message: "çŠ¶æ€å·²åˆ‡æ¢",
    })
}

// DeleteChecklistItem åˆ é™¤å­ä»»åŠ¡
func (h *Handler) DeleteChecklistItem(w http.ResponseWriter, r *http.Request) {
    itemID, err := strconv.Atoi(r.PathValue("itemId"))
    if err != nil || itemID <= 0 {
        h.sendError(w, http.StatusBadRequest, "INVALID_ID", "æ— æ•ˆçš„å­ä»»åŠ¡ ID")
        return
    }

    if err := h.db.DeleteChecklistItem(itemID); err != nil {
        h.sendError(w, http.StatusNotFound, "NOT_FOUND", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Message: "åˆ é™¤æˆåŠŸ",
    })
}
```

---

### æ­¥éª¤ 6: æ³¨å†Œè·¯ç”±

åœ¨ `api/routes.go` ä¸­æ·»åŠ :

```go
// å­ä»»åŠ¡è·¯ç”±
mux.HandleFunc("POST "+base+"/{id}/items", withMiddlewares(h.CreateChecklistItem))
mux.HandleFunc("PUT "+base+"/{id}/items/{itemId}", withMiddlewares(h.UpdateChecklistItem))
mux.HandleFunc("POST "+base+"/{id}/items/{itemId}/toggle", withMiddlewares(h.ToggleChecklistItem))
mux.HandleFunc("DELETE "+base+"/{id}/items/{itemId}", withMiddlewares(h.DeleteChecklistItem))
```

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1/todos"

echo "=== 1. åˆ›å»º Todo ==="
TODO_ID=$(curl -s -X POST "$BASE_URL" \
  -H "Content-Type: application/json" \
  -d '{"title": "å­¦ä¹  Go è¯­è¨€"}' | jq -r '.data.id')
echo "Todo ID: $TODO_ID"

echo -e "\n=== 2. æ·»åŠ å­ä»»åŠ¡ ==="
curl -s -X POST "$BASE_URL/$TODO_ID/items" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹ åŸºç¡€è¯­æ³•"}' | jq '.data'

ITEM_ID=$(curl -s -X POST "$BASE_URL/$TODO_ID/items" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹ å¹¶å‘ç¼–ç¨‹"}' | jq -r '.data.id')

curl -s -X POST "$BASE_URL/$TODO_ID/items" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹ ç½‘ç»œç¼–ç¨‹"}' > /dev/null

echo "å­ä»»åŠ¡ ID: $ITEM_ID"

echo -e "\n=== 3. æŸ¥çœ‹ Todo(åŒ…å«å­ä»»åŠ¡å’Œè¿›åº¦) ==="
curl -s "$BASE_URL" | jq '.data.todos[0] | {title, progress, items}'

echo -e "\n=== 4. åˆ‡æ¢å­ä»»åŠ¡çŠ¶æ€ ==="
curl -s -X POST "$BASE_URL/$TODO_ID/items/$ITEM_ID/toggle" | jq '.data.completed'

echo -e "\n=== 5. å†æ¬¡æŸ¥çœ‹è¿›åº¦ ==="
curl -s "$BASE_URL" | jq '.data.todos[0] | {title, progress, items: [.items[] | {content, completed}]}'

echo -e "\n=== 6. æ›´æ–°å­ä»»åŠ¡å†…å®¹ ==="
curl -s -X PUT "$BASE_URL/$TODO_ID/items/$ITEM_ID" \
  -H "Content-Type: application/json" \
  -d '{"content": "å­¦ä¹  goroutine å’Œ channel"}' | jq '.data'

echo -e "\n=== 7. åˆ é™¤å­ä»»åŠ¡ ==="
curl -s -X DELETE "$BASE_URL/$TODO_ID/items/$ITEM_ID"

echo -e "\n=== 8. åˆ é™¤ Todo(å­ä»»åŠ¡åº”è¯¥çº§è”åˆ é™¤) ==="
curl -s -X DELETE "$BASE_URL/$TODO_ID"

# éªŒè¯å­ä»»åŠ¡å·²åˆ é™¤(ç›´æ¥æŸ¥æ•°æ®åº“)
# sqlite3 todos.db "SELECT COUNT(*) FROM checklist_items WHERE todo_id=$TODO_ID"
```

### é¢„æœŸè¾“å‡º

```json
// åŒ…å«å­ä»»åŠ¡çš„ Todo
{
  "title": "å­¦ä¹  Go è¯­è¨€",
  "progress": 33,
  "items": [
    {"content": "å­¦ä¹ åŸºç¡€è¯­æ³•", "completed": false},
    {"content": "å­¦ä¹ å¹¶å‘ç¼–ç¨‹", "completed": true},
    {"content": "å­¦ä¹ ç½‘ç»œç¼–ç¨‹", "completed": false}
  ]
}
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

**æ•°æ®åº“å±‚**:
- [ ] `checklist_items` è¡¨åˆ›å»ºæˆåŠŸ
- [ ] å¤–é”®çº¦æŸç”Ÿæ•ˆ(`PRAGMA foreign_keys = ON`)
- [ ] `CreateChecklistItem` è‡ªåŠ¨è®¾ç½® position
- [ ] `ToggleChecklistItem` åˆ‡æ¢çŠ¶æ€
- [ ] `GetChecklistItemsByTodoIDs` æ‰¹é‡æŸ¥è¯¢
- [ ] `ReorderChecklistItems` é‡æ–°æ’åº

**æ¨¡å‹å±‚**:
- [ ] `ChecklistItem` ç»“æ„ä½“å®šä¹‰
- [ ] `Todo.Items` å­—æ®µ
- [ ] `Todo.Progress` è®¡ç®—
- [ ] `CalculateProgress()` æ–¹æ³•

**API å±‚**:
- [ ] `POST /todos/{id}/items` åˆ›å»ºå­ä»»åŠ¡
- [ ] `PUT /todos/{id}/items/{itemId}` æ›´æ–°
- [ ] `POST /todos/{id}/items/{itemId}/toggle` åˆ‡æ¢çŠ¶æ€
- [ ] `DELETE /todos/{id}/items/{itemId}` åˆ é™¤

**æ€§èƒ½**:
- [ ] ä½¿ç”¨æ‰¹é‡æŸ¥è¯¢é¿å… N+1 é—®é¢˜
- [ ] æ·»åŠ  `todo_id` ç´¢å¼•

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: ä¸ºä»€ä¹ˆç”¨ç‹¬ç«‹è¡¨è€Œä¸æ˜¯ JSON å­—æ®µ?

**ç­”**:
- ç‹¬ç«‹è¡¨æ”¯æŒå•ç‹¬æŸ¥è¯¢/æ›´æ–°å­ä»»åŠ¡
- å¯ä»¥åˆ©ç”¨æ•°æ®åº“ç´¢å¼•
- å¤–é”®çº¦æŸä¿è¯æ•°æ®å®Œæ•´æ€§
- æ›´å®¹æ˜“åšå¤æ‚æŸ¥è¯¢(å¦‚"æŸ¥æ‰¾æ‰€æœ‰æœªå®Œæˆçš„å­ä»»åŠ¡")

### Q2: åˆ é™¤ Todo æ—¶å­ä»»åŠ¡æ€ä¹ˆåŠ?

**ç­”**: ä½¿ç”¨å¤–é”®çš„çº§è”åˆ é™¤
```sql
FOREIGN KEY (todo_id) REFERENCES todos(id) ON DELETE CASCADE
```

### Q3: å¦‚ä½•å®ç°æ‹–æ‹½æ’åº?

**ç­”**:
1. å‰ç«¯å‘é€æ–°çš„é¡ºåº `[id3, id1, id2]`
2. åç«¯æ‰¹é‡æ›´æ–° position
```go
// POST /todos/{id}/items/reorder
// Body: {"ids": [3, 1, 2]}
db.ReorderChecklistItems(todoID, itemIDs)
```

### Q4: å­ä»»åŠ¡å…¨éƒ¨å®Œæˆæ—¶è‡ªåŠ¨å®Œæˆ Todo?

**ç­”**: å¯ä»¥åœ¨æ›´æ–°å­ä»»åŠ¡åæ£€æŸ¥
```go
func (h *Handler) afterItemUpdate(todoID int) {
    items, _ := h.db.GetChecklistItemsByTodoID(todoID)
    allCompleted := len(items) > 0
    for _, item := range items {
        if !item.Completed {
            allCompleted = false
            break
        }
    }
    if allCompleted {
        h.db.CompleteTodo(todoID)
    }
}
```

---

## ğŸš€ å®ç°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: åˆ›å»º `model/checklist.go`ï¼Œå®šä¹‰ `ChecklistItem`

**ç¬¬ 2 æ­¥**: æ›´æ–° `model/todo.go`ï¼Œæ·»åŠ  `Items` å’Œ `Progress`

**ç¬¬ 3 æ­¥**: åœ¨ `database/db.go` ä¸­æ·»åŠ å»ºè¡¨è¯­å¥

**ç¬¬ 4 æ­¥**: åˆ›å»º `database/checklist.go`ï¼Œå®ç° CRUD

**ç¬¬ 5 æ­¥**: æ›´æ–° `ListTodos` æ‰¹é‡åŠ è½½å­ä»»åŠ¡

**ç¬¬ 6 æ­¥**: å®ç° Handler å’Œè·¯ç”±

**ç¬¬ 7 æ­¥**: æµ‹è¯•æ‰€æœ‰åœºæ™¯

---

**ç°åœ¨ï¼Œå¼€å§‹å®ç°å­ä»»åŠ¡åŠŸèƒ½å§ï¼è®°ä½ï¼šå¤–é”®çº¦æŸã€æ‰¹é‡æŸ¥è¯¢ã€è¿›åº¦è®¡ç®—ã€‚** ğŸš€
