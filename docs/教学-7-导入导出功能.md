# æ•™å­¦ Part 7: å¯¼å…¥/å¯¼å‡ºåŠŸèƒ½

> **ğŸ“Œ å­¦ä¹ é˜¶æ®µ**: ä¸­çº§ / Go I/O ç¼–ç¨‹
> **å‰ç½®è¦æ±‚**: å·²å®Œæˆæ•™å­¦-5/6ï¼ˆäº‹åŠ¡ã€Contextã€æ‰¹é‡æ“ä½œï¼‰
> **å­¦ä¹ ç›®æ ‡**: æŒæ¡ `encoding/csv`ã€`encoding/json`ã€`io` åŒ…ã€HTTP æ–‡ä»¶ä¸‹è½½/ä¸Šä¼ 
> **æ—¶é—´æŠ•å…¥**: 3-4 å°æ—¶(ç†è§£åŸç† + å®ç° + æµ‹è¯•)

---

## ğŸ¯ åŠŸèƒ½åˆ†æ - Linus å¼æ€è€ƒ

### Linus çš„ä¸‰ä¸ªé—®é¢˜

**1. "è¿™æ˜¯ä¸ªçœŸé—®é¢˜è¿˜æ˜¯è‡†æƒ³å‡ºæ¥çš„?"**

âœ… **çœŸå®é—®é¢˜**:
- ç”¨æˆ·æƒ³å¤‡ä»½è‡ªå·±çš„å¾…åŠäº‹é¡¹æ•°æ®
- ç”¨æˆ·ä»å…¶ä»–å·¥å…·è¿ç§»æ•°æ®è¿‡æ¥
- å›¢é˜Ÿé—´å…±äº«ä»»åŠ¡æ¸…å•
- æ•°æ®åˆ†æéœ€è¦å¯¼å‡ºåˆ° Excel

**ä¸ºä»€ä¹ˆéœ€è¦å¯¼å…¥å¯¼å‡º?**
- **æ•°æ®å¯ç§»æ¤æ€§**: ç”¨æˆ·æ‹¥æœ‰è‡ªå·±çš„æ•°æ®
- **ç³»ç»Ÿé›†æˆ**: ä¸å…¶ä»–å·¥å…·äº’é€š
- **å¤‡ä»½æ¢å¤**: é˜²æ­¢æ•°æ®ä¸¢å¤±
- **æ‰¹é‡æ“ä½œ**: ä¸€æ¬¡æ€§å¯¼å…¥å¤§é‡æ•°æ®

**2. "æœ‰æ›´ç®€å•çš„æ–¹æ³•å—?"**

ğŸ’¡ **æ ¸å¿ƒæ€è·¯**: æµå¼å¤„ç† + æ ‡å‡†æ ¼å¼

**é”™è¯¯æ–¹æ³•**(å…¨éƒ¨åŠ è½½åˆ°å†…å­˜):
```go
// âŒ 10ä¸‡æ¡æ•°æ®ä¼šå ç”¨å¤§é‡å†…å­˜
todos := db.GetAllTodos()
jsonData, _ := json.Marshal(todos)
w.Write(jsonData)
```

**æ­£ç¡®æ–¹æ³•**(æµå¼å†™å…¥):
```go
// âœ… è¾¹æŸ¥è¯¢è¾¹å†™å…¥ï¼Œå†…å­˜å ç”¨æ’å®š
encoder := json.NewEncoder(w)
for _, todo := range todos {
    encoder.Encode(todo)
}
```

**3. "ä¼šç ´åä»€ä¹ˆå—?"**

âš ï¸ **æ½œåœ¨é£é™©**:
- å¯¼å…¥æ¶æ„æ•°æ®(SQL æ³¨å…¥ã€XSS)
- å¤§æ–‡ä»¶å¯¼å…¥å¯¼è‡´å†…å­˜æº¢å‡º
- å¹¶å‘å¯¼å…¥å¯¼è‡´æ•°æ®ä¸ä¸€è‡´

âœ… **å®‰å…¨è®¾è®¡**:
- è¾“å…¥éªŒè¯å’Œæ•°æ®æ¸…æ´—
- æ–‡ä»¶å¤§å°é™åˆ¶
- äº‹åŠ¡ä¿è¯åŸå­æ€§

---

## ğŸ“š æ ¸å¿ƒçŸ¥è¯†è®²è§£

### 1. Go çš„ I/O æ¨¡å‹

Go çš„ I/O è®¾è®¡åŸºäºä¸¤ä¸ªæ ¸å¿ƒæ¥å£:

```go
// io.Reader - è¯»å–æ•°æ®çš„æŠ½è±¡
type Reader interface {
    Read(p []byte) (n int, err error)
}

// io.Writer - å†™å…¥æ•°æ®çš„æŠ½è±¡
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

**ä¸ºä»€ä¹ˆè¿™ä¸ªè®¾è®¡å¾ˆä¼˜é›…?**
- `http.ResponseWriter` å®ç°äº† `io.Writer`
- `http.Request.Body` å®ç°äº† `io.Reader`
- å¯ä»¥ç›´æ¥æŠŠæ•°æ®"æµ"åˆ° HTTP å“åº”ä¸­

```go
// ç›´æ¥æŠŠ CSV æµåˆ° HTTP å“åº”
csvWriter := csv.NewWriter(w)  // w æ˜¯ http.ResponseWriter
csvWriter.Write([]string{"ID", "Title"})
csvWriter.Flush()
```

---

### 2. encoding/csv åŒ…

**CSV å†™å…¥**:
```go
import "encoding/csv"

func writeCSV(w io.Writer, todos []model.Todo) error {
    writer := csv.NewWriter(w)
    defer writer.Flush()

    // å†™å…¥è¡¨å¤´
    if err := writer.Write([]string{"ID", "æ ‡é¢˜", "çŠ¶æ€"}); err != nil {
        return err
    }

    // å†™å…¥æ•°æ®è¡Œ
    for _, todo := range todos {
        row := []string{
            strconv.Itoa(todo.ID),
            todo.Title,
            todo.Status,
        }
        if err := writer.Write(row); err != nil {
            return err
        }
    }

    return writer.Error()  // æ£€æŸ¥ç¼“å†²åŒºé”™è¯¯
}
```

**CSV è¯»å–**:
```go
func readCSV(r io.Reader) ([]model.Todo, error) {
    reader := csv.NewReader(r)

    // è·³è¿‡è¡¨å¤´
    if _, err := reader.Read(); err != nil {
        return nil, err
    }

    var todos []model.Todo
    for {
        record, err := reader.Read()
        if err == io.EOF {
            break
        }
        if err != nil {
            return nil, err
        }

        id, _ := strconv.Atoi(record[0])
        todos = append(todos, model.Todo{
            ID:     id,
            Title:  record[1],
            Status: record[2],
        })
    }

    return todos, nil
}
```

**å…³é”®ç‚¹**:
- `csv.Writer` æœ‰å†…éƒ¨ç¼“å†²åŒºï¼Œå¿…é¡»è°ƒç”¨ `Flush()`
- `csv.Reader.Read()` è¿”å› `io.EOF` è¡¨ç¤ºæ–‡ä»¶ç»“æŸ
- CSV é»˜è®¤ç”¨é€—å·åˆ†éš”ï¼Œå¯ä»¥é€šè¿‡ `writer.Comma = '\t'` æ”¹ä¸º Tab

---

### 3. encoding/json æµå¼å¤„ç†

**JSON æ•°ç»„å¯¼å‡º**(æµå¼):
```go
func exportJSON(w io.Writer, todos []model.Todo) error {
    w.Write([]byte("[\n"))

    encoder := json.NewEncoder(w)
    encoder.SetIndent("", "  ")

    for i, todo := range todos {
        if i > 0 {
            w.Write([]byte(",\n"))
        }
        if err := encoder.Encode(todo); err != nil {
            return err
        }
    }

    w.Write([]byte("]\n"))
    return nil
}
```

**JSON æ•°ç»„å¯¼å…¥**(æµå¼):
```go
func importJSON(r io.Reader) ([]model.Todo, error) {
    decoder := json.NewDecoder(r)

    // è¯»å–å¼€å§‹çš„ '['
    if _, err := decoder.Token(); err != nil {
        return nil, err
    }

    var todos []model.Todo
    for decoder.More() {
        var todo model.Todo
        if err := decoder.Decode(&todo); err != nil {
            return nil, err
        }
        todos = append(todos, todo)
    }

    return todos, nil
}
```

---

### 4. HTTP æ–‡ä»¶ä¸‹è½½

**è®¾ç½®å“åº”å¤´è§¦å‘ä¸‹è½½**:
```go
func (h *Handler) ExportTodos(w http.ResponseWriter, r *http.Request) {
    format := r.URL.Query().Get("format")

    switch format {
    case "csv":
        // å‘Šè¯‰æµè§ˆå™¨è¿™æ˜¯ä¸€ä¸ªè¦ä¸‹è½½çš„æ–‡ä»¶
        w.Header().Set("Content-Type", "text/csv; charset=utf-8")
        w.Header().Set("Content-Disposition", "attachment; filename=todos.csv")
        // æ·»åŠ  UTF-8 BOMï¼Œè®© Excel æ­£ç¡®è¯†åˆ«ä¸­æ–‡
        w.Write([]byte{0xEF, 0xBB, 0xBF})

    case "json":
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("Content-Disposition", "attachment; filename=todos.json")
    }

    // ... å†™å…¥æ•°æ®
}
```

**å…³é”®å“åº”å¤´**:
- `Content-Type`: å‘Šè¯‰æµè§ˆå™¨æ–‡ä»¶ç±»å‹
- `Content-Disposition: attachment`: è§¦å‘ä¸‹è½½è€Œä¸æ˜¯åœ¨æµè§ˆå™¨æ˜¾ç¤º
- `filename=xxx`: é»˜è®¤çš„ä¸‹è½½æ–‡ä»¶å

---

### 5. HTTP æ–‡ä»¶ä¸Šä¼ 

**å¤„ç† multipart/form-data**:
```go
func (h *Handler) ImportTodos(w http.ResponseWriter, r *http.Request) {
    // é™åˆ¶ä¸Šä¼ å¤§å°(10MB)
    r.Body = http.MaxBytesReader(w, r.Body, 10<<20)

    // è§£æ multipart è¡¨å•
    if err := r.ParseMultipartForm(10 << 20); err != nil {
        h.sendError(w, http.StatusBadRequest, "FILE_TOO_LARGE", "æ–‡ä»¶å¤ªå¤§")
        return
    }

    // è·å–ä¸Šä¼ çš„æ–‡ä»¶
    file, header, err := r.FormFile("file")
    if err != nil {
        h.sendError(w, http.StatusBadRequest, "NO_FILE", "è¯·é€‰æ‹©æ–‡ä»¶")
        return
    }
    defer file.Close()

    // æ£€æŸ¥æ–‡ä»¶ç±»å‹
    if !strings.HasSuffix(header.Filename, ".json") {
        h.sendError(w, http.StatusBadRequest, "INVALID_FORMAT", "åªæ”¯æŒ JSON æ–‡ä»¶")
        return
    }

    // è§£ææ–‡ä»¶å†…å®¹
    todos, err := parseImportFile(file)
    // ...
}
```

---

## ğŸ’» å®Œæ•´ä»£ç ç¤ºä¾‹

### æ­¥éª¤ 1: æ•°æ®åº“å±‚ - æ‰¹é‡åˆ›å»º

> **æ³¨æ„**ï¼šå‡½æ•°å‘½åå¸¦ `Context` åç¼€ï¼Œä¸é¡¹ç›®ç°æœ‰ä»£ç é£æ ¼ä¿æŒä¸€è‡´ï¼ˆå‚è€ƒæ•™å­¦-5/6ï¼‰ã€‚

åœ¨ `database/db.go` ä¸­æ·»åŠ :

```go
// ImportTodosContext æ‰¹é‡å¯¼å…¥å¾…åŠäº‹é¡¹(äº‹åŠ¡ä¿è¯ï¼Œæ”¯æŒ Context)
// æ³¨æ„ï¼šä½¿ç”¨å‘½åè¿”å›å€¼ (err error)ï¼Œè®© defer èƒ½è®¿é—®åˆ°é”™è¯¯
func (db *DB) ImportTodosContext(ctx context.Context, todos []model.Todo) (imported int, err error) {
    if len(todos) == 0 {
        return 0, nil
    }

    // é™åˆ¶å•æ¬¡å¯¼å…¥æ•°é‡
    if len(todos) > 1000 {
        return 0, fmt.Errorf("å•æ¬¡å¯¼å…¥æœ€å¤š 1000 æ¡ï¼Œå½“å‰: %d", len(todos))
    }

    // ä½¿ç”¨ BeginTx æ”¯æŒ Contextï¼ˆä¸æ•™å­¦-5/6ä¸€è‡´ï¼‰
    tx, err := db.conn.BeginTx(ctx, nil)
    if err != nil {
        return 0, fmt.Errorf("å¼€å¯äº‹åŠ¡å¤±è´¥: %w", err)
    }

    defer func() {
        if err != nil {
            if rbErr := tx.Rollback(); rbErr != nil {
                log.Printf("å›æ»šå¤±è´¥: %v (åŸå§‹é”™è¯¯: %v)", rbErr, err)
            }
        }
    }()

    stmt, err := tx.PrepareContext(ctx, `
        INSERT INTO todos (title, description, status, due_date, created_at, updated_at, version)
        VALUES (?, ?, ?, ?, ?, ?, 1)
    `)
    if err != nil {
        return 0, fmt.Errorf("å‡†å¤‡è¯­å¥å¤±è´¥: %w", err)
    }
    defer stmt.Close()

    now := time.Now().UTC()
    // imported å·²åœ¨å‘½åè¿”å›å€¼ä¸­å£°æ˜ï¼Œé»˜è®¤å€¼ä¸º 0

    for _, todo := range todos {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆï¼ˆä¸æ•™å­¦-5/6ä¸€è‡´ï¼‰
        select {
        case <-ctx.Done():
            return imported, ctx.Err()
        default:
        }

        // æ•°æ®éªŒè¯
        if todo.Title == "" {
            continue  // è·³è¿‡æ— æ•ˆæ•°æ®
        }

        // è®¾ç½®é»˜è®¤å€¼
        if todo.Status == "" {
            todo.Status = "pending"
        }
        if todo.CreatedAt.IsZero() {
            todo.CreatedAt = now
        }
        todo.UpdatedAt = now

        _, err = stmt.ExecContext(ctx,
            todo.Title,
            todo.Description,
            todo.Status,
            todo.DueDate,
            todo.CreatedAt,
            todo.UpdatedAt,
        )
        if err != nil {
            return imported, fmt.Errorf("æ’å…¥ç¬¬ %d æ¡å¤±è´¥: %w", imported+1, err)
        }
        imported++
    }

    if err = tx.Commit(); err != nil {
        return 0, fmt.Errorf("æäº¤äº‹åŠ¡å¤±è´¥: %w", err)
    }

    return imported, nil
}

// ExportTodosContext å¯¼å‡ºæ‰€æœ‰å¾…åŠäº‹é¡¹(ç”¨äºå¯¼å‡ºåŠŸèƒ½ï¼Œæ”¯æŒ Context)
func (db *DB) ExportTodosContext(ctx context.Context) ([]model.Todo, error) {
    query := `
        SELECT id, version, title, description, status, due_date,
               created_at, updated_at, completed_at
        FROM todos
        ORDER BY created_at DESC
    `

    rows, err := db.conn.QueryContext(ctx, query)
    if err != nil {
        return nil, fmt.Errorf("æŸ¥è¯¢å¤±è´¥: %w", err)
    }
    defer rows.Close()

    var todos []model.Todo
    for rows.Next() {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
        select {
        case <-ctx.Done():
            return nil, ctx.Err()
        default:
        }

        var todo model.Todo
        var dueDate, completedAt sql.NullString

        err := rows.Scan(
            &todo.ID,
            &todo.Version,
            &todo.Title,
            &todo.Description,
            &todo.Status,
            &dueDate,
            &todo.CreatedAt,
            &todo.UpdatedAt,
            &completedAt,
        )
        if err != nil {
            return nil, fmt.Errorf("æ‰«æå¤±è´¥: %w", err)
        }

        if dueDate.Valid {
            if t, parseErr := time.Parse(time.RFC3339, dueDate.String); parseErr == nil {
                todo.DueDate = &t
            }
        }
        if completedAt.Valid {
            if t, parseErr := time.Parse(time.RFC3339, completedAt.String); parseErr == nil {
                todo.CompletedAt = &t
            }
        }

        todos = append(todos, todo)
    }

    if err := rows.Err(); err != nil {
        return nil, fmt.Errorf("è¿­ä»£è¡Œå¤±è´¥: %w", err)
    }

    return todos, nil
}
```

---

### æ­¥éª¤ 2: Handler å±‚ - å¯¼å‡ºåŠŸèƒ½

> **æ³¨æ„**ï¼šHandler å±‚æ·»åŠ  Context è¶…æ—¶æ§åˆ¶ï¼Œä¸é¡¹ç›®ç°æœ‰ handlers ä¿æŒä¸€è‡´ã€‚

**ç¬¬ 1 æ­¥**ï¼šç¡®ä¿è¶…æ—¶å¸¸é‡å·²æ·»åŠ ï¼ˆå¦‚æœæ•™å­¦-5/6æœªæ·»åŠ ï¼‰ï¼š
```go
const (
    // ... å…¶ä»–è¶…æ—¶å¸¸é‡ ...
    ExportTimeout = 30 * time.Second // å¯¼å‡ºè¶…æ—¶ï¼ˆå¯èƒ½æ•°æ®é‡å¤§ï¼‰
    ImportTimeout = 60 * time.Second // å¯¼å…¥è¶…æ—¶ï¼ˆå¯èƒ½æ•°æ®é‡å¤§ï¼‰
)
```

**ç¬¬ 2 æ­¥**ï¼šåœ¨ `handler/handler.go` ä¸­æ·»åŠ å¯¼å‡ºåŠŸèƒ½:

```go
import (
    "encoding/csv"
    "encoding/json"
    "strconv"
    "strings"
)

// ExportTodos å¯¼å‡ºå¾…åŠäº‹é¡¹ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰
func (h *Handler) ExportTodos(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Contextï¼ˆå¯¼å‡ºå¯èƒ½æ•°æ®é‡å¤§ï¼Œè¶…æ—¶è®¾é•¿ä¸€äº›ï¼‰
    ctx, cancel := context.WithTimeout(r.Context(), ExportTimeout)
    defer cancel()

    format := r.URL.Query().Get("format")
    if format == "" {
        format = "json"
    }

    // è·å–æ‰€æœ‰æ•°æ®ï¼ˆä½¿ç”¨ Context ç‰ˆæœ¬ï¼‰
    todos, err := h.db.ExportTodosContext(ctx)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6ä¸€è‡´ï¼‰
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("ExportTodos timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "å¯¼å‡ºè¶…æ—¶ï¼Œæ•°æ®é‡è¿‡å¤§")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("ExportTodos canceled: %v", err)
            return // å®¢æˆ·ç«¯å–æ¶ˆï¼Œä¸å“åº”
        }
        log.Printf("å¯¼å‡ºå¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "EXPORT_ERROR", "å¯¼å‡ºå¤±è´¥")
        return
    }

    switch format {
    case "csv":
        h.exportCSV(w, todos)
    case "json":
        h.exportJSON(w, todos)
    default:
        h.sendError(w, http.StatusBadRequest, "INVALID_FORMAT", "ä¸æ”¯æŒçš„æ ¼å¼ï¼Œè¯·ä½¿ç”¨ json æˆ– csv")
    }
}

// exportCSV å¯¼å‡ºä¸º CSV æ ¼å¼
func (h *Handler) exportCSV(w http.ResponseWriter, todos []model.Todo) {
    // è®¾ç½®å“åº”å¤´
    w.Header().Set("Content-Type", "text/csv; charset=utf-8")
    w.Header().Set("Content-Disposition", "attachment; filename=todos.csv")

    // UTF-8 BOMï¼Œè®© Excel æ­£ç¡®è¯†åˆ«ä¸­æ–‡
    w.Write([]byte{0xEF, 0xBB, 0xBF})

    writer := csv.NewWriter(w)
    defer writer.Flush()

    // å†™å…¥è¡¨å¤´
    headers := []string{"ID", "æ ‡é¢˜", "æè¿°", "çŠ¶æ€", "æˆªæ­¢æ—¥æœŸ", "åˆ›å»ºæ—¶é—´", "å®Œæˆæ—¶é—´"}
    if err := writer.Write(headers); err != nil {
        log.Printf("å†™å…¥ CSV è¡¨å¤´å¤±è´¥: %v", err)
        return
    }

    // å†™å…¥æ•°æ®
    for _, todo := range todos {
        row := []string{
            strconv.Itoa(todo.ID),
            todo.Title,
            todo.Description,
            todo.Status,
            formatTimePtr(todo.DueDate),
            todo.CreatedAt.Format("2006-01-02 15:04:05"),
            formatTimePtr(todo.CompletedAt),
        }
        if err := writer.Write(row); err != nil {
            log.Printf("å†™å…¥ CSV è¡Œå¤±è´¥: %v", err)
            return
        }
    }
}

// exportJSON å¯¼å‡ºä¸º JSON æ ¼å¼
func (h *Handler) exportJSON(w http.ResponseWriter, todos []model.Todo) {
    w.Header().Set("Content-Type", "application/json; charset=utf-8")
    w.Header().Set("Content-Disposition", "attachment; filename=todos.json")

    // æ ¼å¼åŒ–è¾“å‡ºï¼Œæ–¹ä¾¿é˜…è¯»
    encoder := json.NewEncoder(w)
    encoder.SetIndent("", "  ")

    if err := encoder.Encode(todos); err != nil {
        log.Printf("å†™å…¥ JSON å¤±è´¥: %v", err)
    }
}

// formatTimePtr æ ¼å¼åŒ–æ—¶é—´æŒ‡é’ˆ
func formatTimePtr(t *time.Time) string {
    if t == nil {
        return ""
    }
    return t.Format("2006-01-02 15:04:05")
}
```

---

### æ­¥éª¤ 3: Handler å±‚ - å¯¼å…¥åŠŸèƒ½

```go
// ImportRequest å¯¼å…¥è¯·æ±‚ä½“(JSON æ ¼å¼)
type ImportRequest struct {
    Todos []ImportTodoItem `json:"todos"`
}

// ImportTodoItem å¯¼å…¥çš„å•ä¸ªå¾…åŠäº‹é¡¹
type ImportTodoItem struct {
    Title       string  `json:"title"`
    Description string  `json:"description"`
    Status      string  `json:"status"`
    DueDate     *string `json:"due_date"`
}

// ImportTodos å¯¼å…¥å¾…åŠäº‹é¡¹ï¼ˆå¸¦è¶…æ—¶æ§åˆ¶ï¼‰
func (h *Handler) ImportTodos(w http.ResponseWriter, r *http.Request) {
    // åˆ›å»ºå¸¦è¶…æ—¶çš„ Contextï¼ˆå¯¼å…¥å¯èƒ½æ•°æ®é‡å¤§ï¼Œè¶…æ—¶è®¾é•¿ä¸€äº›ï¼‰
    ctx, cancel := context.WithTimeout(r.Context(), ImportTimeout)
    defer cancel()

    // é™åˆ¶è¯·æ±‚ä½“å¤§å°
    r.Body = http.MaxBytesReader(w, r.Body, 10<<20) // 10MB
    defer r.Body.Close()

    contentType := r.Header.Get("Content-Type")

    var todos []model.Todo
    var err error

    if strings.HasPrefix(contentType, "multipart/form-data") {
        // æ–‡ä»¶ä¸Šä¼ æ–¹å¼
        todos, err = h.parseImportFile(r)
    } else {
        // JSON è¯·æ±‚ä½“æ–¹å¼
        todos, err = h.parseImportJSON(r)
    }

    if err != nil {
        h.sendError(w, http.StatusBadRequest, "PARSE_ERROR", err.Error())
        return
    }

    if len(todos) == 0 {
        h.sendError(w, http.StatusBadRequest, "EMPTY_DATA", "æ²¡æœ‰å¯å¯¼å…¥çš„æ•°æ®")
        return
    }

    // æ‰§è¡Œå¯¼å…¥ï¼ˆä½¿ç”¨ Context ç‰ˆæœ¬ï¼‰
    imported, err := h.db.ImportTodosContext(ctx, todos)
    if err != nil {
        // åŒºåˆ†è¶…æ—¶é”™è¯¯å’Œå…¶ä»–é”™è¯¯ï¼ˆä¸æ•™å­¦-5/6ä¸€è‡´ï¼‰
        if errors.Is(err, context.DeadlineExceeded) {
            log.Printf("ImportTodos timeout: %v", err)
            h.sendError(w, http.StatusRequestTimeout, "TIMEOUT", "å¯¼å…¥è¶…æ—¶ï¼Œæ•°æ®é‡è¿‡å¤§")
            return
        }
        if errors.Is(err, context.Canceled) {
            log.Printf("ImportTodos canceled: %v", err)
            return // å®¢æˆ·ç«¯å–æ¶ˆï¼Œä¸å“åº”
        }
        log.Printf("å¯¼å…¥å¤±è´¥: %v", err)
        h.sendError(w, http.StatusInternalServerError, "IMPORT_ERROR", err.Error())
        return
    }

    h.sendJSON(w, http.StatusOK, Response{
        Success: true,
        Data: map[string]interface{}{
            "imported": imported,
            "total":    len(todos),
        },
        Message: fmt.Sprintf("æˆåŠŸå¯¼å…¥ %d æ¡å¾…åŠäº‹é¡¹", imported),
    })
}

// parseImportJSON è§£æ JSON è¯·æ±‚ä½“
func (h *Handler) parseImportJSON(r *http.Request) ([]model.Todo, error) {
    var req ImportRequest
    if err := json.NewDecoder(r.Body).Decode(&req); err != nil {
        return nil, fmt.Errorf("JSON è§£æå¤±è´¥: %w", err)
    }

    todos := make([]model.Todo, 0, len(req.Todos))
    for _, item := range req.Todos {
        todo := model.Todo{
            Title:       strings.TrimSpace(item.Title),
            Description: strings.TrimSpace(item.Description),
            Status:      item.Status,
        }

        // è§£ææˆªæ­¢æ—¥æœŸ
        if item.DueDate != nil && *item.DueDate != "" {
            if t, err := time.Parse("2006-01-02", *item.DueDate); err == nil {
                todo.DueDate = &t
            } else if t, err := time.Parse(time.RFC3339, *item.DueDate); err == nil {
                todo.DueDate = &t
            }
        }

        todos = append(todos, todo)
    }

    return todos, nil
}

// parseImportFile è§£æä¸Šä¼ çš„æ–‡ä»¶
func (h *Handler) parseImportFile(r *http.Request) ([]model.Todo, error) {
    if err := r.ParseMultipartForm(10 << 20); err != nil {
        return nil, fmt.Errorf("è§£æè¡¨å•å¤±è´¥: %w", err)
    }

    file, header, err := r.FormFile("file")
    if err != nil {
        return nil, fmt.Errorf("è·å–æ–‡ä»¶å¤±è´¥: %w", err)
    }
    defer file.Close()

    filename := strings.ToLower(header.Filename)

    if strings.HasSuffix(filename, ".json") {
        return h.parseJSONFile(file)
    } else if strings.HasSuffix(filename, ".csv") {
        return h.parseCSVFile(file)
    }

    return nil, fmt.Errorf("ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼ï¼Œè¯·ä½¿ç”¨ .json æˆ– .csv")
}

// parseJSONFile è§£æ JSON æ–‡ä»¶
func (h *Handler) parseJSONFile(file io.Reader) ([]model.Todo, error) {
    var todos []model.Todo
    if err := json.NewDecoder(file).Decode(&todos); err != nil {
        return nil, fmt.Errorf("JSON æ–‡ä»¶è§£æå¤±è´¥: %w", err)
    }
    return todos, nil
}

// parseCSVFile è§£æ CSV æ–‡ä»¶
func (h *Handler) parseCSVFile(file io.Reader) ([]model.Todo, error) {
    reader := csv.NewReader(file)

    // è¯»å–è¡¨å¤´
    headers, err := reader.Read()
    if err != nil {
        return nil, fmt.Errorf("è¯»å– CSV è¡¨å¤´å¤±è´¥: %w", err)
    }

    // å»ºç«‹åˆ—ååˆ°ç´¢å¼•çš„æ˜ å°„
    colIndex := make(map[string]int)
    for i, h := range headers {
        colIndex[strings.ToLower(strings.TrimSpace(h))] = i
    }

    // æ£€æŸ¥å¿…éœ€åˆ—
    titleIdx, hasTitleCol := colIndex["æ ‡é¢˜"]
    if !hasTitleCol {
        titleIdx, hasTitleCol = colIndex["title"]
    }
    if !hasTitleCol {
        return nil, fmt.Errorf("CSV ç¼ºå°‘æ ‡é¢˜åˆ—")
    }

    var todos []model.Todo
    lineNum := 1

    for {
        lineNum++
        record, err := reader.Read()
        if err == io.EOF {
            break
        }
        if err != nil {
            return nil, fmt.Errorf("è¯»å–ç¬¬ %d è¡Œå¤±è´¥: %w", lineNum, err)
        }

        todo := model.Todo{
            Title: strings.TrimSpace(record[titleIdx]),
        }

        // å¯é€‰åˆ—
        if idx, ok := colIndex["æè¿°"]; ok && idx < len(record) {
            todo.Description = strings.TrimSpace(record[idx])
        } else if idx, ok := colIndex["description"]; ok && idx < len(record) {
            todo.Description = strings.TrimSpace(record[idx])
        }

        if idx, ok := colIndex["çŠ¶æ€"]; ok && idx < len(record) {
            todo.Status = strings.TrimSpace(record[idx])
        } else if idx, ok := colIndex["status"]; ok && idx < len(record) {
            todo.Status = strings.TrimSpace(record[idx])
        }

        todos = append(todos, todo)
    }

    return todos, nil
}
```

---

### æ­¥éª¤ 4: æ³¨å†Œè·¯ç”±

åœ¨ `api/routes.go` çš„ `registerTodoRoutes` é—­åŒ…ä¸­æ·»åŠ ï¼ˆå‚è€ƒå½“å‰é¡¹ç›®ç»“æ„ `api/routes.go:58-68`ï¼‰:

```go
registerTodoRoutes := func(base string) {
    mux.HandleFunc("GET "+base, withMiddlewares(h.ListTodos))
    mux.HandleFunc("POST "+base, withMiddlewares(h.CreateTodo))
    mux.HandleFunc("OPTIONS "+base, withMiddlewares(optionsHandler))

    mux.HandleFunc("GET "+base+"/stats", withMiddlewares(h.GetStats))

    // æ•™å­¦-5/6ï¼šæ‰¹é‡æ“ä½œè·¯ç”±ï¼ˆå¦‚æœå·²å®ç°ï¼‰
    // mux.HandleFunc("POST "+base+"/batch/complete", ...)
    // mux.HandleFunc("POST "+base+"/batch/delete", ...)

    // æ•™å­¦-7ï¼šå¯¼å…¥å¯¼å‡ºè·¯ç”±
    mux.HandleFunc("GET "+base+"/export", withMiddlewares(h.ExportTodos))
    mux.HandleFunc("POST "+base+"/import", withMiddlewares(h.ImportTodos))
    mux.HandleFunc("OPTIONS "+base+"/export", withMiddlewares(optionsHandler))
    mux.HandleFunc("OPTIONS "+base+"/import", withMiddlewares(optionsHandler))

    mux.HandleFunc("PUT "+base+"/{id}", withMiddlewares(h.UpdateTodo))
    mux.HandleFunc("DELETE "+base+"/{id}", withMiddlewares(h.DeleteTodo))
    mux.HandleFunc("OPTIONS "+base+"/{id}", withMiddlewares(optionsHandler))
}
```

**è·¯ç”±é¡ºåºè¯´æ˜**ï¼š
- `/export` å’Œ `/import` å¿…é¡»åœ¨ `/{id}` ä¹‹å‰æ³¨å†Œ
- ä¸ `/stats`ã€`/batch/*` è·¯ç”±æ”¾åœ¨åŒä¸€åŒºåŸŸ

---

## âš ï¸ å…³é”®ç‚¹è§£æ

### 1. UTF-8 BOM é—®é¢˜

**é—®é¢˜**: Excel æ‰“å¼€ CSV æ—¶ä¸­æ–‡ä¹±ç 

**åŸå› **: Excel é»˜è®¤ä½¿ç”¨ç³»ç»Ÿç¼–ç (GBK)æ‰“å¼€ CSV

**è§£å†³**: åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ  UTF-8 BOM
```go
// UTF-8 BOM: 0xEF 0xBB 0xBF
w.Write([]byte{0xEF, 0xBB, 0xBF})
```

---

### 2. æµå¼å¤„ç† vs å…¨é‡åŠ è½½

**å°æ•°æ®é‡**(< 1000 æ¡): å…¨é‡åŠ è½½æ²¡é—®é¢˜
```go
todos, _ := db.GetAll()
json.Marshal(todos)
```

**å¤§æ•°æ®é‡**(> 10000 æ¡): å¿…é¡»æµå¼å¤„ç†
```go
// è¾¹æŸ¥è¯¢è¾¹å†™å…¥ï¼Œå†…å­˜å ç”¨ O(1)
rows, _ := db.Query("SELECT ...")
for rows.Next() {
    todo := scanTodo(rows)
    encoder.Encode(todo)  // ç«‹å³å†™å…¥å“åº”
}
```

---

### 3. å®‰å…¨æ€§è€ƒè™‘

**è¾“å…¥éªŒè¯**:
```go
// é™åˆ¶æ–‡ä»¶å¤§å°
r.Body = http.MaxBytesReader(w, r.Body, 10<<20)

// éªŒè¯æ–‡ä»¶ç±»å‹
if !strings.HasSuffix(filename, ".json") {
    return error
}

// æ¸…æ´—æ•°æ®
title := strings.TrimSpace(input.Title)
if len(title) > 500 {
    title = title[:500]  // æˆªæ–­
}
```

**é˜²æ­¢ SQL æ³¨å…¥**: ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢(å·²æœ‰)

---

### 4. äº‹åŠ¡ä¿è¯åŸå­æ€§ï¼ˆä¸æ•™å­¦-5/6ä¸€è‡´ï¼‰

```go
// å¯¼å…¥è¦ä¹ˆå…¨éƒ¨æˆåŠŸï¼Œè¦ä¹ˆå…¨éƒ¨å¤±è´¥
// æ³¨æ„ï¼šä½¿ç”¨å‘½åè¿”å›å€¼ (err error)ï¼Œè®© defer èƒ½è®¿é—®åˆ°é”™è¯¯
func importWithTx(ctx context.Context, todos []model.Todo) (err error) {
    tx, err := db.conn.BeginTx(ctx, nil)
    if err != nil {
        return err
    }

    defer func() {
        if err != nil {
            if rbErr := tx.Rollback(); rbErr != nil {
                log.Printf("å›æ»šå¤±è´¥: %v", rbErr)
            }
        }
    }()

    // é¢„å…ˆå£°æ˜ stmtï¼Œé¿å…åœ¨ä¸‹é¢ä½¿ç”¨ := é®è”½ err
    var stmt *sql.Stmt
    stmt, err = tx.PrepareContext(ctx, "INSERT INTO ...")
    if err != nil {
        return err
    }
    defer stmt.Close()

    for _, todo := range todos {
        // æ£€æŸ¥ Context æ˜¯å¦å·²å–æ¶ˆ
        select {
        case <-ctx.Done():
            err = ctx.Err()
            return err
        default:
        }

        // ä½¿ç”¨ = èµ‹å€¼ï¼Œä¸è¦ç”¨ :=ï¼ˆä¼šé®è”½å‘½åè¿”å›å€¼ errï¼‰
        _, err = stmt.ExecContext(ctx, ...)
        if err != nil {
            return err  // è§¦å‘ defer å›æ»š
        }
    }

    err = tx.Commit()
    return err
}
```

> **å…³é”®ç‚¹**ï¼šè¯¦è§æ•™å­¦-5"å¸¸è§é™·é˜±"ç¬¬6æ¡ï¼ˆå˜é‡é®è”½å¯¼è‡´ defer å¤±æ•ˆï¼‰ã€‚

---

## ğŸ§ª æµ‹è¯•ç¤ºä¾‹

### æµ‹è¯•è„šæœ¬

```bash
#!/bin/bash

BASE_URL="http://localhost:7789/api/v1/todos"

echo "=== 1. åˆ›å»ºæµ‹è¯•æ•°æ® ==="
for i in {1..5}; do
  curl -s -X POST "$BASE_URL" \
    -H "Content-Type: application/json" \
    -d "{\"title\": \"æµ‹è¯•ä»»åŠ¡ $i\", \"description\": \"æè¿° $i\"}" > /dev/null
done
echo "åˆ›å»ºäº† 5 æ¡æµ‹è¯•æ•°æ®"

echo -e "\n=== 2. æµ‹è¯• JSON å¯¼å‡º ==="
curl -s "$BASE_URL/export?format=json" -o todos.json
echo "å¯¼å‡ºåˆ° todos.jsonï¼Œå†…å®¹:"
head -20 todos.json

echo -e "\n=== 3. æµ‹è¯• CSV å¯¼å‡º ==="
curl -s "$BASE_URL/export?format=csv" -o todos.csv
echo "å¯¼å‡ºåˆ° todos.csvï¼Œå†…å®¹:"
cat todos.csv

echo -e "\n=== 4. æµ‹è¯• JSON å¯¼å…¥ ==="
curl -X POST "$BASE_URL/import" \
  -H "Content-Type: application/json" \
  -d '{
    "todos": [
      {"title": "å¯¼å…¥ä»»åŠ¡ 1", "description": "é€šè¿‡ API å¯¼å…¥"},
      {"title": "å¯¼å…¥ä»»åŠ¡ 2", "status": "completed"},
      {"title": "å¯¼å…¥ä»»åŠ¡ 3", "due_date": "2024-12-31"}
    ]
  }'

echo -e "\n\n=== 5. æµ‹è¯•æ–‡ä»¶ä¸Šä¼ å¯¼å…¥ ==="
curl -X POST "$BASE_URL/import" \
  -F "file=@todos.json"

echo -e "\n\n=== 6. æµ‹è¯•é”™è¯¯æƒ…å†µ ==="
# ç©ºæ•°æ®
curl -X POST "$BASE_URL/import" \
  -H "Content-Type: application/json" \
  -d '{"todos": []}'

# æ— æ•ˆæ ¼å¼
curl -s "$BASE_URL/export?format=xml"
```

---

## âœ… å®ç°æ£€æŸ¥æ¸…å•

**å¯¼å‡ºåŠŸèƒ½**:
- [ ] JSON æ ¼å¼å¯¼å‡ºæ­£å¸¸
- [ ] CSV æ ¼å¼å¯¼å‡ºæ­£å¸¸
- [ ] CSV åœ¨ Excel ä¸­æ‰“å¼€ä¸­æ–‡ä¸ä¹±ç 
- [ ] Content-Disposition è§¦å‘ä¸‹è½½
- [ ] ç©ºæ•°æ®æ—¶è¿”å›ç©ºæ•°ç»„/ç©ºæ–‡ä»¶
- [ ] è¶…æ—¶æƒ…å†µè¿”å›æ­£ç¡®çš„é”™è¯¯ç ï¼ˆ408ï¼‰

**å¯¼å…¥åŠŸèƒ½**:
- [ ] JSON è¯·æ±‚ä½“å¯¼å…¥æ­£å¸¸
- [ ] JSON æ–‡ä»¶ä¸Šä¼ å¯¼å…¥æ­£å¸¸
- [ ] CSV æ–‡ä»¶ä¸Šä¼ å¯¼å…¥æ­£å¸¸
- [ ] ç©ºæ•°æ®æ—¶è¿”å›å‹å¥½æç¤º
- [ ] è¶…å¤§æ–‡ä»¶è¢«æ‹’ç»(10MB é™åˆ¶)
- [ ] æ— æ•ˆæ ¼å¼è¿”å›é”™è¯¯
- [ ] äº‹åŠ¡ä¿è¯åŸå­æ€§
- [ ] è¶…æ—¶æƒ…å†µè¿”å›æ­£ç¡®çš„é”™è¯¯ç ï¼ˆ408ï¼‰

**Context æ”¯æŒ**ï¼ˆä¸æ•™å­¦-5/6ä¸€è‡´ï¼‰:
- [ ] ä½¿ç”¨ `BeginTx(ctx, nil)` è€Œä¸æ˜¯ `Begin()`
- [ ] ä½¿ç”¨ `QueryContext`ã€`ExecContext`ã€`PrepareContext`
- [ ] åœ¨å¾ªç¯ä¸­æ£€æŸ¥ `ctx.Done()`
- [ ] Handler å±‚ä½¿ç”¨ `context.WithTimeout`
- [ ] åŒºåˆ† `context.DeadlineExceeded` å’Œ `context.Canceled`

**å®‰å…¨æ€§**:
- [ ] æ–‡ä»¶å¤§å°é™åˆ¶ç”Ÿæ•ˆ
- [ ] æ•°æ®éªŒè¯(æ ‡é¢˜éç©ºç­‰)
- [ ] ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢

---

## ğŸ’¡ å¸¸è§é—®é¢˜ FAQ

### Q1: ä¸ºä»€ä¹ˆ CSV è¦ç”¨ BOM?

**ç­”**: Excel æ‰“å¼€ CSV æ—¶é»˜è®¤ä½¿ç”¨ç³»ç»Ÿç¼–ç (Windows æ˜¯ GBK)ã€‚æ·»åŠ  UTF-8 BOM (0xEF 0xBB 0xBF) åï¼ŒExcel ä¼šè¯†åˆ«ä¸º UTF-8 ç¼–ç ã€‚

### Q2: å¯¼å…¥å¤§é‡æ•°æ®æ—¶åº”è¯¥æ€ä¹ˆä¼˜åŒ–?

**ç­”**:
1. **æ‰¹é‡æ’å…¥**: ä½¿ç”¨ `INSERT INTO ... VALUES (...), (...), (...)` å‡å°‘å¾€è¿”æ¬¡æ•°
2. **äº‹åŠ¡**: ä¸€ä¸ªäº‹åŠ¡å†…å®Œæˆæ‰€æœ‰æ’å…¥
3. **ç¦ç”¨ç´¢å¼•**: å¤§é‡æ’å…¥å‰ç¦ç”¨ç´¢å¼•ï¼Œæ’å…¥åé‡å»º
4. **åˆ†æ‰¹å¤„ç†**: æ¯ 1000 æ¡æäº¤ä¸€æ¬¡ï¼Œé˜²æ­¢äº‹åŠ¡è¿‡å¤§

### Q3: å¦‚ä½•æ”¯æŒæ›´å¤šæ ¼å¼(Excel)?

**ç­”**: ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“:
- Excel: `github.com/xuri/excelize/v2`
- YAML: `gopkg.in/yaml.v3`

ä½†å¯¹äºå­¦ä¹ é¡¹ç›®ï¼ŒJSON å’Œ CSV å·²ç»è¶³å¤Ÿã€‚

### Q4: å¯¼å‡ºå¤§é‡æ•°æ®æ—¶å¦‚ä½•æ˜¾ç¤ºè¿›åº¦?

**ç­”**: HTTP ä¸é€‚åˆæ˜¾ç¤ºè¿›åº¦ã€‚å¯ä»¥:
1. å¼‚æ­¥å¯¼å‡º + è½®è¯¢çŠ¶æ€
2. ä½¿ç”¨ Server-Sent Events
3. åˆ†é¡µå¯¼å‡º

---

## ğŸš€ å®ç°æ­¥éª¤å»ºè®®

**ç¬¬ 1 æ­¥**: æ·»åŠ è¶…æ—¶å¸¸é‡ï¼ˆå¦‚æœæ•™å­¦-5/6æœªæ·»åŠ ï¼‰
- åœ¨ `handler/handler.go` ä¸­æ·»åŠ  `ExportTimeout` å’Œ `ImportTimeout`

**ç¬¬ 2 æ­¥**: å®ç° `database/db.go` ä¸­çš„ `ImportTodosContext` å’Œ `ExportTodosContext`
- ä½¿ç”¨ `BeginTx(ctx, nil)` å¼€å¯äº‹åŠ¡
- ä½¿ç”¨ `PrepareContext`ã€`ExecContext`ã€`QueryContext`
- åœ¨å¾ªç¯ä¸­æ£€æŸ¥ `ctx.Done()`

**ç¬¬ 3 æ­¥**: å®ç° `handler/handler.go` ä¸­çš„å¯¼å‡ºåŠŸèƒ½
- æ·»åŠ  Context è¶…æ—¶æ§åˆ¶
- åŒºåˆ†è¶…æ—¶/å–æ¶ˆ/å…¶ä»–é”™è¯¯

**ç¬¬ 4 æ­¥**: å®ç°å¯¼å…¥åŠŸèƒ½(å…ˆ JSONï¼Œå CSV)
- åŒæ ·æ·»åŠ  Context è¶…æ—¶æ§åˆ¶

**ç¬¬ 5 æ­¥**: æ³¨å†Œè·¯ç”±
- åœ¨ `/{id}` ä¹‹å‰æ³¨å†Œ `/export` å’Œ `/import`

**ç¬¬ 6 æ­¥**: ä½¿ç”¨æµ‹è¯•è„šæœ¬éªŒè¯

---

**ä¸æ•™å­¦-5/6çš„ä¸€è‡´æ€§**ï¼š
- å‡½æ•°å‘½åï¼š`xxxContext` åç¼€
- äº‹åŠ¡å¤„ç†ï¼š`BeginTx` + `defer Rollback`
- è¶…æ—¶æ§åˆ¶ï¼š`context.WithTimeout` + é”™è¯¯åŒºåˆ†

**ç°åœ¨ï¼Œå¼€å§‹å®ç°å¯¼å…¥å¯¼å‡ºåŠŸèƒ½å§ï¼è®°ä½ï¼šæµå¼å¤„ç†ã€äº‹åŠ¡ä¿è¯ã€Context è¶…æ—¶ã€å®‰å…¨éªŒè¯ã€‚** ğŸš€
