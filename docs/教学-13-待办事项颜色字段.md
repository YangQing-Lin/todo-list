# 教学-13：待办事项颜色字段

## 功能需求

当前待办事项的颜色是前端通过 CSS `:nth-child` 选择器按位置循环分配的，这意味着删除或新增 Todo 后，现有 Todo 的颜色会发生变化。

**目标**：让每个待办事项在创建时就固定一个颜色，存储在数据库中，这样无论增删其他项目，颜色都不会变。

## 前端已完成的修改

前端已经修改完毕，会在创建 Todo 时发送 `color` 字段：

```typescript
// frontend/src/types/index.ts
export const TODO_COLORS = [
  '#FFE066', // Yellow
  '#7DFFAF', // Mint
  '#FF9ECD', // Pink
  '#9EE5FF', // Cyan
  '#D4ADFF', // Purple
  '#FFB399', // Peach
] as const;

export interface CreateTodoRequest {
  title: string;
  description?: string;
  color?: string;  // 新增：颜色字段
}

export interface Todo {
  // ... 其他字段
  color?: string;  // 新增：颜色字段
}
```

前端在创建时会随机选择一个颜色发送，渲染时优先使用 Todo 自带的颜色，对于没有 color 字段的旧数据会根据 ID 计算一个稳定的默认颜色。

---

## 后端实现步骤

你需要修改 4 个文件：

### 步骤 1：修改 Model（model/todo.go）

**位置**：`model/todo.go:8-18`

在 `Todo` 结构体中添加 `Color` 字段：

```go
// Todo 表示一个待办事项
type Todo struct {
    ID          int        `json:"id"`
    Version     int        `json:"version"`
    Title       string     `json:"title"`
    Description string     `json:"description"`
    Status      string     `json:"status"`
    Color       string     `json:"color,omitempty"`  // 新增：待办事项颜色
    DueDate     *time.Time `json:"due_date,omitempty"`
    CreatedAt   time.Time  `json:"created_at"`
    UpdatedAt   time.Time  `json:"updated_at"`
    CompletedAt *time.Time `json:"completed_at,omitempty"`
}
```

**修改 `NewTodo` 函数**（`model/todo.go:21-31`）：

添加 `color` 参数：

```go
// NewTodo 创建一个新的待办事项
func NewTodo(title, description, color string) *Todo {
    now := time.Now()
    return &Todo{
        Version:     1,
        Title:       title,
        Description: description,
        Status:      "pending",
        Color:       color,
        CreatedAt:   now,
        UpdatedAt:   now,
    }
}
```

---

### 步骤 2：修改 Handler（handler/handler.go）

**位置**：`handler/handler.go:25-28`

修改 `CreateTodoRequest` 结构体：

```go
// CreateTodoRequest 创建待办事项请求体
type CreateTodoRequest struct {
    Title       string `json:"title" example:"Buy groceries"`
    Description string `json:"description" example:"Milk, bread, and fruits"`
    Color       string `json:"color" example:"#FFE066"`  // 新增
}
```

**位置**：`handler/handler.go:210-211`

修改 `CreateTodo` 函数中创建 Todo 的代码：

```go
// 原来的代码：
// todo := model.NewTodo(req.Title, req.Description)

// 改为：
todo := model.NewTodo(req.Title, req.Description, req.Color)
```

---

### 步骤 3：修改数据库迁移（database/db.go）

项目已经有 `ensureVersionColumn` 作为数据库迁移的模板。你需要创建一个类似的函数来添加 `color` 列。

**添加新函数** `ensureColorColumn`（参考 `database/db.go:68-112`）：

```go
// ensureColorColumn 确保 color 列存在（数据库迁移）
func (db *DB) ensureColorColumn() error {
    rows, err := db.conn.Query(`PRAGMA table_info(todos);`)
    if err != nil {
        return fmt.Errorf("failed to inspect todos table: %w", err)
    }
    defer rows.Close()

    hasColorColumn := false
    for rows.Next() {
        var (
            cid        int
            name       string
            dataType   string
            notNull    int
            defaultVal sql.NullString
            pk         int
        )
        if err := rows.Scan(&cid, &name, &dataType, &notNull, &defaultVal, &pk); err != nil {
            return fmt.Errorf("failed to scan todos schema: %w", err)
        }
        if name == "color" {
            hasColorColumn = true
            break
        }
    }

    if err := rows.Err(); err != nil {
        return fmt.Errorf("failed to iterate todos schema: %w", err)
    }

    if hasColorColumn {
        return nil  // 列已存在，无需迁移
    }

    // 添加 color 列（允许 NULL，旧数据不需要默认值）
    alterStmt := `ALTER TABLE todos ADD COLUMN color TEXT`
    if _, err := db.conn.Exec(alterStmt); err != nil {
        return fmt.Errorf("failed to add color column: %w", err)
    }

    log.Println("Database migration: added 'color' column to todos table")
    return nil
}
```

**在 `initSchema` 中调用**（`database/db.go:42-66`）：

```go
func (db *DB) initSchema() error {
    // ... 现有的 schema 创建代码 ...

    if _, err := db.conn.Exec(schema); err != nil {
        return err
    }

    // 现有的迁移
    if err := db.ensureVersionColumn(); err != nil {
        return err
    }

    // 新增：颜色列迁移
    if err := db.ensureColorColumn(); err != nil {
        return err
    }

    return nil
}
```

---

### 步骤 4：修改数据库 CRUD（database/db.go）

#### 4.1 修改 CreateTodo（`database/db.go:120-147`）

```go
func (db *DB) CreateTodo(todo *model.Todo) error {
    query := `
        INSERT INTO todos (title, description, status, color, due_date, created_at, updated_at, version)
        VALUES (?, ?, ?, ?, ?, ?, ?, ?)
    `

    result, err := db.conn.Exec(
        query,
        todo.Title,
        todo.Description,
        todo.Status,
        todo.Color,  // 新增
        todo.DueDate,
        todo.CreatedAt,
        todo.UpdatedAt,
        todo.Version,
    )
    // ... 后续代码不变
}
```

#### 4.2 修改 ListTodos（`database/db.go:177` 和 `database/db.go:247-257`）

修改 SELECT 语句和 Scan：

```go
// 修改 baseQuery（第 177 行附近）
baseQuery := "SELECT id, version, title, description, status, color, due_date, created_at, updated_at, completed_at FROM todos WHERE 1=1"

// 修改 Scan（第 247-257 行附近）
for rows.Next() {
    var todo model.Todo
    var dueDate, completedAt sql.NullString
    var color sql.NullString  // 新增：处理可能为 NULL 的 color

    err := rows.Scan(
        &todo.ID,
        &todo.Version,
        &todo.Title,
        &todo.Description,
        &todo.Status,
        &color,  // 新增
        &dueDate,
        &todo.CreatedAt,
        &todo.UpdatedAt,
        &completedAt,
    )
    if err != nil {
        return nil, 0, fmt.Errorf("扫描失败: %w", err)
    }

    // 处理 color NULL 值
    if color.Valid {
        todo.Color = color.String
    }

    // ... 后续 dueDate 和 completedAt 处理不变
}
```

#### 4.3 修改 GetTodoByID（`database/db.go:279-308`）

```go
func (db *DB) GetTodoByID(id int) (*model.Todo, error) {
    query := `
        SELECT id, version, title, description, status, color, due_date,
               created_at, updated_at, completed_at
        FROM todos
        WHERE id = ?
    `

    var todo model.Todo
    var color sql.NullString  // 新增

    err := db.conn.QueryRow(query, id).Scan(
        &todo.ID,
        &todo.Version,
        &todo.Title,
        &todo.Description,
        &todo.Status,
        &color,  // 新增
        &todo.DueDate,
        &todo.CreatedAt,
        &todo.UpdatedAt,
        &todo.CompletedAt,
    )

    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, fmt.Errorf("failed to get todo: %w", err)
    }

    // 处理 color NULL 值
    if color.Valid {
        todo.Color = color.String
    }

    return &todo, nil
}
```

---

## 关键知识点

### 1. 为什么 color 字段用 `sql.NullString`？

SQLite 中新增的列对于旧数据会是 `NULL`。Go 的 `string` 类型不能直接接收 `NULL` 值，会导致 scan 错误。使用 `sql.NullString` 可以安全处理：

```go
var color sql.NullString
// ...
if color.Valid {
    todo.Color = color.String  // 有值
} else {
    todo.Color = ""  // NULL，保持空字符串
}
```

### 2. 数据库迁移的幂等性

`ensureColorColumn` 函数在每次启动时都会检查列是否存在：
- 如果存在，跳过（幂等）
- 如果不存在，执行 `ALTER TABLE`

这样无论服务重启多少次，迁移只会执行一次。

### 3. 向后兼容

- 前端：没有 `color` 的旧数据会根据 ID 计算默认颜色
- 后端：`color` 列允许 NULL，不影响旧数据
- API：`color` 字段是可选的（`omitempty`）

---

## 测试验证

### 1. 启动服务并检查迁移日志

```bash
go run cmd/server/main.go
```

应该看到类似日志：
```
Database migration: added 'color' column to todos table
```

### 2. 测试 API

```bash
# 创建带颜色的 Todo
curl -X POST http://localhost:7789/api/v1/todos \
  -H "Content-Type: application/json" \
  -d '{"title": "Test Color", "color": "#FFE066"}'

# 获取列表，验证 color 字段
curl http://localhost:7789/api/v1/todos | jq
```

### 3. 前端测试

```bash
cd frontend && npm run dev
```

- 创建新 Todo，观察颜色
- 删除中间的 Todo，验证其他 Todo 颜色不变
- 刷新页面，验证颜色持久化

---

## 完成清单

- [ ] model/todo.go: 添加 `Color` 字段到 `Todo` 结构体
- [ ] model/todo.go: 修改 `NewTodo` 函数签名，添加 `color` 参数
- [ ] handler/handler.go: 添加 `Color` 字段到 `CreateTodoRequest`
- [ ] handler/handler.go: 修改 `CreateTodo` 调用 `NewTodo` 时传入 `req.Color`
- [ ] database/db.go: 添加 `ensureColorColumn` 迁移函数
- [ ] database/db.go: 在 `initSchema` 中调用 `ensureColorColumn`
- [ ] database/db.go: 修改 `CreateTodo` 的 INSERT 语句
- [ ] database/db.go: 修改 `ListTodos` 的 SELECT 和 Scan
- [ ] database/db.go: 修改 `GetTodoByID` 的 SELECT 和 Scan
- [ ] 测试：启动服务，创建新 Todo，验证颜色字段正常工作

---

## 进阶思考

1. **颜色验证**：是否应该在后端验证 `color` 是否是有效的十六进制颜色？
2. **默认颜色**：如果前端不传 `color`，后端应该随机生成还是留空？
3. **颜色选择**：未来可能让用户手动选择颜色？

这些问题没有标准答案，取决于产品需求。当前设计是最简单的：前端负责生成颜色，后端只负责存储。
