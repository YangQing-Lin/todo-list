# Scripts - 测试与工具

> "Talk is cheap. Show me the code." - Linus Torvalds

## 问题背景

原始代码存在典型的包冲突问题：
```
main redeclared in this block
```

两个测试脚本都在同一个 `package main` 中定义了 `main` 函数。这在Go中是编译错误，不是一个"可以修复"的bug，而是**根本性的设计错误**。

## 解决方案

### 核心原则
1. **一个包，一个main** - 每个可执行程序独立打包
2. **简单优于复杂** - 避免过度抽象的共享包
3. **清晰分离** - 不同的测试目的应该有不同的程序

### 目录结构
```
scripts/
├── api-test/          # 纯后端API测试
│   └── main.go       # test_api.go 的重构版本
├── frontend-test/     # 前后端集成测试
│   └── main.go       # test_frontend_api.go 的重构版本
└── README.md         # 你正在看的文件
```

## 使用方法

### 后端API测试
```bash
cd scripts/api-test
go run main.go
```

测试内容：
- 健康检查 `/`
- 获取Todo列表 `/api/todos`
- 创建新Todo项
- 验证数据持久化

### 前端集成测试
```bash
cd scripts/frontend-test
go run main.go
```

测试内容：
- 后端API全部功能
- 前端代理到后端的连通性
- 跨域配置验证

## 设计决策

### 为什么不创建共享包？

**错误的想法**：创建一个 `testutils` 包来消除代码重复

**为什么这是错的**：
1. **过度设计** - 90%的重复代码不是问题，重复的简单逻辑比复杂的抽象更好
2. **维护成本** - 每个测试的细微差异会导致包参数化复杂化
3. **Go哲学** - "A little copying is better than a little dependency"

### Linus的观点

"如果你需要抽象层来解决问题，那你的数据结构可能设计错了。"

这里的"数据结构"就是程序组织方式。两个独立的测试程序就应该保持独立，而不是通过复杂的抽象强行耦合。

## 技术细节

### 测试工具函数

每个测试脚本都有自己的 `TestEndpoint` 函数。虽然代码相同，但这是**有意为之**：

1. **独立性** - 每个测试可以独立修改，不影响其他测试
2. **可读性** - 所有逻辑在一个文件里，无需跳转
3. **部署简单** - 单个文件复制即可运行

### 错误处理

采用Go的错误处理惯例：
```go
if err != nil {
    fmt.Printf("❌ 操作失败: %v\n", err)
    return
}
```

## 未来扩展

如果需要添加新的测试类型：

1. **创建新目录** - `scripts/new-test-type/`
2. **复制现有代码** - 选择最接近的测试脚本作为模板
3. **修改测试逻辑** - 根据新需求调整

**绝对不要**：
- 创建"通用测试框架"
- 过度抽象现有代码
- 为了消除重复而引入复杂性

记住：**能用就行**。测试代码不是生产代码，简单直接更重要。